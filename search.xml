<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Euler-技术总监-简历]]></title>
    <url>%2F2019%2F08%2F28%2Fresume%2F</url>
    <content type="text"><![CDATA[Euler-技术总监-简历联系方式 Email：xuanshuangchen@gmail.com QQ/微信号：471023334/xuanshuangchen 个人信息 Euler/男/1989 本科/四川大学-计算机科学与技术 2008/7-2012/9 技术博客：https://euler-king.github.io Github：https://github.com/euler-king CSDN: https://blog.csdn.net/jiangxuexuanshuang 期望职位：技术总监，技术经理 目前状态：在职，未考虑新工作 工作经历广州睿维科技有限公司 | 技术总监 | 2018年4月 ~ 至今工作描述1、公司研发技术体系搭建，公司技术架构不断优化升级。 2、项目计划安排，人员分工，人才招聘，人才培养。 3、技术选型，系统设计，功能开发，难题解决，进度推进，资源沟通。 4、管理研发团队睿维云平台1、 作为公司未来几年的基础架构，为各种业务系统提供快速的技术支撑。云平台主要为公司提供可持续的技术积累，为公司的微服务化向前推进，快速开发提供技术支撑。2、 个人职责： 系统相关技术研究，技术实现，尽量提高开发效率，如一套代码全平台使用（Android,IOS,web,小程序）。 开发计划制定、进度推进与跟踪、数据库设计。 前端、后端、App框架搭建。 整体系统开发，code review。 3、 该系统分为管理后台Web、Android/IOS的用户端App、Android/IOS的管理后台App三个端，主要为提供机场行业解决方案。子系统分为：基础平台，各个业务系统。4、 基础平台提供：字典配置、系统参数配置、多语言配置、组织架构相关管理、权限管理、模块管理等功能。主要为业务系统提供基础数据。5、 负责选型与落地实现以下的相应技术、框架。 后台框架采用Spring Cloud Config，Spring Cloud Bus，Spring Cloud Eureka，Spring Cloud Gateway等Spring Cloud一系列框架，Spring Security、Spring boot、mybatis、netty、redis、fastdfs、postgresql等技术。Netty主要用来与前端进行实时交互。Redis缓存主要用来存储用户权限信息，系统配置、频繁请求的数据等信息。Fastdfs用于保存平台的一系列图片，如用户头像，物品图片等。 管理后台PC端使用了vue+vue-router+element-ui+axios等技术。 Android与IOS用户端和管理后台App采用Cordova+vue+vue-router+element-ui的架构，实现跨平台的开发。编写shell的Android、IOS一键打包脚本，提高打包效率和打包的准确性。 小程序采用：mpvue + web-view + vue-router代理的方式，mpvue提供壳，其余使用H5开发，使程序同时适用于Android，IOS，小程序。 小蛙游戏1、 负责系统的开发计划制定、进度推进与跟踪、数据库设计，系统设置，前端、后端、App框架搭建，整体系统开发。2、 该系统分为管理后台、Android/IOS的用户端App、Android/IOS的管理端App、用户收款App四个大的模块，主要提供了游戏周边的功能服务。 管理后台提供了系统整体的基础数据管理功能，如数据字典、RBAC用户角色权限管理、缓存管理、商品管理等，也包含了部分比赛的创建、监控等功能。 用户端App分为首页、比赛、游戏、社区、商场几个主要模块。用户可以购买相应的商品获取积分，并使用积分参与比赛；赢得比赛后可以获取相应的积金；通过积金可以在商城兑换相应的商品。同时可以进行用户的积分和积金的转赠，添加了二维码的生成和扫描的功能，方便了系统的使用流程，比如转赠，加入社区等。提供了分享功能，对接微信平台，便于用户与好友分享。 管理端App主要有首页、比赛模块。首页展示用户的账户信息，并提供对商品库存的管理、收益的查看。比赛模块提供社区比赛的创建、维护等功能。 3、 负责选型与落地实现以下的相应技术、框架。 后台框架采用Spring boot、Spring、SpringMVC、mybatis、netty、redis、fastdfs、postgresql框架。Netty主要用来与收款app进行交互。Redis缓存主要用来存储用户权限信息，系统配置、频繁请求的数据等信息。Fastdfs用于保存平台的一系列图片，如商品图片，用户头像等。Nginx负责对后台的数据转发与负载均衡。 管理后台PC端使用了vue+vue-router+iview+axios等技术。 Android与IOS用户端和管理端App采用Cordova+vue+vue-router+mint-ui的架构，实现跨平台的开发。编写shell的Android、IOS一键打包脚本，提高打包效率和打包的准确性。 收款App是二次开发，修改了原先的Http需要渗透配置的安全问题，交互采用websocket的方式，通过客户端发起连接，进行双向通信，达到收款实时的目的。 广州朗睿科技发展有限公司 | 技术经理 | 2016年4月 ~ 2017年12月工作描述1、技术架构搭建与实现。 2、系统设计，功能开发，难题解决，进度推进，资源沟通。 3、管理研发团队安检系统1、 负责项目的系统设计，架构搭建，问题处理，项目进度推进。2、 产品为机场提供整套的安检流程。也为机场货站提供货物安检功能，保证货物流转过程中的高危违禁等物品的检测。系统分为主要分为管理后台、监控中心、开包台客户端、验证台客户端等多个子系统。 管理后台提供对业务的基础数据配置，如通道管理、设备管理、拦截管理、报表统计。 监控中心包含通道的视频监控、旅客监控、物品开包监控、拦截监控等功能。 验证台主要根据旅客的身份证、人脸识别、登机牌等进行验证。 开包台通过X光机进行物品图像采集，对图像开包处理，人工判别，并操作的功能。 3、 后台接口系统设计，mybatis generator进行二次开发（提高团队开发效率），maven插件开发，技术组件开发：如消息中间件（activemq）、文件服务连接池开发（ftp连接池、fastdfs连接池）、缓存组件开发（redis缓存）、日志组件开发（sqlite分文件报文日志记录）、数据库历史数据迁移及清理方案设计、文件服务器扩展设计等。客户端采用C#，以便与相应的硬件对接。4、 系统开发过程中处理的问题。编写C#客户端与后台交互的组件，解决客户端与后台对接问题；人脸识别对接（ICE技术研发）；外部接口对接开发（ibmmq对接）。 技能清单 前端：vue/Element-UI/iview/Cordova 前端工具：sass/less 数据库相关：MySQL/PgSQL/SQLite 版本管理、文档和自动化部署工具：Svn/Git/apiDoc/jenkins 单元测试：JUnit 云和开放平台：微信应用开发 技术图谱 技能关键字 Spring Cloud Spring Boot Netty Vue ElementUI Cordova 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>个人简历</category>
      </categories>
      <tags>
        <tag>个人简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建个人博客]]></title>
    <url>%2F2019%2F08%2F28%2Fdeploy-self-blog%2F</url>
    <content type="text"><![CDATA[安装参考文档：https://hexo.io/zh-cn/ npm install hexo-cli -g hexo init euler-king cd euler-king npm install hexo server访问地址：http://localhost:4000常用命令hexo new "postName" #新建文章 hexo new page "pageName" #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【十四】微服务多语言数据库设计]]></title>
    <url>%2F2019%2F07%2F25%2Fcanna-cloud-14%2F</url>
    <content type="text"><![CDATA[/*==============================================================*/ /* Table: canna_base_lang */ /*==============================================================*/ create table canna_base_lang ( id serial8 not null, code character varying(256) null, service_code character varying(256) null, lang character varying(32) null, name character varying(255) null, constraint PK_CANNA_BASE_LANG primary key (id) ); comment on table canna_base_lang is '多语言配置'; comment on column canna_base_lang.id is 'ID'; comment on column canna_base_lang.code is '编码'; comment on column canna_base_lang.service_code is '服务编码'; comment on column canna_base_lang.lang is '语言'; comment on column canna_base_lang.name is '名称'; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【二十三】安装snipe-it]]></title>
    <url>%2F2019%2F07%2F09%2Fcentos7-soft-install-23%2F</url>
    <content type="text"><![CDATA[wget https://github.com/snipe/snipe-it/archive/v4.7.5.tar.gz tar xzvf v4.7.5.tar.gz cd snipe-it-4.7.5/ curl -sS https://getcomposer.org/installer | php php composer.phar install --no-dev --prefer-source cp composer.phar /usr/local/bin/composer composer global require laravel/installer chmod 777 -R storage chmod 777 -R public/uploads php artisan key:generate nginx配置： 备注：需要先启动php-frm root /home/data/eam/snipe-it-4.7.5/public/; index index.php index.html index.htm; location / { try_files $uri $uri/ /index.php$is_args$args; } location /js { root /home/data/eam/snipe-it-4.7.5/public; } location /css { root /home/data/eam/snipe-it-4.7.5/public; } location /index.php/css { rewrite ^(.*)/css/(.+)$ /css/$2 last; } location /index.php/js { rewrite ^(.*)/js/(.+)$ /js/$2 last; } location =/.env { return 404; } location ~ \.php$ { try_files $uri $uri/ =404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /roywise/data/eam/snipe-it-4.7.5/public/$fastcgi_script_name; include fastcgi_params; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【二十二】安装php7.3.7]]></title>
    <url>%2F2019%2F07%2F08%2Fcentos7-soft-install-22%2F</url>
    <content type="text"><![CDATA[yum install epel-release -y yum update yum -y install wget vim pcre pcre-devel openssl openssl-devel libicu-devel gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel ncurses ncurses-devel curl curl-devel krb5-devel libidn libidn-devel openldap openldap-devel nss_ldap jemalloc-devel cmake boost-devel bison automake libevent libevent-devel gd gd-devel libtool* libmcrypt libmcrypt-devel mcrypt mhash libxslt libxslt-devel readline readline-devel gmp gmp-devel libcurl libcurl-devel openjpeg-devel yum remove cmake cd /home/soft wget https://github.com/Kitware/CMake/releases/download/v3.14.5/cmake-3.14.5.tar.gz tar -zxvf cmake-3.14.5.tar.gz cd cmake-3.14.5 ./bootstrap gmake gmake install yum remove libzip cd /home/soft wget https://libzip.org/download/libzip-1.5.2.tar.gz tar -zxvf libzip-1.5.2.tar.gz cd libzip-1.5.2 mkdir build cd build cmake .. make &amp;&amp; make install cd /home/soft groupadd php useradd -g php php wget https://www.php.net/distributions/php-7.3.7.tar.gz tar xvf php-7.3.7.tar.gz cd php-7.3.7 cp -frp /usr/lib64/libldap* /usr/lib/ ./configure --prefix=/home/app/php \ --with-config-file-path=/home/app/php/etc \ --enable-fpm \ --with-fpm-user=php \ --with-fpm-group=php \ --enable-mysqlnd \ --with-mysqli=mysqlnd \ --with-pdo-mysql=mysqlnd \ --enable-mysqlnd-compression-support \ --with-iconv-dir \ --with-freetype-dir \ --with-jpeg-dir \ --with-png-dir \ --with-zlib \ --with-libxml-dir \ --enable-xml \ --disable-rpath \ --enable-bcmath \ --enable-shmop \ --enable-sysvsem \ --enable-inline-optimization \ --with-curl \ --enable-mbregex \ --enable-mbstring \ --enable-intl \ --with-mcrypt \ --with-libmbfl \ --enable-ftp \ --with-gd \ --enable-gd-jis-conv \ --enable-gd-native-ttf \ --with-openssl \ --with-mhash \ --enable-pcntl \ --enable-sockets \ --with-xmlrpc \ --enable-zip \ --enable-soap \ --with-gettext \ --disable-fileinfo \ --enable-opcache \ --with-pear \ --enable-maintainer-zts \ --with-ldap=shared \ --without-gdbm vim /etc/ld.so.conf #添加如下几行 /usr/local/lib64 /usr/local/lib /usr/lib /usr/lib64 #保存退出 :wq ldconfig -v # 使之生效 make -j 4 &amp;&amp; make install cp /home/soft/php-7.3.7/php.ini-production /home/app/php/etc/php.ini document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【十三】spring cloud gateway ServerCodecConfigurer 问题]]></title>
    <url>%2F2019%2F06%2F20%2Fcanna-cloud-13%2F</url>
    <content type="text"><![CDATA[问题描述： Parameter 0 of method modifyRequestBodyGatewayFilterFactory in org.springframework.cloud.gateway.config.GatewayAutoConfiguration required a bean of type ‘org.springframework.http.codec.ServerCodecConfigurer’ that could not be found. 问题原因：依赖冲突 解决方法： &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【十二】spring cloud config center fresh配置]]></title>
    <url>%2F2019%2F05%2F16%2Fcanna-cloud-12%2F</url>
    <content type="text"><![CDATA[spring cloud 版本：Greenwich.RELEASE 一、config server，依赖引入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; application.yml配置 ​ server: port: 7010 servlet: context-path: /config-server eureka: client: healthcheck: enabled: true registerWithEureka: false fetchRegistry: false server: waitTimeInMsWhenSyncEmpty: 0 ​ bootstrap.yml配置 spring: application: name: "canna-cloud-module-eureka-server" cloud: config: uri: http://localhost:8888 server: git: search-paths: config username: "" password: "" uri:"" label: master name: config-client profile: prod 启动类 @SpringBootApplication @EnableConfigServer @RestController public class ConfigServerApplication { @RequestMapping("/hello") public String home() { return "eureka server start success"; } public static void main(String[] args) throws Exception { SpringApplication.run(ConfigServerApplication.class, args); } } 二、config client使用 application.yml配置 server: port: 7020 servlet: context-path: /config-client management: #actuator server: port: 7021 endpoints: web: base-path: /actuator #默认是/actuator 前缀，可以在这里修改 exposure: include: "*" #打开全部请求端点 # include: refresh,health,info #打开部分 eureka: client: healthcheck: enabled: true registerWithEureka: false fetchRegistry: false server: waitTimeInMsWhenSyncEmpty: 0 bootstrap.yml配置 spring: application: name: "canna-cloud-module-eureka-server" cloud: config: uri: http://localhost:7010/config-server label: master profile: dev name: config-client 启动类 @SpringBootApplication public class ConfigClientServerApplication { public static void main(String[] args) throws Exception { SpringApplication.run(ConfigClientServerApplication.class, args); } } 配置刷新测试Controller。注意在需要的地方添加注解：@RefreshScope @RestController @RefreshScope public class ConfigController { @Value("${myww}") String myww; @RequestMapping("/hello") public String home() { return "config client server start success, value:" + myww; } } 调用postman，访问POST方法： http://localhost:7021/actuator/refresh 再请求controller即可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【四十三】ConcurrentLinkedQueue]]></title>
    <url>%2F2019%2F05%2F09%2Fsource-code-java-43%2F</url>
    <content type="text"><![CDATA[ConcurrentLinkedQueue通过使用CAS原子操作保证其相应功能的安全性 1、定义原子变量与原子操作，CAS来判断其操作的准确性 /** * Throws NullPointerException if argument is null. * * @param v the element */ private static void checkNotNull(Object v) { if (v == null) throw new NullPointerException(); } private boolean casTail(Node&lt;E&gt; cmp, Node&lt;E&gt; val) { return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val); } private boolean casHead(Node&lt;E&gt; cmp, Node&lt;E&gt; val) { return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val); } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long headOffset; private static final long tailOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = ConcurrentLinkedQueue.class; headOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("head")); tailOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("tail")); } catch (Exception e) { throw new Error(e); } } 2、Node，定义保存数据的节点，同时也对Node的处理使用CAS原子操作 private static class Node&lt;E&gt; { volatile E item; volatile Node&lt;E&gt; next; /** * Constructs a new node. Uses relaxed write because item can * only be seen after publication via casNext. */ Node(E item) { UNSAFE.putObject(this, itemOffset, item); } boolean casItem(E cmp, E val) { return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); } void lazySetNext(Node&lt;E&gt; val) { UNSAFE.putOrderedObject(this, nextOffset, val); } boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) { return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("item")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("next")); } catch (Exception e) { throw new Error(e); } } } 3、定义队列的头尾节点 /** * A node from which the first live (non-deleted) node (if any) * can be reached in O(1) time. * Invariants: * - all live nodes are reachable from head via succ() * - head != null * - (tmp = head).next != tmp || tmp != head * Non-invariants: * - head.item may or may not be null. * - it is permitted for tail to lag behind head, that is, for tail * to not be reachable from head! */ private transient volatile Node&lt;E&gt; head; /** * A node from which the last node on list (that is, the unique * node with node.next == null) can be reached in O(1) time. * Invariants: * - the last node is always reachable from tail via succ() * - tail != null * Non-invariants: * - tail.item may or may not be null. * - it is permitted for tail to lag behind head, that is, for tail * to not be reachable from head! * - tail.next may or may not be self-pointing to tail. */ private transient volatile Node&lt;E&gt; tail; 4、构造函数，含有元素的构造方法，使用lazySetNext，保证关联后续节点的原子性 /** * Creates a {@code ConcurrentLinkedQueue} that is initially empty. */ public ConcurrentLinkedQueue() { head = tail = new Node&lt;E&gt;(null); } /** * Creates a {@code ConcurrentLinkedQueue} * initially containing the elements of the given collection, * added in traversal order of the collection's iterator. * * @param c the collection of elements to initially contain * @throws NullPointerException if the specified collection or any * of its elements are null */ public ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c) { Node&lt;E&gt; h = null, t = null; for (E e : c) { checkNotNull(e); Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); if (h == null) h = t = newNode; else { t.lazySetNext(newNode); t = newNode; } } if (h == null) h = t = new Node&lt;E&gt;(null); head = h; tail = t; } 5、add/offer offer：后续添加元素，如果尾部的下个节点一直不为空（有其他线程已添加进元素），则一直循环，直到添加完成为止 /** * Inserts the specified element at the tail of this queue. * As the queue is unbounded, this method will never throw * {@link IllegalStateException} or return {@code false}. * * @return {@code true} (as specified by {@link Collection#add}) * @throws NullPointerException if the specified element is null */ public boolean add(E e) { return offer(e); } /** * Inserts the specified element at the tail of this queue. * As the queue is unbounded, this method will never return {@code false}. * * @return {@code true} (as specified by {@link Queue#offer}) * @throws NullPointerException if the specified element is null */ public boolean offer(E e) { checkNotNull(e); final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); for (Node&lt;E&gt; t = tail, p = t;;) { Node&lt;E&gt; q = p.next; if (q == null) { // p is last node if (p.casNext(null, newNode)) { // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become "live". if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; } // Lost CAS race to another thread; re-read next } else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. p = (p != t &amp;&amp; t != (t = tail)) ? t : q; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【四十二】Stack]]></title>
    <url>%2F2019%2F05%2F09%2Fsource-code-java-42%2F</url>
    <content type="text"><![CDATA[Stack继承Vector，堆栈添加了pop与push操作，并添加synchronized修饰，保证其安全性 1、push/pop；插入与取出 /** * Pushes an item onto the top of this stack. This has exactly * the same effect as: * &lt;blockquote&gt;&lt;pre&gt; * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt; * * @param item the item to be pushed onto this stack. * @return the &lt;code&gt;item&lt;/code&gt; argument. * @see java.util.Vector#addElement */ public E push(E item) { addElement(item); return item; } /** * Removes the object at the top of this stack and returns that * object as the value of this function. * * @return The object at the top of this stack (the last item * of the &lt;tt&gt;Vector&lt;/tt&gt; object). * @throws EmptyStackException if this stack is empty. */ public synchronized E pop() { E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; } 2、peek：获取栈顶元素 /** * Looks at the object at the top of this stack without removing it * from the stack. * * @return the object at the top of this stack (the last item * of the &lt;tt&gt;Vector&lt;/tt&gt; object). * @throws EmptyStackException if this stack is empty. */ public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); } 3、search：查询堆栈元素 /** * Returns the 1-based position where an object is on this stack. * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this * method returns the distance from the top of the stack of the * occurrence nearest the top of the stack; the topmost item on the * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt; * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the * items in this stack. * * @param o the desired object. * @return the 1-based position from the top of the stack where * the object is located; the return value &lt;code&gt;-1&lt;/code&gt; * indicates that the object is not on the stack. */ public synchronized int search(Object o) { int i = lastIndexOf(o); if (i &gt;= 0) { return size() - i; } return -1; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【四十一】Vector]]></title>
    <url>%2F2019%2F05%2F09%2Fsource-code-java-41%2F</url>
    <content type="text"><![CDATA[Vector：线程安全List 1、变量定义，底层依然使用数组保存数据 /** * The array buffer into which the components of the vector are * stored. The capacity of the vector is the length of this array buffer, * and is at least large enough to contain all the vector's elements. * * &lt;p&gt;Any array elements following the last element in the Vector are null. * * @serial */ protected Object[] elementData; /** * The number of valid components in this {@code Vector} object. * Components {@code elementData[0]} through * {@code elementData[elementCount-1]} are the actual items. * * @serial */ protected int elementCount; /** * The amount by which the capacity of the vector is automatically * incremented when its size becomes greater than its capacity. If * the capacity increment is less than or equal to zero, the capacity * of the vector is doubled each time it needs to grow. * * @serial */ protected int capacityIncrement; 2、对于操作方法，基本使用的是synchronized关键字，保证其操作的安全性。 设置大小，判断是否为空等。与ArrayList方法大致一样，添加了线程安全关键字修饰 /** * Sets the size of this vector. If the new size is greater than the * current size, new {@code null} items are added to the end of * the vector. If the new size is less than the current size, all * components at index {@code newSize} and greater are discarded. * * @param newSize the new size of this vector * @throws ArrayIndexOutOfBoundsException if the new size is negative */ public synchronized void setSize(int newSize) { modCount++; if (newSize &gt; elementCount) { ensureCapacityHelper(newSize); } else { for (int i = newSize ; i &lt; elementCount ; i++) { elementData[i] = null; } } elementCount = newSize; } /** * Returns the current capacity of this vector. * * @return the current capacity (the length of its internal * data array, kept in the field {@code elementData} * of this vector) */ public synchronized int capacity() { return elementData.length; } /** * Returns the number of components in this vector. * * @return the number of components in this vector */ public synchronized int size() { return elementCount; } /** * Tests if this vector has no components. * * @return {@code true} if and only if this vector has * no components, that is, its size is zero; * {@code false} otherwise. */ public synchronized boolean isEmpty() { return elementCount == 0; } 3、添加元素addElement /** * Adds the specified component to the end of this vector, * increasing its size by one. The capacity of this vector is * increased if its size becomes greater than its capacity. * * &lt;p&gt;This method is identical in functionality to the * {@link #add(Object) add(E)} * method (which is part of the {@link List} interface). * * @param obj the component to be added */ public synchronized void addElement(E obj) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; } 4、删除元素：removeElement /** * Removes the first (lowest-indexed) occurrence of the argument * from this vector. If the object is found in this vector, each * component in the vector with an index greater or equal to the * object's index is shifted downward to have an index one smaller * than the value it had previously. * * &lt;p&gt;This method is identical in functionality to the * {@link #remove(Object)} method (which is part of the * {@link List} interface). * * @param obj the component to be removed * @return {@code true} if the argument was a component of this * vector; {@code false} otherwise. */ public synchronized boolean removeElement(Object obj) { modCount++; int i = indexOf(obj); if (i &gt;= 0) { removeElementAt(i); return true; } return false; } 5、get/set：查询与设置 /** * Returns the element at the specified position in this Vector. * * @param index index of the element to return * @return object at the specified index * @throws ArrayIndexOutOfBoundsException if the index is out of range * ({@code index &lt; 0 || index &gt;= size()}) * @since 1.2 */ public synchronized E get(int index) { if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); } /** * Replaces the element at the specified position in this Vector with the * specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws ArrayIndexOutOfBoundsException if the index is out of range * ({@code index &lt; 0 || index &gt;= size()}) * @since 1.2 */ public synchronized E set(int index, E element) { if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; } 5、add/remove：添加与删除，remove底层调用removeElement /** * Appends the specified element to the end of this Vector. * * @param e element to be appended to this Vector * @return {@code true} (as specified by {@link Collection#add}) * @since 1.2 */ public synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } /** * Removes the first occurrence of the specified element in this Vector * If the Vector does not contain the element, it is unchanged. More * formally, removes the element with the lowest index i such that * {@code (o==null ? get(i)==null : o.equals(get(i)))} (if such * an element exists). * * @param o element to be removed from this Vector, if present * @return true if the Vector contained the specified element * @since 1.2 */ public boolean remove(Object o) { return removeElement(o); } 总结：Vector是List的一种线程安全的实现，基本操作与ArrayList类似 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【四十】ArrayDeque]]></title>
    <url>%2F2019%2F05%2F09%2Fsource-code-java-40%2F</url>
    <content type="text"><![CDATA[ArrayDeque继承了AbstractCollection的基本集合实现，同时实现了Deque的接口 1、变量定义 保存在数组对象中，定义了头部位置和尾部位置，最小的数据大小为8 /** * The array in which the elements of the deque are stored. * The capacity of the deque is the length of this array, which is * always a power of two. The array is never allowed to become * full, except transiently within an addX method where it is * resized (see doubleCapacity) immediately upon becoming full, * thus avoiding head and tail wrapping around to equal each * other. We also guarantee that all array cells not holding * deque elements are always null. */ transient Object[] elements; // non-private to simplify nested class access /** * The index of the element at the head of the deque (which is the * element that would be removed by remove() or pop()); or an * arbitrary number equal to tail if the deque is empty. */ transient int head; /** * The index at which the next element would be added to the tail * of the deque (via addLast(E), add(E), or push(E)). */ transient int tail; /** * The minimum capacity that we'll use for a newly created deque. * Must be a power of 2. */ private static final int MIN_INITIAL_CAPACITY = 8; 2、allocateElements：根据元素大小分配空间，使用位移来获取与所需空间最接近的2的n次方的大小。 /** * Allocates empty array to hold the given number of elements. * * @param numElements the number of elements to hold */ private void allocateElements(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests "&lt;=" because arrays aren't kept full. if (numElements &gt;= initialCapacity) { initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements } elements = new Object[initialCapacity]; } 3、doubleCapacity：扩容，每次扩容为原先容量的一倍 /** * Doubles the capacity of this deque. Call only when full, i.e., * when head and tail have wrapped around to become equal. */ private void doubleCapacity() { assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException("Sorry, deque too big"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n; } 4、copyElements：将队列中的元素复制，并返回对应的数组 /** * Copies the elements from our element array into the specified array, * in order (from first to last element in the deque). It is assumed * that the array is large enough to hold all elements in the deque. * * @return its argument */ private &lt;T&gt; T[] copyElements(T[] a) { if (head &lt; tail) { System.arraycopy(elements, head, a, 0, size()); } else if (head &gt; tail) { int headPortionLen = elements.length - head; System.arraycopy(elements, head, a, 0, headPortionLen); System.arraycopy(elements, 0, a, headPortionLen, tail); } return a; } 5、默认构造：大小为16；指定大小，根据指定的大小，分配相近的2的n次方的空间大小 /** * Constructs an empty array deque with an initial capacity * sufficient to hold 16 elements. */ public ArrayDeque() { elements = new Object[16]; } /** * Constructs an empty array deque with an initial capacity * sufficient to hold the specified number of elements. * * @param numElements lower bound on initial capacity of the deque */ public ArrayDeque(int numElements) { allocateElements(numElements); } 6、初始化元素构造 先分配空间 再将元素添加进队列中 /** * Constructs a deque containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. (The first element returned by the collection's * iterator becomes the first element, or &lt;i&gt;front&lt;/i&gt; of the * deque.) * * @param c the collection whose elements are to be placed into the deque * @throws NullPointerException if the specified collection is null */ public ArrayDeque(Collection&lt;? extends E&gt; c) { allocateElements(c.size()); addAll(c); } 7、addFirst：head初始为0，添加到第一个元素时，下标指向数组的最后一个。如果第一个下标和最后一个下标相同了说明数组已经满了，进行扩容。元素不支持添加null元素，因为判断是否存在元素是通过null进行判断的。 /** * Inserts the specified element at the front of this deque. * * @param e the element to add * @throws NullPointerException if the specified element is null */ public void addFirst(E e) { if (e == null) throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity(); } 8、addLast：队列从后插入，如果队列满了，则双倍扩容 /** * Inserts the specified element at the end of this deque. * * &lt;p&gt;This method is equivalent to {@link #add}. * * @param e the element to add * @throws NullPointerException if the specified element is null */ public void addLast(E e) { if (e == null) throw new NullPointerException(); elements[tail] = e; if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); } 9、offerFirst：实际使用addFirst放到，如果添加成功，添加了返回值true /** * Inserts the specified element at the front of this deque. * * @param e the element to add * @return {@code true} (as specified by {@link Deque#offerFirst}) * @throws NullPointerException if the specified element is null */ public boolean offerFirst(E e) { addFirst(e); return true; } 10、offerLast：实际使用addLast放到，如果添加成功，添加了返回值true /** * Inserts the specified element at the end of this deque. * * @param e the element to add * @return {@code true} (as specified by {@link Deque#offerLast}) * @throws NullPointerException if the specified element is null */ public boolean offerLast(E e) { addLast(e); return true; } 11、pollFirst：返回第一个元素，并删除第一个元素。 public E pollFirst() { int h = head; @SuppressWarnings("unchecked") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); return result; } 12、pollLast：返回最后一个元素，并删除最后一个元素。如果元素为空则返回null public E pollLast() { int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings("unchecked") E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result; } 13、removeFirst，removeLast分配对pollFirst与pollLast进行封装，区别是如果元素不存在则抛出NoSuchElementException异常。 /** * @throws NoSuchElementException {@inheritDoc} */ public E removeFirst() { E x = pollFirst(); if (x == null) throw new NoSuchElementException(); return x; } /** * @throws NoSuchElementException {@inheritDoc} */ public E removeLast() { E x = pollLast(); if (x == null) throw new NoSuchElementException(); return x; } 14、getFirst、getLast：获取第一个/最后一个元素，如果元素不存在则抛出异常 /** * @throws NoSuchElementException {@inheritDoc} */ public E getFirst() { @SuppressWarnings("unchecked") E result = (E) elements[head]; if (result == null) throw new NoSuchElementException(); return result; } /** * @throws NoSuchElementException {@inheritDoc} */ public E getLast() { @SuppressWarnings("unchecked") E result = (E) elements[(tail - 1) &amp; (elements.length - 1)]; if (result == null) throw new NoSuchElementException(); return result; } 15、peekFirst/peekLast：返回第一个元素/最后一个元素，不存在返回null @SuppressWarnings("unchecked") public E peekFirst() { // elements[head] is null if deque empty return (E) elements[head]; } @SuppressWarnings("unchecked") public E peekLast() { return (E) elements[(tail - 1) &amp; (elements.length - 1)]; } 16、removeFirstOccurrence/removeLastOccurrence：从头开始/从尾开始，删除第一次出现的元素，删除成功则返回true，如果待删除元素为null，则直接返回false。 /** * Removes the first occurrence of the specified element in this * deque (when traversing the deque from head to tail). * If the deque does not contain the element, it is unchanged. * More formally, removes the first element {@code e} such that * {@code o.equals(e)} (if such an element exists). * Returns {@code true} if this deque contained the specified element * (or equivalently, if this deque changed as a result of the call). * * @param o element to be removed from this deque, if present * @return {@code true} if the deque contained the specified element */ public boolean removeFirstOccurrence(Object o) { if (o == null) return false; int mask = elements.length - 1; int i = head; Object x; while ( (x = elements[i]) != null) { if (o.equals(x)) { delete(i); return true; } i = (i + 1) &amp; mask; } return false; } /** * Removes the last occurrence of the specified element in this * deque (when traversing the deque from head to tail). * If the deque does not contain the element, it is unchanged. * More formally, removes the last element {@code e} such that * {@code o.equals(e)} (if such an element exists). * Returns {@code true} if this deque contained the specified element * (or equivalently, if this deque changed as a result of the call). * * @param o element to be removed from this deque, if present * @return {@code true} if the deque contained the specified element */ public boolean removeLastOccurrence(Object o) { if (o == null) return false; int mask = elements.length - 1; int i = (tail - 1) &amp; mask; Object x; while ( (x = elements[i]) != null) { if (o.equals(x)) { delete(i); return true; } i = (i - 1) &amp; mask; } return false; } 17、push/pop：后进先出，堆栈的实现方式 /** * Pushes an element onto the stack represented by this deque. In other * words, inserts the element at the front of this deque. * * &lt;p&gt;This method is equivalent to {@link #addFirst}. * * @param e the element to push * @throws NullPointerException if the specified element is null */ public void push(E e) { addFirst(e); } /** * Pops an element from the stack represented by this deque. In other * words, removes and returns the first element of this deque. * * &lt;p&gt;This method is equivalent to {@link #removeFirst()}. * * @return the element at the front of this deque (which is the top * of the stack represented by this deque) * @throws NoSuchElementException {@inheritDoc} */ public E pop() { return removeFirst(); } 18、size：计算头部与尾部的差值来获取队列的长度 /** * Returns the number of elements in this deque. * * @return the number of elements in this deque */ public int size() { return (tail - head) &amp; (elements.length - 1); } 19、contains：遍历数组，查看是否存在 /** * Returns {@code true} if this deque contains the specified element. * More formally, returns {@code true} if and only if this deque contains * at least one element {@code e} such that {@code o.equals(e)}. * * @param o object to be checked for containment in this deque * @return {@code true} if this deque contains the specified element */ public boolean contains(Object o) { if (o == null) return false; int mask = elements.length - 1; int i = head; Object x; while ( (x = elements[i]) != null) { if (o.equals(x)) return true; i = (i + 1) &amp; mask; } return false; } 20、remove：删除第一个出现的元素 /** * Removes a single instance of the specified element from this deque. * If the deque does not contain the element, it is unchanged. * More formally, removes the first element {@code e} such that * {@code o.equals(e)} (if such an element exists). * Returns {@code true} if this deque contained the specified element * (or equivalently, if this deque changed as a result of the call). * * &lt;p&gt;This method is equivalent to {@link #removeFirstOccurrence(Object)}. * * @param o element to be removed from this deque, if present * @return {@code true} if this deque contained the specified element */ public boolean remove(Object o) { return removeFirstOccurrence(o); } 21、clone：提供了队列复制克隆的方法 /** * Returns a copy of this deque. * * @return a copy of this deque */ public ArrayDeque&lt;E&gt; clone() { try { @SuppressWarnings("unchecked") ArrayDeque&lt;E&gt; result = (ArrayDeque&lt;E&gt;) super.clone(); result.elements = Arrays.copyOf(elements, elements.length); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十九】Deque]]></title>
    <url>%2F2019%2F05%2F06%2Fsource-code-java-39%2F</url>
    <content type="text"><![CDATA[Deque是双向队列，包含Queue的全部功能，同时添加了双向队列的特有实现 1、在第一个元素前添加元素：添加失败抛出异常 void addFirst(E e); 2、在最后的位置添加元素：添加失败抛出异常 void addLast(E e); 3、调用addFirst方法，添加成功返回true，否则抛出异常 boolean offerFirst(E e); 4、调用addLast方法，添加成功返回true，否则抛出异常 boolean offerLast(E e); 5、删除第一个元素，调用pollFirst方法，没有元素则抛出异常。 E removeFirst(); 6、删除最后一个元素，调用pollLast方法，没有元素则抛出异常。 E removeLast(); 7、推出第一个元素，并返回元素信息，没有数据返回null E pollFirst(); 8、推出最后一个元素，并返回元素信息，没有数据返回null E pollLast(); 9、获取第一个元素，并返回，没有元素则抛出异常。 E getFirst(); 10、获取最后一个元素，并返回，没有则抛出异常 E getLast(); 11、获取第一个元素，并返回，没有则返回null E peekFirst(); 12、获取最后一个元素，并返回，没有则返回null E peekLast(); 13、从第一个元素开始，删除第一次出现的元素，删除成功（存在）返回true，不存在返回false。 boolean removeFirstOccurrence(Object o); 14、从最后一个元素开始，删除第一次出现的元素，删除成功（存在）返回true，不存在返回false。 boolean removeLastOccurrence(Object o); 15、调用addFirst方法，结合pop可以用来实现堆栈的数据结构，后进先出。 void push(E e); 16、调用removeFirst方法 E pop(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十八】LinkedBlockingQueue]]></title>
    <url>%2F2019%2F04%2F28%2Fsource-code-java-38%2F</url>
    <content type="text"><![CDATA[LinkedBlockingQueue：链表阻塞队列 1、定义单向列表 static class Node&lt;E&gt; { E item; /** * One of: * - the real successor Node * - this Node, meaning the successor is head.next * - null, meaning there is no successor (this is the last node) */ Node&lt;E&gt; next; Node(E x) { item = x; } } 2、初始化相关值，总容量，队列长度，取元素锁，添加元素锁等 /** The capacity bound, or Integer.MAX_VALUE if none */ private final int capacity; /** Current number of elements */ private final AtomicInteger count = new AtomicInteger(); /** * Head of linked list. * Invariant: head.item == null */ transient Node&lt;E&gt; head; /** * Tail of linked list. * Invariant: last.next == null */ private transient Node&lt;E&gt; last; /** Lock held by take, poll, etc */ private final ReentrantLock takeLock = new ReentrantLock(); /** Wait queue for waiting takes */ private final Condition notEmpty = takeLock.newCondition(); /** Lock held by put, offer, etc */ private final ReentrantLock putLock = new ReentrantLock(); /** Wait queue for waiting puts */ private final Condition notFull = putLock.newCondition(); 3、队列是否为空的标志，使用乐观锁保证了线程安全，put、offer方法使用 /** * Signals a waiting take. Called only from put/offer (which do not * otherwise ordinarily lock takeLock.) */ private void signalNotEmpty() { final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { notEmpty.signal(); } finally { takeLock.unlock(); } } 4、队列是否满的标志。take、poll方法使用 /** * Signals a waiting put. Called only from take/poll. */ private void signalNotFull() { final ReentrantLock putLock = this.putLock; putLock.lock(); try { notFull.signal(); } finally { putLock.unlock(); } } 5、enqueue：添加元素到队列的实际方法 dequeue：删除元素的实际方法 /** * Links node at end of queue. * * @param node the node */ private void enqueue(Node&lt;E&gt; node) { // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node; } /** * Removes a node from head of queue. * * @return the node */ private E dequeue() { // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x; } 6、put：阻塞添加元素，putLock锁保证添加元素的线程安全，如果队列容量满了，则一直wait，达到等待的效果。 /** * Inserts the specified element at the tail of this queue, waiting if * necessary for space to become available. * * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ while (count.get() == capacity) { notFull.await(); } enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); } finally { putLock.unlock(); } if (c == 0) signalNotEmpty(); } 7、offer带参数，如果容量满了，阻塞指定的时间，达到时间如果没有添加成功则返回false。 /** * Inserts the specified element at the tail of this queue, waiting if * necessary up to the specified wait time for space to become available. * * @return {@code true} if successful, or {@code false} if * the specified waiting time elapses before space is available * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { while (count.get() == capacity) { if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); } enqueue(new Node&lt;E&gt;(e)); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); } finally { putLock.unlock(); } if (c == 0) signalNotEmpty(); return true; } 8、offer无参：如果容量满了则立即返回false /** * Inserts the specified element at the tail of this queue if it is * possible to do so immediately without exceeding the queue's capacity, * returning {@code true} upon success and {@code false} if this queue * is full. * When using a capacity-restricted queue, this method is generally * preferable to method {@link BlockingQueue#add add}, which can fail to * insert an element only by throwing an exception. * * @throws NullPointerException if the specified element is null */ public boolean offer(E e) { if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; if (count.get() == capacity) return false; int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try { if (count.get() &lt; capacity) { enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); } } finally { putLock.unlock(); } if (c == 0) signalNotEmpty(); return c &gt;= 0; } 9、take：添加take锁，如果没有元素，则一直等待，知道队列有元素时返回 public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { while (count.get() == 0) { notEmpty.await(); } x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } 10、poll带参数：如果队列为空，则阻塞指定时间，然后返回出栈首个元素，不存在则返回null public E poll(long timeout, TimeUnit unit) throws InterruptedException { E x = null; int c = -1; long nanos = unit.toNanos(timeout); final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { while (count.get() == 0) { if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); } x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } 11、poll无参数：出栈并返回首个元素，不存在则返回null public E poll() { final AtomicInteger count = this.count; if (count.get() == 0) return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { if (count.get() &gt; 0) { x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); } } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } 12、peek：获取首个元素，没有则返回null public E peek() { if (count.get() == 0) return null; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { Node&lt;E&gt; first = head.next; if (first == null) return null; else return first.item; } finally { takeLock.unlock(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十七】BlockingQueue]]></title>
    <url>%2F2019%2F04%2F28%2Fsource-code-java-37%2F</url>
    <content type="text"><![CDATA[BlockingQueue接口，重载了Queue中方法的定义，并添加了put/take这组阻塞方法，可用于生产者消费者的实现。 put：如果队列已满则阻塞，直到队列可继续添加元素 take：如果队列没有元素，则等待，直到有数据时进行返回 public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; { /** * Inserts the specified element into this queue if it is possible to do * so immediately without violating capacity restrictions, returning * {@code true} upon success and throwing an * {@code IllegalStateException} if no space is currently available. * When using a capacity-restricted queue, it is generally preferable to * use {@link #offer(Object) offer}. * * @param e the element to add * @return {@code true} (as specified by {@link Collection#add}) * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this queue */ boolean add(E e); /** * Inserts the specified element into this queue if it is possible to do * so immediately without violating capacity restrictions, returning * {@code true} upon success and {@code false} if no space is currently * available. When using a capacity-restricted queue, this method is * generally preferable to {@link #add}, which can fail to insert an * element only by throwing an exception. * * @param e the element to add * @return {@code true} if the element was added to this queue, else * {@code false} * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this queue */ boolean offer(E e); /** * Inserts the specified element into this queue, waiting if necessary * for space to become available. * * @param e the element to add * @throws InterruptedException if interrupted while waiting * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this queue */ void put(E e) throws InterruptedException; /** * Inserts the specified element into this queue, waiting up to the * specified wait time if necessary for space to become available. * * @param e the element to add * @param timeout how long to wait before giving up, in units of * {@code unit} * @param unit a {@code TimeUnit} determining how to interpret the * {@code timeout} parameter * @return {@code true} if successful, or {@code false} if * the specified waiting time elapses before space is available * @throws InterruptedException if interrupted while waiting * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this queue */ boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; /** * Retrieves and removes the head of this queue, waiting if necessary * until an element becomes available. * * @return the head of this queue * @throws InterruptedException if interrupted while waiting */ E take() throws InterruptedException; /** * Retrieves and removes the head of this queue, waiting up to the * specified wait time if necessary for an element to become available. * * @param timeout how long to wait before giving up, in units of * {@code unit} * @param unit a {@code TimeUnit} determining how to interpret the * {@code timeout} parameter * @return the head of this queue, or {@code null} if the * specified waiting time elapses before an element is available * @throws InterruptedException if interrupted while waiting */ E poll(long timeout, TimeUnit unit) throws InterruptedException; /** * Returns the number of additional elements that this queue can ideally * (in the absence of memory or resource constraints) accept without * blocking, or {@code Integer.MAX_VALUE} if there is no intrinsic * limit. * * &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert * an element will succeed by inspecting {@code remainingCapacity} * because it may be the case that another thread is about to * insert or remove an element. * * @return the remaining capacity */ int remainingCapacity(); /** * Removes a single instance of the specified element from this queue, * if it is present. More formally, removes an element {@code e} such * that {@code o.equals(e)}, if this queue contains one or more such * elements. * Returns {@code true} if this queue contained the specified element * (or equivalently, if this queue changed as a result of the call). * * @param o element to be removed from this queue, if present * @return {@code true} if this queue changed as a result of the call * @throws ClassCastException if the class of the specified element * is incompatible with this queue * (&lt;a href="../Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified element is null * (&lt;a href="../Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) */ boolean remove(Object o); /** * Returns {@code true} if this queue contains the specified element. * More formally, returns {@code true} if and only if this queue contains * at least one element {@code e} such that {@code o.equals(e)}. * * @param o object to be checked for containment in this queue * @return {@code true} if this queue contains the specified element * @throws ClassCastException if the class of the specified element * is incompatible with this queue * (&lt;a href="../Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified element is null * (&lt;a href="../Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) */ public boolean contains(Object o); /** * Removes all available elements from this queue and adds them * to the given collection. This operation may be more * efficient than repeatedly polling this queue. A failure * encountered while attempting to add elements to * collection {@code c} may result in elements being in neither, * either or both collections when the associated exception is * thrown. Attempts to drain a queue to itself result in * {@code IllegalArgumentException}. Further, the behavior of * this operation is undefined if the specified collection is * modified while the operation is in progress. * * @param c the collection to transfer elements into * @return the number of elements transferred * @throws UnsupportedOperationException if addition of elements * is not supported by the specified collection * @throws ClassCastException if the class of an element of this queue * prevents it from being added to the specified collection * @throws NullPointerException if the specified collection is null * @throws IllegalArgumentException if the specified collection is this * queue, or some property of an element of this queue prevents * it from being added to the specified collection */ int drainTo(Collection&lt;? super E&gt; c); /** * Removes at most the given number of available elements from * this queue and adds them to the given collection. A failure * encountered while attempting to add elements to * collection {@code c} may result in elements being in neither, * either or both collections when the associated exception is * thrown. Attempts to drain a queue to itself result in * {@code IllegalArgumentException}. Further, the behavior of * this operation is undefined if the specified collection is * modified while the operation is in progress. * * @param c the collection to transfer elements into * @param maxElements the maximum number of elements to transfer * @return the number of elements transferred * @throws UnsupportedOperationException if addition of elements * is not supported by the specified collection * @throws ClassCastException if the class of an element of this queue * prevents it from being added to the specified collection * @throws NullPointerException if the specified collection is null * @throws IllegalArgumentException if the specified collection is this * queue, or some property of an element of this queue prevents * it from being added to the specified collection */ int drainTo(Collection&lt;? super E&gt; c, int maxElements); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十六】AbstractQueue]]></title>
    <url>%2F2019%2F04%2F28%2Fsource-code-java-36%2F</url>
    <content type="text"><![CDATA[AbstractQueue抽象类，实现了Queue接口的部分通用方法。 1、add：调用offer方法实现，不存在false的情况，false直接抛出异常 /** * Inserts the specified element into this queue if it is possible to do so * immediately without violating capacity restrictions, returning * &lt;tt&gt;true&lt;/tt&gt; upon success and throwing an &lt;tt&gt;IllegalStateException&lt;/tt&gt; * if no space is currently available. * * &lt;p&gt;This implementation returns &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;offer&lt;/tt&gt; succeeds, * else throws an &lt;tt&gt;IllegalStateException&lt;/tt&gt;. * * @param e the element to add * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add}) * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null and * this queue does not permit null elements * @throws IllegalArgumentException if some property of this element * prevents it from being added to this queue */ public boolean add(E e) { if (offer(e)) return true; else throw new IllegalStateException("Queue full"); } 2、remove方法直接调用poll方法，如果为空则直接抛出异常。意味着添加元素时，元素不能为空，否则删除时必然报错。 /** * Retrieves and removes the head of this queue. This method differs * from {@link #poll poll} only in that it throws an exception if this * queue is empty. * * &lt;p&gt;This implementation returns the result of &lt;tt&gt;poll&lt;/tt&gt; * unless the queue is empty. * * @return the head of this queue * @throws NoSuchElementException if this queue is empty */ public E remove() { E x = poll(); if (x != null) return x; else throw new NoSuchElementException(); } 3、element直接调用peek方法，如果首个元素不存在，获取到的为空，则直接抛出不存在元素的一次 /** * Retrieves, but does not remove, the head of this queue. This method * differs from {@link #peek peek} only in that it throws an exception if * this queue is empty. * * &lt;p&gt;This implementation returns the result of &lt;tt&gt;peek&lt;/tt&gt; * unless the queue is empty. * * @return the head of this queue * @throws NoSuchElementException if this queue is empty */ public E element() { E x = peek(); if (x != null) return x; else throw new NoSuchElementException(); } 4、clear，调用poll方法，直到队列空则说明已经清空队列 /** * Removes all of the elements from this queue. * The queue will be empty after this call returns. * * &lt;p&gt;This implementation repeatedly invokes {@link #poll poll} until it * returns &lt;tt&gt;null&lt;/tt&gt;. */ public void clear() { while (poll() != null) ; } 5、addAll：循环调用add方法，一个一个元素添加到集合中，直到集合全部添加完成 /** * Adds all of the elements in the specified collection to this * queue. Attempts to addAll of a queue to itself result in * &lt;tt&gt;IllegalArgumentException&lt;/tt&gt;. Further, the behavior of * this operation is undefined if the specified collection is * modified while the operation is in progress. * * &lt;p&gt;This implementation iterates over the specified collection, * and adds each element returned by the iterator to this * queue, in turn. A runtime exception encountered while * trying to add an element (including, in particular, a * &lt;tt&gt;null&lt;/tt&gt; element) may result in only some of the elements * having been successfully added when the associated exception is * thrown. * * @param c collection containing elements to be added to this queue * @return &lt;tt&gt;true&lt;/tt&gt; if this queue changed as a result of the call * @throws ClassCastException if the class of an element of the specified * collection prevents it from being added to this queue * @throws NullPointerException if the specified collection contains a * null element and this queue does not permit null elements, * or if the specified collection is null * @throws IllegalArgumentException if some property of an element of the * specified collection prevents it from being added to this * queue, or if the specified collection is this queue * @throws IllegalStateException if not all the elements can be added at * this time due to insertion restrictions * @see #add(Object) */ public boolean addAll(Collection&lt;? extends E&gt; c) { if (c == null) throw new NullPointerException(); if (c == this) throw new IllegalArgumentException(); boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十五】Queue]]></title>
    <url>%2F2019%2F04%2F28%2Fsource-code-java-35%2F</url>
    <content type="text"><![CDATA[add：在队列末尾添加元素，如果添加失败则提示异常（队列没有设置容量则与offer功能一样） offer：在队列末尾添加元素，如果添加失败返回false，添加成功返回true。 remove：移除队列第一个元素，如果第一个元素不存在则提示异常。移除成功返回移除的元素 poll：移除第一个元素，返回移除的元素，如果元素不存在则返回null element：返回一个元素，如果不存在，抛出异常 peek：返回第一个元素，如果不存在则返回null add/offer：功能类似，区别在于添加失败是否抛出异常 remove/poll：功能类似，区别在于首个元素不存在时存在抛出异常 element/peek：功能类似，区别在于首个元素不存在时存在抛出异常 public interface Queue&lt;E&gt; extends Collection&lt;E&gt; { /** * Inserts the specified element into this queue if it is possible to do so * immediately without violating capacity restrictions, returning * {@code true} upon success and throwing an {@code IllegalStateException} * if no space is currently available. * * @param e the element to add * @return {@code true} (as specified by {@link Collection#add}) * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null and * this queue does not permit null elements * @throws IllegalArgumentException if some property of this element * prevents it from being added to this queue */ boolean add(E e); /** * Inserts the specified element into this queue if it is possible to do * so immediately without violating capacity restrictions. * When using a capacity-restricted queue, this method is generally * preferable to {@link #add}, which can fail to insert an element only * by throwing an exception. * * @param e the element to add * @return {@code true} if the element was added to this queue, else * {@code false} * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null and * this queue does not permit null elements * @throws IllegalArgumentException if some property of this element * prevents it from being added to this queue */ boolean offer(E e); /** * Retrieves and removes the head of this queue. This method differs * from {@link #poll poll} only in that it throws an exception if this * queue is empty. * * @return the head of this queue * @throws NoSuchElementException if this queue is empty */ E remove(); /** * Retrieves and removes the head of this queue, * or returns {@code null} if this queue is empty. * * @return the head of this queue, or {@code null} if this queue is empty */ E poll(); /** * Retrieves, but does not remove, the head of this queue. This method * differs from {@link #peek peek} only in that it throws an exception * if this queue is empty. * * @return the head of this queue * @throws NoSuchElementException if this queue is empty */ E element(); /** * Retrieves, but does not remove, the head of this queue, * or returns {@code null} if this queue is empty. * * @return the head of this queue, or {@code null} if this queue is empty */ E peek(); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【十一】mybatis generator 连接postgresql生成的java model乱码问题处理]]></title>
    <url>%2F2019%2F04%2F05%2Fcanna-cloud-11%2F</url>
    <content type="text"><![CDATA[&lt;context id="canna-cloud-service-member" targetRuntime="com.flower.canna.cloud.generator.mybatis.runtime.CannaTableMyBatis3"&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;/context&gt; 在context节点下添加： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【十】地区数据存储设计]]></title>
    <url>%2F2019%2F04%2F05%2Fcanna-cloud-10%2F</url>
    <content type="text"><![CDATA[1、用于存储国家、省、市、区/县、镇等地区区域划分信息 设计中使用到了树形结构的相关信息，如parent_id，left_value，right_value。方便后续信息的检索。 对于树形结构在数据库中的存储结构，后续会有相应设计说明。 2、设计相应的E-R图如下： 3、建表语句如下： drop table canna_base_area; /*==============================================================*/ /* Table: canna_base_area */ /*==============================================================*/ create table canna_base_area ( id serial8 not null, code character varying(255) null, cn_name character varying(255) null, en_name character varying(255) null, value character varying(255) null, status character varying(255) null, remark character varying(255) null, sort bigint null, parent_id bigint not null, left_value bigint not null, right_value bigint not null, type character varying(32) null, constraint PK_CANNA_BASE_AREA primary key (id) ); comment on table canna_base_area is '地区信息表'; comment on column canna_base_area.id is 'ID'; comment on column canna_base_area.code is '编码'; comment on column canna_base_area.cn_name is '中文名称'; comment on column canna_base_area.en_name is '英文名'; comment on column canna_base_area.value is '地区值'; comment on column canna_base_area.status is '状态'; comment on column canna_base_area.remark is '备注'; comment on column canna_base_area.sort is '排序显示'; comment on column canna_base_area.parent_id is '父节点编码'; comment on column canna_base_area.left_value is '左值'; comment on column canna_base_area.right_value is '右值'; comment on column canna_base_area.type is '地区类型：国家/省/市'; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【九】系统参数设计]]></title>
    <url>%2F2019%2F04%2F05%2Fcanna-cloud-9%2F</url>
    <content type="text"><![CDATA[系统参数，存储值为key-value的数据结构，设计E-R图如下： 相应的建表语句： drop table canna_base_configure; /*==============================================================*/ /* Table: canna_base_configure */ /*==============================================================*/ create table canna_base_configure ( id serial8 not null, param_key character varying(64) null, param_value text null, param_status character varying(32) null, description character varying(255) null, create_time timestamp null, constraint PK_CANNA_BASE_CONFIGURE primary key (id) ); comment on table canna_base_configure is '系统参数配置'; comment on column canna_base_configure.id is 'ID'; comment on column canna_base_configure.param_key is '参数'; comment on column canna_base_configure.param_value is '参数值'; comment on column canna_base_configure.param_status is '参数状态'; comment on column canna_base_configure.description is '参数描述'; comment on column canna_base_configure.create_time is '创建时间'; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【八】数据字典设计]]></title>
    <url>%2F2019%2F04%2F05%2Fcanna-cloud-8%2F</url>
    <content type="text"><![CDATA[数据字典设计。 结构：key-hashKey-hashValue，一般用于前端数据类型的展示，便于对经常变更的数据进行维护。 对应的在缓存中如redis的保存结构为：HashMap的格式 字典项为第一级，parent_code可以设置默认值：CANNA_PARENT 字典项中的详细记录列表，parent_code设置为字典项中的code进行关联。 drop index INDEX_CANNA_BASE_DICT_PARENT_CODE; drop index INDEX_CANNA_BASE_DICT_CODE; drop table canna_base_dict; /*==============================================================*/ /* Table: canna_base_dict */ /*==============================================================*/ create table canna_base_dict ( id bigint not null, code character varying(256) null, cn_name character varying(256) null, en_name character varying(32) null, value character varying(1024) null, parent_code character varying(32) null, status character varying(32) null, remark character varying(255) null, sort bigint null, constraint PK_CANNA_BASE_DICT primary key (id) ); comment on column canna_base_dict.id is 'ID'; comment on column canna_base_dict.code is '字典编码'; comment on column canna_base_dict.cn_name is '字典中文名'; comment on column canna_base_dict.en_name is '字典英文名'; comment on column canna_base_dict.value is '字典值'; comment on column canna_base_dict.parent_code is '父节点编码'; comment on column canna_base_dict.status is '字典状态'; comment on column canna_base_dict.remark is '备注'; comment on column canna_base_dict.sort is '顺序'; /*==============================================================*/ /* Index: INDEX_CANNA_BASE_DICT_CODE */ /*==============================================================*/ create index INDEX_CANNA_BASE_DICT_CODE on canna_base_dict ( code ); /*==============================================================*/ /* Index: INDEX_CANNA_BASE_DICT_PARENT_CODE */ /*==============================================================*/ create index INDEX_CANNA_BASE_DICT_PARENT_CODE on canna_base_dict ( parent_code ); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【七】64进制以内任意进制的转化]]></title>
    <url>%2F2019%2F04%2F03%2Fcanna-cloud-7%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/xuanshuangchen/canna-cloud.git 1、10进制转指定进制 2、指定进制转10进制 3、进制的最大值 4、进制的枚举值，方便操作 进制转化类 public class Radix { private final static char[] DIGITS_BASE = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' , '[' , ']' }; private static final int ASCII_SIZE = 128; private static final int[] DIGITS_INDEX = new int[ASCII_SIZE]; private static final char BLANK_CHAR = '0'; /** * 进制数 */ @Getter protected int radix; /** * 空白补充字符 */ @Getter protected char blankChar; public static final int MAX_RADIX = 64; public static final int MIN_RADIX = 2; /** * 进制最大的字符 */ @Getter protected char maxChar; private char[] digits; static { for (int i = 0; i &lt; ASCII_SIZE; i++) { DIGITS_INDEX[i] = -1; } } public Radix(int radix){ this(radix, DIGITS_BASE); } public Radix(int radix, int beginIndex, int endIndex){ char radixDigit[] = new char[endIndex - beginIndex]; for (int i = beginIndex; i &lt; endIndex; i++) { radixDigit[i - beginIndex] = DIGITS_BASE[i]; } this.init(radix, radixDigit); } public Radix(int radix, char[] digits){ this.init(radix, digits); } private void init(int radix, char[] digits){ if (radix &lt; MIN_RADIX) { throw new NumberFormatException("radix " + radix + " less than MIN_RADIX"); } if (radix &gt; MAX_RADIX) { throw new NumberFormatException("radix " + radix + " greater than MAX_RADIX"); } this.digits = digits; this.radix = radix; this.blankChar = BLANK_CHAR; this.maxChar = digits[radix - 1]; for (int i = 0; i &lt; digits.length; i++) { DIGITS_INDEX[digits[i]] = i; } } public String toRadixWithBlank(long value, long length) { String dest = toRadix(value); if(dest.length() &gt; length){ throw new StringIndexOutOfBoundsException("string max than setting length"); } if (dest.length() &lt; length) { dest = this.getRepeatStr(blankChar, length - dest.length()) + dest; } return dest; } public long toDecimal(String value) { return parseLong(value, radix); } public long getMaxValue(long bit) { String value = this.getRepeatStr(maxChar, bit); return parseLong(value, radix); } private String getRepeatStr(char value, long length){ StringBuilder builder = new StringBuilder(); for(int i = 0; i &lt; length; i ++){ builder.append(value); } return builder.toString(); } public String toRadix(long i) { if (radix == 10) return Long.toString(i); char[] buf = new char[65]; int charPos = 64; boolean negative = (i &lt; 0); if (!negative) { i = -i; } while (i &lt;= -radix) { buf[charPos--] = digits[(int)(-(i % radix))]; i = i / radix; } buf[charPos] = digits[(int)(-i)]; if (negative) { buf[--charPos] = '-'; } return new String(buf, charPos, (65 - charPos)); } private long parseLong(String s, int radix) throws NumberFormatException { if (s == null) { throw new NumberFormatException("null"); } if (radix &lt; MIN_RADIX) { throw new NumberFormatException("radix " + radix + " less than MIN_RADIX"); } if (radix &gt; MAX_RADIX) { throw new NumberFormatException("radix " + radix + " greater than MAX_RADIX"); } long result = 0; boolean negative = false; int i = 0, len = s.length(); long limit = -Long.MAX_VALUE; long multmin; int digit; if (len &gt; 0) { char firstChar = s.charAt(0); if (firstChar &lt; '0') { // Possible leading "+" or "-" if (firstChar == '-') { negative = true; limit = Long.MIN_VALUE; } else if (firstChar != '+') throw new NumberFormatException("For input string: \"" + s + "\""); if (len == 1) // Cannot have lone "+" or "-" throw new NumberFormatException("For input string: \"" + s + "\""); i++; } multmin = limit / radix; while (i &lt; len) { // Accumulating negatively avoids surprises near MAX_VALUE digit = DIGITS_INDEX[s.charAt(i++)]; if (digit &lt; 0) { throw new NumberFormatException("For input string: \"" + s + "\""); } if (digit &gt;= radix) { throw new NumberFormatException("For input string: \"" + s + "\""); } if (result &lt; multmin) { throw new NumberFormatException("For input string: \"" + s + "\""); } result *= radix; if (result &lt; limit + digit) { throw new NumberFormatException("For input string: \"" + s + "\""); } result -= digit; } } else { throw new NumberFormatException("For input string: \"" + s + "\""); } return negative ? result : -result; } } 进制枚举类： public enum RadixEnum { Radix2(2), Radix3(3), Radix4(4), Radix5(5), Radix6(6), Radix7(7), Radix8(8), Radix9(9), Radix10(10), Radix11(11), Radix12(12), Radix13(13), Radix14(14), Radix15(15), Radix16(16), Radix17(17), Radix18(18), Radix19(19), Radix20(20), Radix21(21), Radix22(22), Radix23(23), Radix24(24), Radix25(25), Radix26(26), Radix27(27), Radix28(28), Radix29(29), Radix30(30), Radix31(31), Radix32(32), Radix33(33), Radix34(34), Radix35(35), Radix36(36), Radix37(37), Radix38(38), Radix39(39), Radix40(40), Radix41(41), Radix42(42), Radix43(43), Radix44(44), Radix45(45), Radix46(46), Radix47(47), Radix48(48), Radix49(49), Radix50(50), Radix51(51), Radix52(52), Radix53(53), Radix54(54), Radix55(55), Radix56(56), Radix57(57), Radix58(58), Radix59(59), Radix60(60), Radix61(61), Radix62(62), Radix63(63), Radix64(64) ; public static final ImmutableMap&lt;Integer, RadixEnum&gt; radixEnumMap = ImmutableMap.&lt;Integer, RadixEnum&gt; of(2, Radix2) .of(3, Radix3) .of(4, Radix4) .of(5, Radix5) .of(6, Radix6) .of(7, Radix7) .of(8, Radix8) .of(9, Radix9) .of(10, Radix10) .of(11, Radix11) .of(12, Radix12) .of(13, Radix13) .of(14, Radix14) .of(15, Radix15) .of(16, Radix16) .of(17, Radix17) .of(18, Radix18) .of(19, Radix19) .of(20, Radix20) .of(21, Radix21) .of(22, Radix22) .of(23, Radix23) .of(24, Radix24) .of(25, Radix25) .of(26, Radix26) .of(27, Radix27) .of(28, Radix28) .of(29, Radix29) .of(30, Radix30) .of(31, Radix31) .of(32, Radix32) .of(33, Radix33) .of(34, Radix34) .of(35, Radix35) .of(36, Radix36) .of(37, Radix37) .of(38, Radix38) .of(39, Radix39) .of(40, Radix40) .of(41, Radix41) .of(42, Radix42) .of(43, Radix43) .of(44, Radix44) .of(45, Radix45) .of(46, Radix46) .of(47, Radix47) .of(48, Radix48) .of(49, Radix49) .of(50, Radix50) .of(51, Radix51) .of(52, Radix52) .of(53, Radix53) .of(54, Radix54) .of(55, Radix55) .of(56, Radix56) .of(57, Radix57) .of(58, Radix58) .of(59, Radix59) .of(60, Radix60) .of(61, Radix61) .of(62, Radix62) .of(63, Radix63) .of(64, Radix64); private Radix radix; private RadixEnum(int radix) { this.radix = new Radix(radix); } public String toRadixWithBlank(long value, long length) { return this.radix.toRadixWithBlank(value, length); } public long toDecimal(String value) { return this.radix.toDecimal(value); } public long getMaxValue(long bit) { return this.radix.getMaxValue(bit); } public String toRadix(long i) { return this.radix.toRadix(i); } public RadixEnum valueOf(int radix) { if (radix &lt; Radix.MIN_RADIX) { throw new NumberFormatException("radix " + radix + " less than MIN_RADIX"); } if (radix &gt; Radix.MAX_RADIX) { throw new NumberFormatException("radix " + radix + " greater than MAX_RADIX"); } return radixEnumMap.get(radix); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【六】canna-cloud-base-sqlite]]></title>
    <url>%2F2019%2F04%2F03%2Fcanna-cloud-6%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/xuanshuangchen/canna-cloud.git sqlite操作的基础服务，封装基本的数据库连接，插入，批量插入，等操作。利用反射，实现对象与字段的映射，实现类ORM的功能。 提供了sqlite的log实现，将日志写入sqlite文件中 实现Logger接口接口，规范日志操作。 1、sqlite基本操作工具 public class SqliteDBUtils { private SqliteDBUtils(){ //do nothing } public static String getDefaultDbName() { return SqliteStaticConstants.DEFAULT_DATE_FORMAT.format(new Date()); } public static Connection getConnection() throws Exception{ String dbName = getDefaultDbName(); return getConnection(dbName); } public static Connection getConnection(String dbName) throws Exception{ return getConnection(dbName, false); } public static Connection getConnection(String dbName, boolean autoCommit) throws Exception{ Class.forName(SqliteStaticConstants.SQLITE_DB_DRIVER); String realDb = SqliteStaticConstants.getSqliteDbname(dbName); Connection conn = DriverManager.getConnection( realDb ); conn.setAutoCommit(autoCommit); return conn; } public static void createTable(Connection connection, String createTableSql) throws SQLException { Statement stmt = null; try { stmt = connection.createStatement(); stmt.executeUpdate(createTableSql); connection.commit(); } catch (Exception e) { log.error("", e); connection.rollback(); throw new SQLException(e); }finally { closeQuietly(stmt); } } public static void createTable(String dbName, String createTableSql) throws SQLException { Connection connection = null; try { connection = getConnection(dbName); createTable(connection, createTableSql); } catch (Exception e) { log.error("", e); }finally{ closeQuietly(connection); } } public static Long insert(Connection connection, String sql, List&lt;Object&gt; params) throws SQLException { PreparedStatement prepStmt = connection.prepareStatement(sql); long result = 0; ResultSet rs = null; try{ prepStmt.setQueryTimeout(60); int i = 1; if(params != null){ for(Object param:params){ prepStmt.setObject(i, param); i += 1; } } result = prepStmt.executeUpdate(); connection.commit(); rs = prepStmt.getGeneratedKeys(); if(rs.next()){ return rs.getLong(1); } }catch(Exception e){ log.error("", e); connection.rollback(); throw new SQLException(e); }finally{ closeQuietly(rs); closeQuietly(prepStmt); } return result; } public static void insertBatch(Connection connection, String sql, List&lt;List&lt;Object&gt;&gt; params) throws SQLException { PreparedStatement prepStmt = connection.prepareStatement(sql); ResultSet rs = null; try{ prepStmt.setQueryTimeout(60); if(params != null &amp;&amp; !params.isEmpty()){ for(List&lt;Object&gt; paramItem : params){ if(paramItem != null &amp;&amp; !paramItem.isEmpty()){ int i = 1; for(Object param : paramItem){ prepStmt.setObject(i, param); i += 1; } prepStmt.addBatch(); } } } prepStmt.executeBatch(); connection.commit(); }catch(Exception e){ log.error("", e); connection.rollback(); throw new SQLException(e); }finally{ closeQuietly(rs); closeQuietly(prepStmt); } } private static void closeQuietly(AutoCloseable closeable) { try { if (closeable != null) { closeable.close(); } } catch (Exception ioe) { // ignore } } } 2、sqlite反射操作 public class SQLUtils { public static String getInsertSql(String tableName, Set&lt;String&gt; columnList) throws InstantiationException, IllegalAccessException { StringBuffer sb = new StringBuffer(); StringBuffer sb2 = new StringBuffer(); sb.append("insert into "+tableName+"("); sb2.append("values ("); for(String key : columnList){ sb.append(toUnderlineName(key)+","); sb2.append("?,"); } String insertStr = sb.substring(0, sb.length() - 1) + ")"; String valueStr = sb2.substring(0, sb2.length() - 1) + ")"; return insertStr + valueStr; } /* * 获取参数 */ public static &lt;T&gt; List&lt;List&lt;Object&gt;&gt; getParams(List&lt;T&gt; value,Set&lt;String&gt; columnList) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException{ List&lt;List&lt;Object&gt;&gt; list = new ArrayList&lt;List&lt;Object&gt;&gt;(); for(T item:value){ BeanMap valueMap = BeanMap.create(item); List&lt;Object&gt; listo = new ArrayList&lt;Object&gt;(); for(String column:columnList){ Object o = valueMap.get(column); listo.add(o); } list.add(listo); } return list; } public static &lt;T&gt; List&lt;Object&gt; getParams(T value,Set&lt;String&gt; columnList) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException{ BeanMap valueMap = BeanMap.create(value); List&lt;Object&gt; listo = new ArrayList&lt;Object&gt;(); for(String column:columnList){ Object o = valueMap.get(column); listo.add(o); } return listo; } //两个相加 public static &lt;T&gt; T[] ArrayConcat(T[] first,T[] second){ return ArrayUtils.addAll(first, second); } public static String toUnderlineName(String s) { if (s == null) { return null; } else { StringBuilder sb = new StringBuilder(); boolean upperCase = false; for(int i = 0; i &lt; s.length(); ++i) { char c = s.charAt(i); boolean nextUpperCase = true; if (i &lt; s.length() - 1) { nextUpperCase = Character.isUpperCase(s.charAt(i + 1)); } if (i &gt;= 0 &amp;&amp; Character.isUpperCase(c)) { if ((!upperCase || !nextUpperCase) &amp;&amp; i &gt; 0) { sb.append("_"); } upperCase = true; } else { upperCase = false; } sb.append(Character.toLowerCase(c)); } return sb.toString(); } } public static String getTableName(String className){ if(StringUtils.isBlank(className)){ return ""; } String prefix = "t"; StringBuilder sb = new StringBuilder(); sb.append(prefix); for(int i = 0; i&lt;className.length();i++){ Character c = className.charAt(i); if(Character.isUpperCase(c)){ sb.append("_"); sb.append(Character.toLowerCase(c)); }else{ sb.append(c); } } return sb.toString(); } } 3、日志封装实现 public class SqliteLogger implements Logger { private LogSqliteService logSqliteService; public static Logger getLogger(String logName){ SqliteLogger sqliteLogger = new SqliteLogger(); sqliteLogger.logSqliteService = LogSqliteService.getLogSqliteService(logName, SqliteStaticConstants.DEFAULT_DATE_FORMAT); return sqliteLogger; } public static Logger getLogger(Class&lt;?&gt; clazz){ SqliteLogger sqliteLogger = new SqliteLogger(); sqliteLogger.logSqliteService = LogSqliteService.getLogSqliteService(clazz.getName(), SqliteStaticConstants.DEFAULT_DATE_FORMAT); return sqliteLogger; } public static Logger getLogger(String logName, String sqliteDBPreName){ SqliteLogger sqliteLogger = new SqliteLogger(); sqliteLogger.logSqliteService = LogSqliteService.getLogSqliteService(logName, SqliteStaticConstants.DEFAULT_DATE_FORMAT, sqliteDBPreName); return sqliteLogger; } public static Logger getLogger(Class&lt;?&gt; clazz, String sqliteDBPreName){ SqliteLogger sqliteLogger = new SqliteLogger(); sqliteLogger.logSqliteService = LogSqliteService.getLogSqliteService(clazz.getName(), SqliteStaticConstants.DEFAULT_DATE_FORMAT, sqliteDBPreName); return sqliteLogger; } public static Logger getLogger(String logName, FastDateFormat createStrategy){ SqliteLogger sqliteLogger = new SqliteLogger(); sqliteLogger.logSqliteService = LogSqliteService.getLogSqliteService(logName, createStrategy); return sqliteLogger; } public static Logger getLogger(Class&lt;?&gt; clazz, FastDateFormat createStrategy){ SqliteLogger sqliteLogger = new SqliteLogger(); sqliteLogger.logSqliteService = LogSqliteService.getLogSqliteService(clazz.getName(), createStrategy); return sqliteLogger; } public static Logger getLogger(String logName, FastDateFormat createStrategy, String sqliteDBPreName){ SqliteLogger sqliteLogger = new SqliteLogger(); sqliteLogger.logSqliteService = LogSqliteService.getLogSqliteService(logName, createStrategy, sqliteDBPreName); return sqliteLogger; } public static Logger getLogger(Class&lt;?&gt; clazz, FastDateFormat createStrategy, String sqliteDBPreName){ SqliteLogger sqliteLogger = new SqliteLogger(); sqliteLogger.logSqliteService = LogSqliteService.getLogSqliteService(clazz.getName(), createStrategy, sqliteDBPreName); return sqliteLogger; } @Override public String getName() { return null; } @Override public boolean isTraceEnabled() { return false; } @Override public void trace(String s) { } @Override public void trace(String s, Object o) { } @Override public void trace(String s, Object o, Object o1) { } @Override public void trace(String s, Object... objects) { } @Override public void trace(String s, Throwable throwable) { } @Override public boolean isTraceEnabled(Marker marker) { return false; } @Override public void trace(Marker marker, String s) { } @Override public void trace(Marker marker, String s, Object o) { } @Override public void trace(Marker marker, String s, Object o, Object o1) { } @Override public void trace(Marker marker, String s, Object... objects) { } @Override public void trace(Marker marker, String s, Throwable throwable) { } @Override public boolean isDebugEnabled() { return false; } @Override public void debug(String s) { logSqliteService.infoQuiet(s, LogLevel.DEBUG); } @Override public void debug(String s, Object o) { String info = String.format(s, o); logSqliteService.infoQuiet(info, LogLevel.DEBUG); } @Override public void debug(String s, Object o, Object o1) { String info = String.format(s, o, o1); logSqliteService.infoQuiet(s, LogLevel.DEBUG); } @Override public void debug(String s, Object... objects) { String info = String.format(s, objects); logSqliteService.infoQuiet(s, LogLevel.DEBUG); } @Override public void debug(String s, Throwable throwable) { String info = s + throwable.getMessage(); logSqliteService.infoQuiet(s, LogLevel.DEBUG); } @Override public boolean isDebugEnabled(Marker marker) { return false; } @Override public void debug(Marker marker, String s) { } @Override public void debug(Marker marker, String s, Object o) { } @Override public void debug(Marker marker, String s, Object o, Object o1) { } @Override public void debug(Marker marker, String s, Object... objects) { } @Override public void debug(Marker marker, String s, Throwable throwable) { } @Override public boolean isInfoEnabled() { return false; } @Override public void info(String s) { logSqliteService.infoQuiet(s, LogLevel.INFO); } @Override public void info(String s, Object o) { String info = String.format(s, o); logSqliteService.infoQuiet(s, LogLevel.INFO); } @Override public void info(String s, Object o, Object o1) { String info = String.format(s, o, o1); logSqliteService.infoQuiet(s, LogLevel.INFO); } @Override public void info(String s, Object... objects) { String info = String.format(s, objects); logSqliteService.infoQuiet(s, LogLevel.INFO); } @Override public void info(String s, Throwable throwable) { String info = s + throwable.getMessage(); logSqliteService.infoQuiet(s, LogLevel.INFO); } @Override public boolean isInfoEnabled(Marker marker) { return false; } @Override public void info(Marker marker, String s) { } @Override public void info(Marker marker, String s, Object o) { } @Override public void info(Marker marker, String s, Object o, Object o1) { } @Override public void info(Marker marker, String s, Object... objects) { } @Override public void info(Marker marker, String s, Throwable throwable) { } @Override public boolean isWarnEnabled() { return false; } @Override public void warn(String s) { } @Override public void warn(String s, Object o) { } @Override public void warn(String s, Object... objects) { } @Override public void warn(String s, Object o, Object o1) { } @Override public void warn(String s, Throwable throwable) { } @Override public boolean isWarnEnabled(Marker marker) { return false; } @Override public void warn(Marker marker, String s) { } @Override public void warn(Marker marker, String s, Object o) { } @Override public void warn(Marker marker, String s, Object o, Object o1) { } @Override public void warn(Marker marker, String s, Object... objects) { } @Override public void warn(Marker marker, String s, Throwable throwable) { } @Override public boolean isErrorEnabled() { return false; } @Override public void error(String s) { } @Override public void error(String s, Object o) { } @Override public void error(String s, Object o, Object o1) { } @Override public void error(String s, Object... objects) { } @Override public void error(String s, Throwable throwable) { } @Override public boolean isErrorEnabled(Marker marker) { return false; } @Override public void error(Marker marker, String s) { } @Override public void error(Marker marker, String s, Object o) { } @Override public void error(Marker marker, String s, Object o, Object o1) { } @Override public void error(Marker marker, String s, Object... objects) { } @Override public void error(Marker marker, String s, Throwable throwable) { } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【五】spring boot延迟自定义枚举的static值初始化]]></title>
    <url>%2F2019%2F04%2F03%2Fcanna-cloud-5%2F</url>
    <content type="text"><![CDATA[1、自定义注解：InitEnum @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface InitEnum { public static final Object[] NULL_ITEM = { "" }; public static final Class[] parameterTypes = { String.class }; } 2、反射创建实例 public static &lt;T&gt; T getInstance(Class&lt;T&gt; clazz) throws Exception { try { return clazz.newInstance(); } catch (InstantiationException | IllegalAccessException e) { log.info("", e); throw new Exception("实例化失败"); } } 3、在需要的初始化对象中添加注解 @InitEnum public class FileModuleEnum { private static final Map&lt;String, FileModuleEnum&gt; nameEnumMap = new ConcurrentHashMap&lt;&gt;(); protected FileModuleEnum(String name) { if (!nameEnumMap.containsKey(name)) { nameEnumMap.put(name, this); } } public static FileModuleEnum valueOf(String name) { if (name == null) throw new NullPointerException("Name is null"); FileModuleEnum result = nameEnumMap.get(name); if (result != null) { return result; } throw new IllegalArgumentException("No enum constant exists, name is." + name); } } 4、监听启动后进行初始化 @Log4j2 @Component @Order(value = 0) public class EndStartedListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; { @Resource private SpringClassService springClassService; @Override public void onApplicationEvent(ContextRefreshedEvent event) { try { this.initEnum(); } catch (Exception e) { log.error("", e); } } private void initEnum() throws Exception { List&lt;Class&gt; classList = springClassService.listAllClass(); for (Class clazz: classList) { if (clazz.isAnnotationPresent(InitEnum.class)) { Object temp = BeanTransferUtils.getInstance(clazz, InitEnum.parameterTypes, InitEnum.NULL_ITEM); temp = null; } } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【四】spring boot的bean延迟初始化]]></title>
    <url>%2F2019%2F04%2F03%2Fcanna-cloud-4%2F</url>
    <content type="text"><![CDATA[逻辑： 1、定义初始化抽象接口InitService 2、通过监听器，在启动完成后，遍历所有的bean，判断是否实现了接口InitService。 3、如果实现了接口，则调用接口中的初始化方法，并根据接口定义的初始化顺序先后进行初始化。 public interface InitService { /* * order 越大 约先初始化 */ /** * 拦截器 */ static final Integer INTERCEPT_ORDER = 1000; // &gt;= 1000 /** * 队列 */ static final Integer QUEUE_ORDER = 2000; // &gt;= 2000 /** * 控制器 */ static final Integer CONTROLLER_ORDER = 3000; // &gt;= 3000 /** * 定时任务 */ static final Integer SCHEDULE_ORDER = 4000; // &gt;= 4000 /** * service服务 */ static final Integer SERVICE_ORDER = 5000; // &gt;= 5000 /** * 配置实例化 */ static final Integer CONFIGURE_ORDER = 6000; // &gt;= 6000 int getOrder(); void init() throws CannaException; } public class EndStartedListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; { @Override public void onApplicationEvent(ContextRefreshedEvent event) { if (((ApplicationContextEvent) event).getApplicationContext().getParent() == null) { try { this.initSystem(SpringContextHolder.getApplicationContext()); } catch (CannaException e) { log.error("", e); } } } public void initSystem(ApplicationContext context) throws CannaException { String beans[] = context.getBeanDefinitionNames(); log.info("bean length:{}", beans.length); Map&lt;Integer, List&lt;Object&gt;&gt; beanMap = new HashMap&lt;Integer, List&lt;Object&gt;&gt;(); for (String bean : beans) { Object obj = context.getBean(bean); if (obj instanceof InitService) { InitService initService = (InitService) obj; Integer key = initService.getOrder(); List&lt;Object&gt; beanList = beanMap.get(key); if (beanList == null) { beanList = new ArrayList&lt;Object&gt;(); beanMap.put(key, beanList); } beanList.add(initService); } } if (beanMap.isEmpty()) { return; } Set&lt;Integer&gt; keySet = beanMap.keySet(); Integer[] keyArr = keySet.toArray(new Integer[]{}); Arrays.sort(keyArr); for (int i = keyArr.length - 1; i &gt;= 0; i--) { Integer IKey = keyArr[i]; List&lt;Object&gt; beanList = beanMap.get(IKey); for (Object obj : beanList) { if (obj instanceof InitService) { InitService initService = (InitService) obj; initService.init(); } } } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【三】canna-cloud-maven-plugin]]></title>
    <url>%2F2019%2F04%2F02%2Fcanna-cloud-3%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/xuanshuangchen/canna-cloud.git 自定义代码生成插件 1、配置pom.xml： &lt;profile&gt; &lt;id&gt;mybatis&lt;/id&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.flower.canna.cloud&lt;/groupId&gt; &lt;artifactId&gt;canna-cloud-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0.0&lt;/version&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/classes/&lt;/outputDirectory&gt; &lt;workDirectory&gt;target/work/&lt;/workDirectory&gt; &lt;configFileName&gt;generator/generator.properties&lt;/configFileName&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;myBatisGenerator&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;myBatisGenerator&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; 2、在需要生成的工程目录下，配置如下文件： generator/generator.properties 3、插件通过自动获取maven本地仓库地址，再拼接相应的driverJarPath，得到相应的驱动； 使用canna-cloud-mybatis-generator自动生成器，调用如下命令，可直接重复生成相应的模块。 mvn clean package -P mybatis document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【二】canna-cloud-mybatis-generator]]></title>
    <url>%2F2019%2F04%2F02%2Fcanna-cloud-2%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/xuanshuangchen/canna-cloud.git 1、通过简化配置文件，方便开发 datasource.type=com.alibaba.druid.pool.DruidDataSource datasource.driverJarPath=org/postgresql/postgresql/42.2.5/postgresql-42.2.5.jar datasource.driverClassName=org.postgresql.Driver datasource.url=jdbc:postgresql://127.0.0.1:5432/db_canna datasource.username=postgres datasource.password=postgres TEMP_PROJECT_PATH=/temp/ GENERATOR_TABLE_CONF_NAME=generator/app.ini driverJarPath直接读取maven的工程目录，减少了驱动可能不存在的问题。 2、表配置 [module_app] modulePackage=com.flower.canna.cloud.service.app contextName=canna-cloud-service-app projectPath=/canna-cloud/canna-cloud-service/canna-cloud-service-app/ schema=public moduleSchema=module_app [table_common] t_app_info=AppInfo [column_t_app_info] columnName=type javaType=com.flower.canna.service.common.mybatis.EnumType typeHandler=com.flower.canna.cloud.base.biz.mybatis.CommonEnumTypeHandler suffix=::jsonb operation=&amp;lt;= 同一个模块，只需指定工程的路径，便可直接生成全部相应的定制化程序。 对应自定义处理字段，可通过配置相应的处理方法，实现字段的映射。 3、生成后的配置文件如下： &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;generatorConfiguration&gt; &lt;classPathEntry location="/maven/repo/org/postgresql/postgresql/42.2.5/postgresql-42.2.5.jar"/&gt; &lt;context id="canna-cloud-service-app" targetRuntime="com.flower.canna.cloud.generator.mybatis.runtime.CannaTableMyBatis3"&gt; &lt;plugin type="com.flower.canna.cloud.generator.mybatis.plugins.ModelMapperPlugin"/&gt; &lt;plugin type="com.flower.canna.cloud.generator.mybatis.plugins.MapperXmlMapperPlugin"/&gt; &lt;plugin type="com.flower.canna.cloud.generator.mybatis.plugins.ExpandMapperXmlMapperPlugin"/&gt; &lt;plugin type="com.flower.canna.cloud.generator.mybatis.plugins.biz.JavaServicePlugin"/&gt; &lt;plugin type="com.flower.canna.cloud.generator.mybatis.plugins.biz.JavaEnumPlugin"/&gt; &lt;plugin type="com.flower.canna.cloud.generator.mybatis.plugins.CommonMapperPlugin"/&gt; &lt;commentGenerator type="com.flower.canna.cloud.generator.mybatis.rewrite.RemarkDefaultCommentGenerator"&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass="org.postgresql.Driver" connectionURL="jdbc:postgresql://120.78.61.232:35432/db_wallet" userId="postgres" password="postgres"&gt; &lt;property name="remarksReporting" value="true"/&gt; &lt;property name="useInformationSchema" value="true"/&gt; &lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage="com.flower.canna.cloud.service.app.api.model" targetProject="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-api/src/main/java"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;property name="rootClass" value="com.flower.canna.cloud.base.biz.model.Identifiable"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="mybatis.postgresql.com.flower.canna.cloud.service.app" targetProject="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-producer/src/main/resources"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator targetPackage="com.flower.canna.cloud.service.app.producer.mapper" targetProject="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-producer/src/main/java" type="CANNA_MAPPER"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;property name="rootInterface" value="com.flower.canna.cloud.base.biz.mapper.BaseMapper"/&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="t_app_info" domainObjectName="AppInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false" catalog="catalog" alias="t"&gt; &lt;property name="runtimeSchema" value="${module_app}"/&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;property name="serviceGenerator-targetPackage" value="com.flower.canna.cloud.service.app.api.service"/&gt; &lt;property name="serviceGenerator-targetProject" value="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-api/src/main/java"/&gt; &lt;property name="serviceGenerator-template" value="common/service.vm"/&gt; &lt;property name="serviceGenerator-serviceName" value="AppInfoService"/&gt; &lt;property name="serviceGenerator-serviceFullName" value="com.flower.canna.cloud.service.app.api.service.AppInfoService"/&gt; &lt;property name="serviceGenerator-firstLowServiceName" value="appInfoService"/&gt; &lt;property name="serviceGenerator-firstLowConsumerServiceName" value="appInfoConsumerService"/&gt; &lt;property name="serviceGenerator-restPath" value="/app/info"/&gt; &lt;property name="serviceGenerator-feignClientName" value="T-APP-INFO"/&gt; &lt;property name="serviceImplGenerator-targetPackage" value="com.flower.canna.cloud.service.app.producer.service"/&gt; &lt;property name="serviceImplGenerator-targetProject" value="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-producer/src/main/java"/&gt; &lt;property name="serviceImplGenerator-template" value="common/service-impl.vm"/&gt; &lt;property name="serviceImplGenerator-serviceName" value="AppInfoService"/&gt; &lt;property name="serviceImplGenerator-serviceFullName" value="com.flower.canna.cloud.service.app.api.service.AppInfoService"/&gt; &lt;property name="serviceImplGenerator-firstLowServiceName" value="appInfoService"/&gt; &lt;property name="serviceImplGenerator-firstLowConsumerServiceName" value="appInfoConsumerService"/&gt; &lt;property name="serviceImplGenerator-restPath" value="/app/info"/&gt; &lt;property name="serviceImplGenerator-feignClientName" value="T-APP-INFO"/&gt; &lt;property name="producerControllerGenerator-targetPackage" value="com.flower.canna.cloud.service.app.producer.controller"/&gt; &lt;property name="producerControllerGenerator-targetProject" value="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-producer/src/main/java"/&gt; &lt;property name="producerControllerGenerator-template" value="eurake-base/producer-controller.vm"/&gt; &lt;property name="producerControllerGenerator-serviceName" value="AppInfoService"/&gt; &lt;property name="producerControllerGenerator-serviceFullName" value="com.flower.canna.cloud.service.app.api.service.AppInfoService"/&gt; &lt;property name="producerControllerGenerator-firstLowServiceName" value="appInfoService"/&gt; &lt;property name="producerControllerGenerator-firstLowConsumerServiceName" value="appInfoConsumerService"/&gt; &lt;property name="producerControllerGenerator-restPath" value="/app/info"/&gt; &lt;property name="producerControllerGenerator-feignClientName" value="T-APP-INFO"/&gt; &lt;property name="consumerControllerGenerator-targetPackage" value="com.flower.canna.cloud.service.app.consumer.controller"/&gt; &lt;property name="consumerControllerGenerator-targetProject" value="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-consumer/src/main/java"/&gt; &lt;property name="consumerControllerGenerator-template" value="eurake-base/consumer-controller.vm"/&gt; &lt;property name="consumerControllerGenerator-serviceName" value="AppInfoService"/&gt; &lt;property name="consumerControllerGenerator-serviceFullName" value="com.flower.canna.cloud.service.app.api.service.AppInfoService"/&gt; &lt;property name="consumerControllerGenerator-firstLowServiceName" value="appInfoService"/&gt; &lt;property name="consumerControllerGenerator-firstLowConsumerServiceName" value="appInfoConsumerService"/&gt; &lt;property name="consumerControllerGenerator-restPath" value="/app/info"/&gt; &lt;property name="consumerControllerGenerator-feignClientName" value="T-APP-INFO"/&gt; &lt;property name="consumerRemoteGenerator-targetPackage" value="com.flower.canna.cloud.service.app.consumer.remote"/&gt; &lt;property name="consumerRemoteGenerator-targetProject" value="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-consumer/src/main/java"/&gt; &lt;property name="consumerRemoteGenerator-template" value="eurake-base/consumer-remote.vm"/&gt; &lt;property name="consumerRemoteGenerator-serviceName" value="AppInfoService"/&gt; &lt;property name="consumerRemoteGenerator-serviceFullName" value="com.flower.canna.cloud.service.app.api.service.AppInfoService"/&gt; &lt;property name="consumerRemoteGenerator-firstLowServiceName" value="appInfoService"/&gt; &lt;property name="consumerRemoteGenerator-firstLowConsumerServiceName" value="appInfoConsumerService"/&gt; &lt;property name="consumerRemoteGenerator-restPath" value="/app/info"/&gt; &lt;property name="consumerRemoteGenerator-feignClientName" value="T-APP-INFO"/&gt; &lt;property name="consumerServiceGenerator-targetPackage" value="com.flower.canna.cloud.service.app.consumer.service"/&gt; &lt;property name="consumerServiceGenerator-targetProject" value="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-consumer/src/main/java"/&gt; &lt;property name="consumerServiceGenerator-template" value="eurake-base/consumer-service.vm"/&gt; &lt;property name="consumerServiceGenerator-serviceName" value="AppInfoService"/&gt; &lt;property name="consumerServiceGenerator-serviceFullName" value="com.flower.canna.cloud.service.app.api.service.AppInfoService"/&gt; &lt;property name="consumerServiceGenerator-firstLowServiceName" value="appInfoService"/&gt; &lt;property name="consumerServiceGenerator-firstLowConsumerServiceName" value="appInfoConsumerService"/&gt; &lt;property name="consumerServiceGenerator-restPath" value="/app/info"/&gt; &lt;property name="consumerServiceGenerator-feignClientName" value="T-APP-INFO"/&gt; &lt;property name="enumsGenerator-targetPackage" value="com.flower.canna.cloud.service.app.api.enums"/&gt; &lt;property name="enumsGenerator-targetProject" value="/canna-cloud/canna-cloud-service/canna-cloud-service-app/canna-cloud-service-app-api/src/main/java"/&gt; &lt;property name="enumsGenerator-template" value="not-exist-enum.vm"/&gt; &lt;property name="enumsGenerator-serviceName" value="AppInfoService"/&gt; &lt;property name="enumsGenerator-serviceFullName" value="com.flower.canna.cloud.service.app.api.service.AppInfoService"/&gt; &lt;property name="enumsGenerator-firstLowServiceName" value="appInfoService"/&gt; &lt;property name="enumsGenerator-firstLowConsumerServiceName" value="appInfoConsumerService"/&gt; &lt;property name="enumsGenerator-restPath" value="/app/info"/&gt; &lt;property name="enumsGenerator-feignClientName" value="T-APP-INFO"/&gt; &lt;generatedKey column="id" sqlStatement="JDBC"/&gt; &lt;columnOverride column="type" javaType="com.flower.canna.service.common.mybatis.EnumType" typeHandler="com.flower.canna.cloud.base.biz.mybatis.CommonEnumTypeHandler" delimitedColumnName="false"&gt; &lt;property name="operation" value="&amp;amp;lt;="/&gt; &lt;/columnOverride&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 4、通过一系列的自定义插件，完成相对应的代码生成 使用lombok，简化getter/setter，同时引入builder public class ModelMapperPlugin extends PluginAdapter { public ModelMapperPlugin() { super(); } @Override public boolean validate(List&lt;String&gt; warnings) { return true; } @Override public boolean modelBaseRecordClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) { topLevelClass.addImportedType("lombok.AllArgsConstructor"); topLevelClass.addImportedType("lombok.Builder"); topLevelClass.addImportedType("lombok.Getter"); topLevelClass.addImportedType("lombok.NoArgsConstructor"); topLevelClass.addImportedType("lombok.Setter"); topLevelClass.addAnnotation("@AllArgsConstructor"); topLevelClass.addAnnotation("@Builder"); topLevelClass.addAnnotation("@NoArgsConstructor"); topLevelClass.addAnnotation("@Setter"); topLevelClass.addAnnotation("@Getter"); return true; } @Override public boolean modelFieldGenerated(Field field, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) { // 添加日期操作 if ("Date".equals(introspectedColumn.getFullyQualifiedJavaType().getShortName())) { Field fieldPrefix = new Field(field.getName() + CommonConstants.DATE_PREFIX, FullyQualifiedJavaType.getStringInstance()); //$NON-NLS-1$ fieldPrefix.setVisibility(JavaVisibility.PRIVATE); Field fieldSuffix = new Field(field.getName() + CommonConstants.DATE_SUFFIX, FullyQualifiedJavaType.getStringInstance()); //$NON-NLS-1$ fieldSuffix.setVisibility(JavaVisibility.PRIVATE); topLevelClass.addField(fieldPrefix); topLevelClass.addField(fieldSuffix); try { IntrospectedColumn columnPrefix = BeanTransferUtils.transferColumn(introspectedColumn, IntrospectedColumn.class, IntrospectedColumn.class); columnPrefix.setActualColumnName(columnPrefix.getActualColumnName() + CommonConstants.DATE_PREFIX); columnPrefix.setRemarks( columnPrefix.getRemarks() + "-起始" ); IntrospectedColumn columnSuffix = BeanTransferUtils.transferColumn(introspectedColumn, IntrospectedColumn.class, IntrospectedColumn.class); columnSuffix.setActualColumnName(columnPrefix.getActualColumnName() + CommonConstants.DATE_SUFFIX); columnSuffix.setRemarks( columnSuffix.getRemarks() + "-截止" ); context.getCommentGenerator().addFieldComment(fieldPrefix, introspectedTable, columnPrefix); context.getCommentGenerator().addFieldComment(fieldSuffix, introspectedTable, columnSuffix); }catch (Exception e) { e.printStackTrace(); } } return true; } @Override public boolean modelSetterMethodGenerated(Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) { // 取消get/set return false; } @Override public boolean modelGetterMethodGenerated(Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) { // 取消get/set return false; } } 字段枚举的生成，避免在需要使用字段时，引入字符串，增加代码可读性 public class JavaEnumPlugin extends PluginAdapter { public JavaEnumPlugin() { super(); } @Override public boolean validate(List&lt;String&gt; warnings) { return true; } @Override public boolean clientGenerated(Interface interfaze, IntrospectedTable introspectedTable) { this.generatorEnum(introspectedTable); return true; } private void generatorEnum(IntrospectedTable introspectedTable) { String tagName = TagConstants.ENUMS_GENERATOR; Properties properties = introspectedTable.getTableConfiguration().getProperties(); String targetPackage = properties.getProperty(tagName + "-" + AttrConstants.TARGET_PACKAGE); String targetProject = properties.getProperty(tagName + "-" + AttrConstants.TARGET_PROJECT); String domainObjectName = introspectedTable.getTableConfiguration().getDomainObjectName(); String enumColumnJava = CannaUtils.getFullName(targetProject, targetPackage, domainObjectName,"Enum.java"); String packageLine = "package " + targetPackage + ";"; String enumName = "public enum " + domainObjectName + "Enum {"; List&lt;String&gt; resultList = new ArrayList&lt;&gt;(); resultList.add(packageLine); resultList.add(enumName); for ( IntrospectedColumn introspectedColumn: introspectedTable.getAllColumns() ) { resultList.add(" " + introspectedColumn.getActualColumnName().toUpperCase() + ","); } resultList.add("}"); try { FileUtils.writeLines(new File(enumColumnJava), CommonConstants.DEFAULT_CHARSET, resultList); } catch (IOException e) { System.err.println(e); } } } 5、继承代码生成逻辑，添加自定义Mapper生成器 public class CannaTableMyBatis3 extends IntrospectedTableMyBatis3Impl { @Override public List&lt;GeneratedXmlFile&gt; getGeneratedXmlFiles() { List&lt;GeneratedXmlFile&gt; answer = new ArrayList&lt;&gt;(); if (xmlMapperGenerator != null) { Document document = xmlMapperGenerator.getDocument(); GeneratedXmlFile gxf = new GeneratedXmlFile(document, getMyBatis3XmlMapperFileName(), getMyBatis3XmlMapperPackage(), context.getSqlMapGeneratorConfiguration().getTargetProject(), false, context.getXmlFormatter()); if (context.getPlugins().sqlMapGenerated(gxf, this)) { answer.add(gxf); } } return answer; } protected AbstractJavaClientGenerator createJavaClientGenerator() { if (context.getJavaClientGeneratorConfiguration() == null) { return null; } String type = context.getJavaClientGeneratorConfiguration() .getConfigurationType(); AbstractJavaClientGenerator javaGenerator; if ("XMLMAPPER".equalsIgnoreCase(type)) { //$NON-NLS-1$ javaGenerator = new JavaMapperGenerator(getClientProject()); } else if ("MIXEDMAPPER".equalsIgnoreCase(type)) { //$NON-NLS-1$ javaGenerator = new MixedClientGenerator(getClientProject()); } else if ("ANNOTATEDMAPPER".equalsIgnoreCase(type)) { //$NON-NLS-1$ javaGenerator = new AnnotatedClientGenerator(getClientProject()); } else if ("MAPPER".equalsIgnoreCase(type)) { //$NON-NLS-1$ javaGenerator = new JavaMapperGenerator(getClientProject()); } else if ("CANNA_MAPPER".equalsIgnoreCase(type)) { //$NON-NLS-1$ javaGenerator = new CannaJavaMapperGenerator(getClientProject()); } else { javaGenerator = (AbstractJavaClientGenerator) ObjectFactory .createInternalObject(type); } return javaGenerator; } } 6、自动生成apidoc，方便前后端对接 public class RemarkDefaultCommentGenerator extends DefaultCommentGenerator { @Override public void addClassComment(InnerClass innerClass, IntrospectedTable introspectedTable) { innerClass.addJavaDocLine("/**"); innerClass.addJavaDocLine(" * @apiDefine SUCCESS_" + introspectedTable.getFullyQualifiedTable().getDomainObjectName()); List&lt;IntrospectedColumn&gt; introspectedColumnList = introspectedTable.getAllColumns(); for (IntrospectedColumn introspectedColumn: introspectedColumnList){ innerClass.addJavaDocLine(" * @apiSuccess {" + introspectedColumn.getFullyQualifiedJavaType().getShortName() + "} " + introspectedColumn.getJavaProperty() + " " + introspectedColumn.getRemarks()); } innerClass.addJavaDocLine(" */"); innerClass.addJavaDocLine("/**"); innerClass.addJavaDocLine(" * @apiDefine PARAM_" + introspectedTable.getFullyQualifiedTable().getDomainObjectName()); for (IntrospectedColumn introspectedColumn: introspectedColumnList){ innerClass.addJavaDocLine(" * @apiParam {" + introspectedColumn.getFullyQualifiedJavaType().getShortName() + "} " + introspectedColumn.getJavaProperty() + " " + introspectedColumn.getRemarks()); } innerClass.addJavaDocLine(" */"); } @Override public void addModelClassComment(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) { this.addClassComment(topLevelClass, introspectedTable); } @Override public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) { field.addJavaDocLine("/**"); //$NON-NLS-1$ if (introspectedColumn.getRemarks() != null) { field.addJavaDocLine(" * " + introspectedColumn.getRemarks()); //$NON-NLS-1$ } field.addJavaDocLine(" */"); //$NON-NLS-1$ } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canna-cloud【一】前言：canna-cloud的构想与实践]]></title>
    <url>%2F2019%2F03%2F31%2Fcanna-cloud-1%2F</url>
    <content type="text"><![CDATA[canna-cloud 基于Spring+SpringMVC+Mybatis分布式系统，引入Spring boot + Spring Cloud微服务架构， 提供一整套企业系统的公共微服务模块与系统，努力打造全方位J2EE企业级开发解决方案。 项目工程地址 githup项目地址 系统简介 基于Spring+SpringMVC+Mybatis分布式系统，引入Spring boot + Spring Cloud微服务架构， 提供一整套企业系统的公共微服务模块与系统，努力打造全方位J2EE企业级开发解决方案。 系统功能|- 1、系统信息管理 | |-用户管理 | |-角色管理 | |-资源管理 | |-部门管理 | |- 2、配置中心 | |-基础字典管理 | |-基础参数管理 | |-地区管理 | |- 3、缓存系统 | |-基础缓存 | |-用户缓存 | |-业务缓存 | |-缓存刷新 | |- 4、监控系统 | |-资源监控服务 | |-服务状态监控 | |-日志信息监控 | |-服务异常报警 | |- 5、告警系统 | |-告警服务管理 | |-邮件提醒 | |-短信提醒 | |- 6、fastdfs文件系统 | |-文件分类 | |-文件上传 | |-文件下载 | |-文件搜索 | |-文件权限管理 | |-文件同步 | |- 7、FTP文件系统 | |-查看FTP文件列表 | |-文件下载 | |-文件上传 | |-文件删除 | |- 8、应用分发系统 | |-应用信息管理 | |-应用版本管理 | |-应用打包服务 | |- 9、支付系统 | |-支付宝支付 | |-微信支付 | |- 10、商城系统 | |-商品管理 | |-商城展示 | |-商品购买 | |-订单管理 | |- 11、物流系统 | |-订单流转 | |- 12、会员管理 | |-普通会员管理 | |-代理会员管理 | |-会员第三方授权 | |- 13、博客系统 | |-会员博客管理 | |-会员博客展示 | |- 14、书城系统 | |-连载管理 | |-书城连载展示 | |- 15、图书馆管理系统 | |-图书分类 | |-图书条形码/二维码 | |-图书上架 | |-图书下架 | |-图书借出 | |-图书归还 系统架构工程结构canna-cloud(com.flower.canna.cloud) |- canna-cloud-ui |- canna-cloud-base(com.flower.canna.cloud.base) | |-canna-cloud-base-biz(com.flower.canna.cloud.base.biz) | |-canna-cloud-base-cache | |-canna-cloud-base-file | |-canna-cloud-base-http | |-canna-cloud-base-notice | |-canna-cloud-base-office | |-canna-cloud-base-parent | |-canna-cloud-base-shine | |-canna-cloud-base-sqlite | |-canna-cloud-base-tools |-canna-cloud-service(com.flower.canna.cloud.service) | |-canna-cloud-service-system(com.flower.canna.cloud.service.system) | | |-canna-cloud-service-system-api(com.flower.canna.cloud.service.system.api) | | |-------------------------------(com.flower.canna.cloud.service.system.api.constants) | | |-------------------------------(com.flower.canna.cloud.service.system.api.exception) | | |-------------------------------(com.flower.canna.cloud.service.system.api.enums) | | |-------------------------------(com.flower.canna.cloud.service.system.api.model) | | |-------------------------------(com.flower.canna.cloud.service.system.api.service) | | |-------------------------------(com.flower.canna.cloud.service.system.api.vo) | | |-canna-cloud-service-system-consumer(com.flower.canna.cloud.service.system.consumer) | | |-------------------------------(com.flower.canna.cloud.service.system.consumer.controller) | | |-------------------------------(com.flower.canna.cloud.service.system.consumer.remote) | | |-------------------------------(com.flower.canna.cloud.service.system.consumer.service) | | |-canna-cloud-service-system-producer(com.flower.canna.cloud.service.system.producer) | | |-------------------------------(com.flower.canna.cloud.service.system.consumer.controller) | | |-------------------------------(com.flower.canna.cloud.service.system.consumer.mapper) | | |-------------------------------(com.flower.canna.cloud.service.system.consumer.service) | |-canna-cloud-service-config | | |-canna-cloud-service-config-api | | |-canna-cloud-service-config-consumer | | |-canna-cloud-service-config-producer | |-canna-cloud-service-cache | | |-canna-cloud-service-cache-api | | |-canna-cloud-service-cache-consumer | | |-canna-cloud-service-cache-producer | |-canna-cloud-service-monitor | | |-canna-cloud-service-monitor-api | | |-canna-cloud-service-monitor-consumer | | |-canna-cloud-service-monitor-producer | |-canna-cloud-service-alarm | | |-canna-cloud-service-alarm-api | | |-canna-cloud-service-alarm-consumer | | |-canna-cloud-service-alarm-producer | |-canna-cloud-service-fastdfs | | |-canna-cloud-service-fastdfs-api | | |-canna-cloud-service-fastdfs-consumer | | |-canna-cloud-service-fastdfs-producer |-canna-cloud-module | |-canna-cloud-module-manager |-canna-cloud-server | |-canna-cloud-server-manager |-canna-cloud-generator | |-canna-cloud-generator-mybatis |-canna-cloud-maven-plugin 技术选型1、前端打包工具: npm/cnpm MVVM框架: vue 脚手架: vue-cli3 UI框架: iview 可视化图标: echarts 2、后台 基础框架: spring-framework-5.0.1 spring-boot-2.1.2 + spring-cloud-Greenwich 缓存框架: redis ORM框架: mybatis 数据库: postgresql/mysql/mariadb 消息中间件: kafka / activemq 文件系统: fastdfs/ftp/七牛云 邮件服务: jodd-mail 项目管理: maven 工具持续集成： jenkins 代码审查： sonarqube maven仓库：nexus 前端仓库: verdaccio 移动端cordova + h5 开发计划使用微服务框架spring cloud eureka spring cloud feign spring cloud starters spring cloud config spring cloud bus spring cloud zuul spring cloud ribbon spring cloud stream spring cloud hystrix spring cloud cluster 一期集成功能系统基础工程 | 代码自动生成器 | 微服务框架集成使用 |-spring security |-spring cloud eureka |-spring cloud feign |-spring cloud starters | 开发功能 |-系统信息管理 |-配置中心 |-缓存系统 |-fastdfs文件系统 |-ftp文件系统 二期集成功能微服务框架集成使用 |-spring cloud config |-spring cloud bus |-spring cloud zuul |-spring cloud ribbon |-spring cloud stream | 开发功能 |-应用分发系统 |-支付系统 |-告警系统 环境部署FastdfsFastdfs集群postgresqlmysqlmysql主备mysql主主postgresql主备jenkinsnexusverdacciosonarqube加入我们 QQ: 471023334 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>canna-cloud</category>
      </categories>
      <tags>
        <tag>canna-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【二十一】安装android打包环境]]></title>
    <url>%2F2019%2F03%2F16%2Fcentos7-soft-install-21%2F</url>
    <content type="text"><![CDATA[下载地址： https://developer.android.google.cn/studio 下载指定文件： 命令如下： mkdir -p /data-scm/app/android-home cd /data-scm/app/android-home wget https://dl.google.com/android/repository/sdk-tools-linux-4333796.zip unzip sdk-tools-linux-4333796.zip mv tools/ android-tools echo "export ANDROID_HOME=/data-scm/app/android-home" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$ANDROID_HOME/android-tools:\$ANDROID_HOME/android-tools/bin:\$ANDROID_HOME/platform-tools" &gt;&gt; /etc/profile source /etc/profile mkdir android-sdk cd android-sdk sdkmanager "build-tools;19.1.0" sdkmanager "build-tools;20.0.0" sdkmanager "build-tools;21.1.2" sdkmanager "build-tools;22.0.1" sdkmanager "build-tools;23.0.1" sdkmanager "build-tools;23.0.3" sdkmanager "build-tools;24.0.0" sdkmanager "build-tools;24.0.1" sdkmanager "build-tools;24.0.2" sdkmanager "build-tools;24.0.3" sdkmanager "build-tools;25.0.0" sdkmanager "build-tools;25.0.1" sdkmanager "build-tools;25.0.2" sdkmanager "build-tools;25.0.3" sdkmanager "build-tools;26.0.0" sdkmanager "build-tools;26.0.1" sdkmanager "build-tools;26.0.2" sdkmanager "build-tools;26.0.3" sdkmanager "build-tools;27.0.0" sdkmanager "build-tools;27.0.1" sdkmanager "build-tools;27.0.2" sdkmanager "build-tools;27.0.3" sdkmanager "build-tools;28.0.0" sdkmanager "build-tools;28.0.1" sdkmanager "build-tools;28.0.2" sdkmanager "build-tools;28.0.3" sdkmanager "platform-tools" sdkmanager "platforms;android-10" sdkmanager "platforms;android-11" sdkmanager "platforms;android-12" sdkmanager "platforms;android-13" sdkmanager "platforms;android-14" sdkmanager "platforms;android-15" sdkmanager "platforms;android-16" sdkmanager "platforms;android-17" sdkmanager "platforms;android-18" sdkmanager "platforms;android-19" sdkmanager "platforms;android-20" sdkmanager "platforms;android-21" sdkmanager "platforms;android-22" sdkmanager "platforms;android-23" sdkmanager "platforms;android-24" sdkmanager "platforms;android-25" sdkmanager "platforms;android-26" sdkmanager "platforms;android-27" sdkmanager "platforms;android-28" cd /data-scm/app/ wget https://services.gradle.org/distributions/gradle-4.4-bin.zip unzip gradle-4.4-bin.zip echo "export GRADLE_HOME=/data-scm/app/gradle-4.4" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$GRADLE_HOME/bin" &gt;&gt; /etc/profile source /etc/profile document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【二十】安装gradle]]></title>
    <url>%2F2019%2F03%2F16%2Fcentos7-soft-install-20%2F</url>
    <content type="text"><![CDATA[mkdir -p /data-scm/app/ cd /data-scm/app/ wget https://services.gradle.org/distributions/gradle-4.4-bin.zip unzip gradle-4.4-bin.zip echo "export GRADLE_HOME=/data-scm/app/gradle-4.4" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$GRADLE_HOME/bin" &gt;&gt; /etc/profile source /etc/profile #验证 gradle -version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【十三】观察者模式]]></title>
    <url>%2F2019%2F03%2F14%2Fdesign-pattern-13%2F</url>
    <content type="text"><![CDATA[说明：观察者中包含全部待观察的对象，可以自由的添加删除待观察的对象。统一的向对象发布通知消息。比较类似消息中间中的消息订阅模式。 1、类图： 2、实现 public abstract class AbstractExport { protected String docName; protected AbstractExportObserve abstractExportObserve; public AbstractExport(AbstractExportObserve abstractExportObserve) { this.abstractExportObserve = abstractExportObserve; } public abstract void update(); } public abstract class AbstractExportObserve { protected List&lt;AbstractExport&gt; abstractExportList = new ArrayList&lt;&gt;(); private String platform; private String msgInfo; public String getMsgInfo() { return msgInfo; } public void setMsgInfo(String msgInfo) { this.msgInfo = msgInfo; } public String getPlatform() { return platform; } public void setPlatform(String platform) { this.platform = platform; } public void add(AbstractExport abstractExport) { abstractExportList.add(abstractExport); } public void remove(AbstractExport abstractExport){ abstractExportList.add(abstractExport); } public void update() { for (AbstractExport abstractExport: abstractExportList) { abstractExport.update(); } } } public class AsyncExport extends AbstractExport { public AsyncExport(AbstractExportObserve abstractExportObserve) { super(abstractExportObserve); super.docName = "ASYNC"; } @Override public void update() { System.out.println("export type:" + super.docName + ";msgInfo:" + abstractExportObserve.getMsgInfo() + "; platform:" + abstractExportObserve.getPlatform()); } } public class SyncExport extends AbstractExport { public SyncExport(AbstractExportObserve abstractExportObserve) { super(abstractExportObserve); super.docName = "SYNC"; } @Override public void update() { System.out.println("export type:" + super.docName + ";msgInfo:" + abstractExportObserve.getMsgInfo() + "; platform:" + abstractExportObserve.getPlatform()); } } public class CentosExportObserve extends AbstractExportObserve { public CentosExportObserve() { setPlatform("Centos"); } } public class WindowsExportObserve extends AbstractExportObserve { public WindowsExportObserve() { setPlatform("Windows"); } } public class ExportTest { public static void main(String[] args) { notifyCentos(); notifyWindows(); } private static void notifyWindows() { WindowsExportObserve windowsExportObserve = new WindowsExportObserve(); AsyncExport asyncExport = new AsyncExport(windowsExportObserve); SyncExport syncExport = new SyncExport(windowsExportObserve); windowsExportObserve.add(asyncExport); windowsExportObserve.add(syncExport); windowsExportObserve.setMsgInfo("test notice"); windowsExportObserve.update(); } private static void notifyCentos() { CentosExportObserve centosExportObserve = new CentosExportObserve(); AsyncExport asyncExport = new AsyncExport(centosExportObserve); SyncExport syncExport = new SyncExport(centosExportObserve); centosExportObserve.add(asyncExport); centosExportObserve.add(syncExport); centosExportObserve.setMsgInfo("test notice"); centosExportObserve.update(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【十二】外观模式]]></title>
    <url>%2F2019%2F03%2F14%2Fdesign-pattern-12%2F</url>
    <content type="text"><![CDATA[说明：提供对不同类的一系列操作的一个集合封装。向外提供一个高内聚的接口。 与模板方法不同的是，模板方法在抽象类中实现定义了流程，在子类中对具体进行实现。 外观模式是封装了现有类的实现，整合成一个所需的业务流程。 1、类图： 2、 public class AsyncExport { private String exportType; public AsyncExport() { this.exportType = "ASYNC"; } public void exportAsync() { System.out.println("export type:" + this.exportType); } } public class DefaultExport { private String exportType; public DefaultExport() { this.exportType = "Default"; } public void exportDefault() { System.out.println("export type:" + this.exportType); } } public class SyncExport { private String exportType; public SyncExport() { this.exportType = "SYNC"; } public void exportSync() { System.out.println("export type:" + this.exportType); } } public class Face { private SyncExport syncExport; private AsyncExport asyncExport; private DefaultExport defaultExport; public Face(){ this.syncExport = new SyncExport(); this.defaultExport = new DefaultExport(); this.asyncExport = new AsyncExport(); } public void export(){ defaultExport.exportDefault(); asyncExport.exportAsync(); syncExport.exportSync(); } } public class ExportTest { public static void main(String[] args) { Face face = new Face(); face.export(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【十一】适配器模式]]></title>
    <url>%2F2019%2F03%2F14%2Fdesign-pattern-11%2F</url>
    <content type="text"><![CDATA[说明：主要用于接口的转化，一般在外部接口对接、系统升级改造时可能会使用。大部分情况下少用，会增加系统复杂度，却又没有实质性的作用。 1、类图 2、实现 public class SyncExport { private String exportType; public SyncExport() { exportType = "SYNC"; } public void exportSync() { System.out.println("export type:" + this.exportType); } } public class Adapter { private SyncExport syncExport; public Adapter(){ this.syncExport = new SyncExport(); } public void export(){ syncExport.exportSync(); } } public class ExportTest { public static void main(String[] args) { Adapter adapter = new Adapter(); adapter.export(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【十】模板方法模式]]></title>
    <url>%2F2019%2F03%2F13%2Fdesign-pattern-10%2F</url>
    <content type="text"><![CDATA[说明：模板提供整体的框架，把抽象的实现留到子类中。 1、类图 2、实现： public abstract class AbstractExport implements Cloneable { protected String exportType; protected abstract void exportPrivate(); public void export() { System.out.println("export type:" + this.exportType); this.exportPrivate(); System.out.println("end export private"); } } public class AsyncExport extends AbstractExport { public AsyncExport() { super.exportType = "ASYNC"; } @Override protected void exportPrivate() { System.out.println("export async private"); } } public class SyncExport extends AbstractExport { public SyncExport() { super.exportType = "SYNC"; } @Override protected void exportPrivate() { System.out.println("export async private"); } } public class ExportTest { public static void main(String[] args) throws CloneNotSupportedException { AbstractExport asyncExport = new AsyncExport(); asyncExport.export(); System.out.println("======"); AbstractExport syncExport = new SyncExport(); syncExport.export(); } } 3、实际项目应用： 模板方法在实际项目中的应用算是比较多的。比如用户不同密码校验方式。不同拦截器的实现等，一般都会使用到模板方法模式。抽象类中提供解决方法的思路框架，具体的实现在实现类中，也有助于理清开发思路。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【九】原型模式]]></title>
    <url>%2F2019%2F03%2F13%2Fdesign-pattern-9%2F</url>
    <content type="text"><![CDATA[原型模式：通过原型实例，拷贝创建新的对象。 1、类图： 2、实现： public abstract class AbstractExport implements Cloneable { protected String exportType; protected String name; public String getExportType() { return exportType; } public void setExportType(String exportType) { this.exportType = exportType; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Object clone() throws CloneNotSupportedException { return super.clone(); } public void export() { System.out.println("export type:" + this.exportType); System.out.println("export name:" + this.name); } } public class AsyncExport extends AbstractExport { public AsyncExport() { super.exportType = "ASYNC"; } } public class SyncExport extends AbstractExport { public SyncExport() { super.exportType = "SYNC"; } } public class ExportTest { public static void main(String[] args) throws CloneNotSupportedException { AbstractExport asyncExport = new AsyncExport(); asyncExport.setName("windows"); asyncExport.export(); AbstractExport asyncExportNew = (AbstractExport) asyncExport.clone(); asyncExportNew.export(); System.out.println("======"); AbstractExport syncExport = new SyncExport(); syncExport.setName("windows2"); syncExport.export(); AbstractExport syncExportNew = (AbstractExport) syncExport.clone(); syncExportNew.export(); } } 3、clone实现的是浅拷贝，如果需要深拷贝，可以在clone中对相应的对象在次进行拷贝并赋值。 4、原型拷贝在想要保留对象原有数据时非常有用。在java中也有其它工具根据实体对象的get、set方法的反射进行字段复制，当然也可以自己根据反射，获取method、field相关信息并进行设置。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【八】工厂方法模式]]></title>
    <url>%2F2019%2F03%2F13%2Fdesign-pattern-8%2F</url>
    <content type="text"><![CDATA[工厂方法模式：不负责全部对象的创建，而是将创建对象放到工厂方法，在具体的客户端根据需要的工厂进行实例化。 1、类图： 2、实现 public abstract class AbstractExport { protected String exportType; public abstract void export(); } public interface IExportFactory { AbstractExport createExport(); } public class AsyncExport extends AbstractExport { public AsyncExport() { super.exportType = "ASYNC"; } @Override public void export() { System.out.println("export type:" + super.exportType); } } public class SyncExport extends AbstractExport { public SyncExport() { super.exportType = "SYNC"; } @Override public void export() { System.out.println("export type:" + super.exportType); } } public class AgentExportFactory implements IExportFactory { public AgentExportFactory() { System.out.println("SyncExportFactory"); } @Override public AbstractExport createExport() { return new SyncExport(); } } public class UserExportFactory implements IExportFactory { public UserExportFactory() { System.out.println("AsyncExportFactory"); } public AbstractExport createExport() { return new SyncExport(); } } public class ExportTest { public static void main(String[] args) { IExportFactory asyncExportFactory = new UserExportFactory(); AbstractExport asyncExport = asyncExportFactory.createExport(); asyncExport.export(); IExportFactory syncExportFactory = new AgentExportFactory(); AbstractExport syncExport = syncExportFactory.createExport(); syncExport.export(); } } 3、优点：工厂类的具体实现客户端可以无需关心。在工厂中可以自由更换实现。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【七】建造者模式]]></title>
    <url>%2F2019%2F03%2F13%2Fdesign-pattern-7%2F</url>
    <content type="text"><![CDATA[建造者模式：将构建一个复杂的对象与它的表示分离，使得同样的构建构建过程可以有不同的表示。 1、类图 2、实现 public abstract class AbstractExport { protected String type; protected String name; public abstract void buildType(); public abstract void buildName(); public final void build() { buildType(); buildName(); System.out.println("type:" + this.type); System.out.println("name:" + this.name); } } public class AsyncExport extends AbstractExport { @Override public void buildType() { super.type = "async type"; } @Override public void buildName() { super.name = "async name"; } } public class SyncExport extends AbstractExport { @Override public void buildType() { super.type = "sync type"; } @Override public void buildName() { super.name = "sync name"; } } public class ExportTest { public static void main(String[] args) { AsyncExport asyncExport = new AsyncExport(); asyncExport.buildName(); asyncExport.buildType(); asyncExport.build(); } } 3、实际使用 public class BaseCode { private static final long serialVersionUID = 1L; private String code; private Long type; public static BaseCode.BaseCodeBuilder builder() { return new BaseCode.BaseCodeBuilder(); } public BaseCode(String code, Long type) { this.code = code; this.type = type; } public BaseCode() { } public String getCode() { return this.code; } public Long getType() { return this.type; } public void setCode(String code) { this.code = code; } public void setType(Long type) { this.type = type; } public static class BaseCodeBuilder { private String code; private Long type; BaseCodeBuilder() { } public BaseCode.BaseCodeBuilder code(String code) { this.code = code; return this; } public BaseCode.BaseCodeBuilder type(Long type) { this.type = type; return this; } public BaseCode build() { return new BaseCode(this.code, this.type); } public String toString() { return "BaseCode.BaseCodeBuilder(code=" + this.code + ", type=" + this.type + ")"; } } } 4、lombok中的建造者模式 使用：@Builder @Builder public class BaseCode { private static final long serialVersionUID = 1L; /** * &lt;pre&gt; * 编码 * &lt;/pre&gt; * */ private String code; /** * &lt;pre&gt; * 编码类型：1:BOSS;2:VIP * &lt;/pre&gt; * */ private Long type; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【六】代理模式]]></title>
    <url>%2F2019%2F03%2F13%2Fdesign-pattern-6%2F</url>
    <content type="text"><![CDATA[代理模式：对外提供对原对象的一个访问方式。通过代理，可以在被代理的方法上统一做一些业务处理，比如说事务、异常、参数等校验 1、类图 2、方案一：使用方法时创建代理 public abstract class AbstractExport { protected String exportType; public abstract void export(); } public class SyncExport extends AbstractExport { public SyncExport() { super.exportType = "SYNC"; System.out.println("init sync export"); } @Override public void export() { System.out.println("export type:" + super.exportType); } } public class ProxySyncExport extends AbstractExport { private AbstractExport export; public ProxySyncExport() { super.exportType = "REAL_SYNC"; } @Override public void export() { if (export == null) { export = new SyncExport(); } export.export(); } } public class ExportTest { public static void main(String[] args) { AbstractExport export = new ProxySyncExport(); export.export(); export.export(); } } 3、方案二：构造时初始化 public abstract class AbstractExport { protected String exportType; public abstract void export(); } public class SyncExport extends AbstractExport { public SyncExport() { super.exportType = "SYNC"; System.out.println("init sync export"); } @Override public void export() { System.out.println("export type:" + super.exportType); } } public class ProxyQuickExport extends AbstractExport { private AbstractExport export; public ProxyQuickExport(AbstractExport export) { super.exportType = "QUICK_SYNC"; this.export = export; } @Override public void export() { export.export(); } } public class QuickExportTest { public static void main(String[] args) { SyncExport syncExport = new SyncExport(); AbstractExport export = new ProxyQuickExport(syncExport); export.export(); export.export(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【五】装饰模式]]></title>
    <url>%2F2019%2F03%2F13%2Fdesign-pattern-5%2F</url>
    <content type="text"><![CDATA[1、类图 2、实现 public interface IExport { void export(); } public abstract class AbstractSyncExport implements IExport { protected IExport parentExport; public AbstractSyncExport(){} public AbstractSyncExport(IExport export) { this.parentExport = export; } } public class AsyncExport extends AbstractSyncExport { private String test = "init async"; public AsyncExport(IExport sync) { super(sync); } @Override public void export() { this.parentExport.export(); System.out.println(test); System.out.println("export type: async" ); } } public class SyncExport extends AbstractSyncExport { public SyncExport(IExport export) { super(export); } @Override public void export() { this.parentExport.export(); System.out.println("export type: sync"); } } public class MainExport implements IExport { @Override public void export() { System.out.println("export type: begin"); } } public class ExportTest { public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException { IExport begin = new MainExport(); IExport sync = new SyncExport(begin); IExport async = new AsyncExport(sync); async.export(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【四】单例模式]]></title>
    <url>%2F2019%2F03%2F13%2Fdesign-pattern-4%2F</url>
    <content type="text"><![CDATA[单例模式：一个类只能创建一个实例。 类图: 实现方式有以下几种： 1、懒汉式： public class Export { private static Export export; private Export() { } public static Export getInstance() { if (export == null) { export = new Export(); } return export; } public void print(){ System.out.println("this is singleton"); } } 2、线程安全懒汉式：全部实例加锁 public class SyncFuncExport { private static SyncFuncExport export; private SyncFuncExport() { } public static synchronized SyncFuncExport getInstance() { if (export == null) { export = new SyncFuncExport(); } return export; } public void print(){ System.out.println("this is synchronized function singleton"); } } 3、线程安全锁懒汉式：如果已初始化则没有锁，提高性能 public class SyncClassExport { private static SyncClassExport export; private SyncClassExport() { } public static SyncClassExport getInstance() { if (export == null) { synchronized (SyncClassExport.class) { if (export == null) { export = new SyncClassExport(); } } } return export; } public void print(){ System.out.println("this is synchronized class singleton"); } } 4、类加载时实例化，实现简单。 public class InitExport { private static InitExport export = new InitExport(); private InitExport() { } public static InitExport getInstance() { return export; } public void print(){ System.out.println("this is init singleton"); } } 5、通过内部类，在使用时实例化 public class InnerClassExport { private static class InnerClassExportInstance{ public static final InnerClassExport export = new InnerClassExport(); } private InnerClassExport() { } public static InnerClassExport getInstance() { return InnerClassExportInstance.export; } public void print(){ System.out.println("this is inner class singleton"); } } 6、为避免子类实例化，添加final，不能被继承 public final class InitExport { private static InitExport export = new InitExport(); private InitExport() { } public static InitExport getInstance() { return export; } public void print(){ System.out.println("this is init singleton"); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【三】策略模式]]></title>
    <url>%2F2019%2F03%2F11%2Fdesign-pattern-3%2F</url>
    <content type="text"><![CDATA[1、类图 2、实现 主要解决输入相近，不同算法计算输出的问题 public abstract class AbstractExport { protected String exportType; public abstract void export(String str); } public class AsyncExport extends AbstractExport { public AsyncExport() { super.exportType = "ASYNC"; } @Override public void export(String str) { System.out.println("export type:" + super.exportType + ";str:" + str); } } public class SyncExport extends AbstractExport { public SyncExport() { super.exportType = "SYNC"; } @Override public void export(String str) { System.out.println("export type:" + super.exportType + ";str:" + str); } } public class NormalExport extends AbstractExport { public NormalExport() { super.exportType = "NORMAL"; } @Override public void export(String str) { System.out.println("export type:" + super.exportType + ";str:" + str); } } public class Context { private AbstractExport abstractExport; public Context(AbstractExport abstractExport) { this.abstractExport = abstractExport; } public void export(String str) { this.abstractExport.export(str); } } public class ExportTest { public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException { String str = "test"; AbstractExport export = new SyncExport(); Context context = new Context(export); context.export(str); AbstractExport exportClass = (AbstractExport) Class.forName(SyncExport.class.getName()).newInstance(); Context contextReflect = new Context(exportClass); contextReflect.export(str); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【二】抽象工厂模式]]></title>
    <url>%2F2019%2F03%2F11%2Fdesign-pattern-2%2F</url>
    <content type="text"><![CDATA[1、类图 2、实现 抽象工厂模式，通过反射实例化，可将具体的实现方式放入配置文件中。 public abstract class AbstractExport { protected String exportType; public abstract void export(); } public class SyncExport extends AbstractExport { public SyncExport() { super.exportType = "SYNC"; } @Override public void export() { System.out.println("export type:" + super.exportType); } } public class AsyncExport extends AbstractExport { public AsyncExport() { super.exportType = "ASYNC"; } @Override public void export() { System.out.println("export type:" + super.exportType); } } public interface IExportFactory { AbstractExport createExport(String exportType); AbstractExport createExportFormClass(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException; } public class CentosExportFactory implements IExportFactory{ public CentosExportFactory() { System.out.println("CentosExportFactory"); } public AbstractExport createExport(String exportType) { AbstractExport export = null; switch (exportType) { case "SYNC": export = new SyncExport(); break; case "ASYNC": export = new AsyncExport(); break; } return export; } public AbstractExport createExportFormClass(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException { AbstractExport export = (AbstractExport) Class.forName(className).newInstance(); return export; } } public class WindowsExportFactory implements IExportFactory{ public WindowsExportFactory() { System.out.println("WindowsExportFactory"); } public AbstractExport createExport(String exportType) { AbstractExport export = null; switch (exportType) { case "SYNC": export = new SyncExport(); break; case "ASYNC": export = new AsyncExport(); break; } return export; } public AbstractExport createExportFormClass(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException { AbstractExport export = (AbstractExport) Class.forName(className).newInstance(); return export; } } public class ExportTest { public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException { // IExportFactory iExportFactory = new WindowsExportFactory(); IExportFactory iExportFactory = (IExportFactory) Class.forName(WindowsExportFactory.class.getName()).newInstance(); AbstractExport export = iExportFactory.createExport("SYNC"); export.export(); AbstractExport exportClass = iExportFactory.createExportFormClass(SyncExport.class.getName()); exportClass.export(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式【一】简单工厂模式]]></title>
    <url>%2F2019%2F03%2F11%2Fdesign-pattern-1%2F</url>
    <content type="text"><![CDATA[1、类图 2、实现： 两种方式，通过反射降低工厂类与实际实现的耦合度。 public abstract class AbstractExport { protected String exportType; public abstract void export(); } public class SyncExport extends AbstractExport { public SyncExport() { super.exportType = "SYNC"; } @Override public void export() { System.out.println("export type:" + super.exportType); } } public class AsyncExport extends AbstractExport { public AsyncExport() { super.exportType = "ASYNC"; } @Override public void export() { System.out.println("export type:" + super.exportType); } } public class ExportFactory { public static AbstractExport createExport(String exportType) { AbstractExport export = null; switch (exportType) { case "SYNC": export = new SyncExport(); break; case "ASYNC": export = new AsyncExport(); break; } return export; } public static AbstractExport createExportFormClass(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException { AbstractExport export = (AbstractExport) Class.forName(className).newInstance(); return export; } } public class ExportTest { public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException { AbstractExport export = ExportFactory.createExport("SYNC"); export.export(); AbstractExport exportClass = ExportFactory.createExportFormClass(SyncExport.class.getName()); exportClass.export(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十四】Buffer]]></title>
    <url>%2F2019%2F03%2F06%2Fsource-code-java-34%2F</url>
    <content type="text"><![CDATA[Buffer抽象类定义了缓存池的基本操作，并实现了缓冲池的常用操作。 缓冲池的作用减少了必须等待一方写入完成后一方才能读取的问题。可以对缓存区进行边读边写，提高了同步处理的性能。 1、成员变量定义 mark：标记，用例临时保存position的数据，position操作完成后可重新设置成mark，后续方法会继续说明 position，当前操作到的位置 limit，缓冲区当前值的大小 capacity：缓冲区总的容量大小 // Invariants: mark &lt;= position &lt;= limit &lt;= capacity private int mark = -1; private int position = 0; private int limit; private int capacity; 2、address 只在direct buffer中有效，用于保存本地buffer的地址 // Used only by direct buffers // NOTE: hoisted here for speed in JNI GetDirectBufferAddress long address; 3、构造函数 先设置容量，再一步一步根据参数的大小限制进行验证，初始化limit、position、mark // Creates a new buffer with the given mark, position, limit, and capacity, // after checking invariants. // Buffer(int mark, int pos, int lim, int cap) { // package-private if (cap &lt; 0) throw new IllegalArgumentException("Negative capacity: " + cap); this.capacity = cap; limit(lim); position(pos); if (mark &gt;= 0) { if (mark &gt; pos) throw new IllegalArgumentException("mark &gt; position: (" + mark + " &gt; " + pos + ")"); this.mark = mark; } } 4、Buffer position(int newPosition)：设置缓冲区新的位置 校验不能高于当前缓冲区的大小，且如果标记大于当前的新位置，则取消旧标记。 /** * Sets this buffer's position. If the mark is defined and larger than the * new position then it is discarded. * * @param newPosition * The new position value; must be non-negative * and no larger than the current limit * * @return This buffer * * @throws IllegalArgumentException * If the preconditions on &lt;tt&gt;newPosition&lt;/tt&gt; do not hold */ public final Buffer position(int newPosition) { if ((newPosition &gt; limit) || (newPosition &lt; 0)) throw new IllegalArgumentException(); position = newPosition; if (mark &gt; position) mark = -1; return this; } 5、Buffer limit(int newLimit)：新上界的设置 如果大于缓冲区的容量，或者上界小于0，都设置失败。 如果当前的位置要大于新上界，则位置后退到新上界。 同样标记大于新上界也需要删除当前标记。 /** * Sets this buffer's limit. If the position is larger than the new limit * then it is set to the new limit. If the mark is defined and larger than * the new limit then it is discarded. * * @param newLimit * The new limit value; must be non-negative * and no larger than this buffer's capacity * * @return This buffer * * @throws IllegalArgumentException * If the preconditions on &lt;tt&gt;newLimit&lt;/tt&gt; do not hold */ public final Buffer limit(int newLimit) { if ((newLimit &gt; capacity) || (newLimit &lt; 0)) throw new IllegalArgumentException(); limit = newLimit; if (position &gt; limit) position = limit; if (mark &gt; limit) mark = -1; return this; } 6、mark：标记当前的位置，以便position使用过后可以回退 /** * Sets this buffer's mark at its position. * * @return This buffer */ public final Buffer mark() { mark = position; return this; } 7、reset还原标记，如果之前未标记过则抛出异常。 /** * Resets this buffer's position to the previously-marked position. * * &lt;p&gt; Invoking this method neither changes nor discards the mark's * value. &lt;/p&gt; * * @return This buffer * * @throws InvalidMarkException * If the mark has not been set */ public final Buffer reset() { int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this; } 8、clear 清空当前缓冲区的内容，缓冲区的容量还在。 /** * Clears this buffer. The position is set to zero, the limit is set to * the capacity, and the mark is discarded. * * &lt;p&gt; Invoke this method before using a sequence of channel-read or * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer. For example: * * &lt;blockquote&gt;&lt;pre&gt; * buf.clear(); // Prepare buffer for reading * in.read(buf); // Read data&lt;/pre&gt;&lt;/blockquote&gt; * * &lt;p&gt; This method does not actually erase the data in the buffer, but it * is named as if it did because it will most often be used in situations * in which that might as well be the case. &lt;/p&gt; * * @return This buffer */ public final Buffer clear() { position = 0; limit = capacity; mark = -1; return this; } 9、flip：保留已读取的缓冲区信息。位置从0开始，并删除标记。 /** * Flips this buffer. The limit is set to the current position and then * the position is set to zero. If the mark is defined then it is * discarded. * * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke * this method to prepare for a sequence of channel-write or relative * &lt;i&gt;get&lt;/i&gt; operations. For example: * * &lt;blockquote&gt;&lt;pre&gt; * buf.put(magic); // Prepend header * in.read(buf); // Read data into rest of buffer * buf.flip(); // Flip buffer * out.write(buf); // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt; * * &lt;p&gt; This method is often used in conjunction with the {@link * java.nio.ByteBuffer#compact compact} method when transferring data from * one place to another. &lt;/p&gt; * * @return This buffer */ public final Buffer flip() { limit = position; position = 0; mark = -1; return this; } 10、rewind：从头开始操作 /** * Rewinds this buffer. The position is set to zero and the mark is * discarded. * * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt; * operations, assuming that the limit has already been set * appropriately. For example: * * &lt;blockquote&gt;&lt;pre&gt; * out.write(buf); // Write remaining data * buf.rewind(); // Rewind buffer * buf.get(array); // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt; * * @return This buffer */ public final Buffer rewind() { position = 0; mark = -1; return this; } 11、remaining：还有多少位置到上界 hasRemaining：是否已达上界 /** * Returns the number of elements between the current position and the * limit. * * @return The number of elements remaining in this buffer */ public final int remaining() { return limit - position; } /** * Tells whether there are any elements between the current position and * the limit. * * @return &lt;tt&gt;true&lt;/tt&gt; if, and only if, there is at least one element * remaining in this buffer */ public final boolean hasRemaining() { return position &lt; limit; } 12、nextGetIndex：获取下一个位置 int nextGetIndex(int nb)：获取之后的nb个位置 /** * Checks the current position against the limit, throwing a {@link * BufferUnderflowException} if it is not smaller than the limit, and then * increments the position. * * @return The current position value, before it is incremented */ final int nextGetIndex() { // package-private if (position &gt;= limit) throw new BufferUnderflowException(); return position++; } final int nextGetIndex(int nb) { // package-private if (limit - position &lt; nb) throw new BufferUnderflowException(); int p = position; position += nb; return p; } 13、nextPutIndex：下一个写入位置 int nextPutIndex(int nb)：下一个写入的nb个位置 /** * Checks the current position against the limit, throwing a {@link * BufferOverflowException} if it is not smaller than the limit, and then * increments the position. * * @return The current position value, before it is incremented */ final int nextPutIndex() { // package-private if (position &gt;= limit) throw new BufferOverflowException(); return position++; } final int nextPutIndex(int nb) { // package-private if (limit - position &lt; nb) throw new BufferOverflowException(); int p = position; position += nb; return p; } 14、校验缓冲区的位置是否合法 /** * Checks the given index against the limit, throwing an {@link * IndexOutOfBoundsException} if it is not smaller than the limit * or is smaller than zero. */ final int checkIndex(int i) { // package-private if ((i &lt; 0) || (i &gt;= limit)) throw new IndexOutOfBoundsException(); return i; } final int checkIndex(int i, int nb) { // package-private if ((i &lt; 0) || (nb &gt; limit - i)) throw new IndexOutOfBoundsException(); return i; } 15、释放缓冲区 final void truncate() { // package-private mark = -1; position = 0; limit = 0; capacity = 0; } 16、discardMark：取消标记 final void discardMark() { // package-private mark = -1; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十三】Bits]]></title>
    <url>%2F2019%2F03%2F05%2Fsource-code-java-33%2F</url>
    <content type="text"><![CDATA[Bits是位操作的工具类，其中用到了一系列经典的位移操作。 1、字节反转，可参考具体的实现。 static short swap(short x) { return Short.reverseBytes(x); } static char swap(char x) { return Character.reverseBytes(x); } static int swap(int x) { return Integer.reverseBytes(x); } static long swap(long x) { return Long.reverseBytes(x); } // short反转：保留第二个字节然后右移八位（变成第一个字节）（逻辑或）第一个字节左移八位变成（第二个字节）达到两个字节交换的目的 public static short reverseBytes(short i) { return (short) (((i &amp; 0xFF00) &gt;&gt; 8) | (i &lt;&lt; 8)); } // int反转：四个字节，前两个字节右移三个字节和一个字节。后两个字节分别左移1个字节和三个字节，达到交换的目的。 public static int reverseBytes(int i) { return ((i &gt;&gt;&gt; 24) ) | ((i &gt;&gt; 8) &amp; 0xFF00) | ((i &lt;&lt; 8) &amp; 0xFF0000) | ((i &lt;&lt; 24)); } // long反转： // 原排序为 8 7 6 5 4 3 2 1 // i = (i &amp; 0x00ff00ff00ff00ffL) &lt;&lt; 8 | (i &gt;&gt;&gt; 8) &amp; 0x00ff00ff00ff00ffL; // 保存结果如下,数据并未丢失： // 7 0 5 0 3 0 1 0 // 0 8 0 6 0 4 0 2 // 即 7 8 5 6 3 4 1 2 // (i &lt;&lt; 48) 得到 1 2 0 0 0 0 // ((i &amp; 0xffff0000L) &lt;&lt; 16) 得到 0 0 3 4 0 0 0 0 // ((i &gt;&gt;&gt; 16) &amp; 0xffff0000L) 得到 0 0 0 0 5 6 0 0 // (i &gt;&gt;&gt; 48) 得到 0 0 0 0 0 0 7 8 // 反转后得到：1 2 3 4 5 6 7 8 // 结论：位移运算博大精深 public static long reverseBytes(long i) { i = (i &amp; 0x00ff00ff00ff00ffL) &lt;&lt; 8 | (i &gt;&gt;&gt; 8) &amp; 0x00ff00ff00ff00ffL; return (i &lt;&lt; 48) | ((i &amp; 0xffff0000L) &lt;&lt; 16) | ((i &gt;&gt;&gt; 16) &amp; 0xffff0000L) | (i &gt;&gt;&gt; 48); } 2、char/short/int/long的put/get操作，基本类似，此处以char为例。不同字节的算法又与swap一致。 3、makeChar：将两个字节拼接成一个char类型，Short也占位两个字节，所以与char操作一致。 实现方式：b1左移八位成为高位字节，b0为低位字节，两个值逻辑或之后成为两个字节，转化为char static private char makeChar(byte b1, byte b0) { return (char)((b1 &lt;&lt; 8) | (b0 &amp; 0xff)); } 4、getCharL/putCharL 操作ByteBuffer 这两个函数互相对应。get方法，ByteBuffer低位高位与char的低位高位对应，put方法，获取char的两个字节，也是低位与高位对应。 static char getCharL(ByteBuffer bb, int bi) { return makeChar(bb._get(bi + 1), bb._get(bi )); } static void putCharL(ByteBuffer bb, int bi, char x) { bb._put(bi , char0(x)); bb._put(bi + 1, char1(x)); } 5、getCharL/putCharL 操作寄存器便宜量 这两个函数互相对应。get方法，获取本地地址的低位高位与char的低位高位对应，put方法，获取char的两个字节，也是直接设置到本地地址的低位与高位。 static char getCharL(long a) { return makeChar(_get(a + 1), _get(a )); } static void putCharL(long a, char x) { _put(a , char0(x)); _put(a + 1, char1(x)); } 6、getCharB/putCharB低位与高位错位设置，其它逻辑与getCharL/putCharL 类似 static char getCharB(ByteBuffer bb, int bi) { return makeChar(bb._get(bi ), bb._get(bi + 1)); } static char getCharB(long a) { return makeChar(_get(a ), _get(a + 1)); } static void putCharB(ByteBuffer bb, int bi, char x) { bb._put(bi , char1(x)); bb._put(bi + 1, char0(x)); } static void putCharB(long a, char x) { _put(a , char1(x)); _put(a + 1, char0(x)); } 7、char与short是两个字节，所以错位只需第一个字节与第二个字节交换。int与long分别为4字节与8字节，相应的反转逻辑与swap中的操作一致 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十二】Lock]]></title>
    <url>%2F2019%2F03%2F04%2Fsource-code-java-32%2F</url>
    <content type="text"><![CDATA[1、public interface Lock Lock是个接口，提供了锁的相关操作方法抽象。属于行锁，不会锁住整个类，具有较好的性能。 与synchronized比较，不会因为一个方法对整个实例或者对象造成影响，具有较高的灵活性与性能。 2、lock 请求获取当前锁，如果获取不到则进行等待，知道获取该锁。 实现中可能由于错误原因，由于获取了锁，但是业务处理失败后未释放锁，导致了死锁。此种情况业务中需要详细的考量。 /** * Acquires the lock. * * &lt;p&gt;If the lock is not available then the current thread becomes * disabled for thread scheduling purposes and lies dormant until the * lock has been acquired. * * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt; * * &lt;p&gt;A {@code Lock} implementation may be able to detect erroneous use * of the lock, such as an invocation that would cause deadlock, and * may throw an (unchecked) exception in such circumstances. The * circumstances and the exception type must be documented by that * {@code Lock} implementation. */ void lock(); 3、请求锁，并优先响应中断。即：如果等待请求锁过程中，线程被中断了，锁便会获取中断，并抛出中断异常。 /** * Acquires the lock unless the current thread is * {@linkplain Thread#interrupt interrupted}. * * &lt;p&gt;Acquires the lock if it is available and returns immediately. * * &lt;p&gt;If the lock is not available then the current thread becomes * disabled for thread scheduling purposes and lies dormant until * one of two things happens: * * &lt;ul&gt; * &lt;li&gt;The lock is acquired by the current thread; or * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} the * current thread, and interruption of lock acquisition is supported. * &lt;/ul&gt; * * &lt;p&gt;If the current thread: * &lt;ul&gt; * &lt;li&gt;has its interrupted status set on entry to this method; or * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while acquiring the * lock, and interruption of lock acquisition is supported, * &lt;/ul&gt; * then {@link InterruptedException} is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt; * * &lt;p&gt;The ability to interrupt a lock acquisition in some * implementations may not be possible, and if possible may be an * expensive operation. The programmer should be aware that this * may be the case. An implementation should document when this is * the case. * * &lt;p&gt;An implementation can favor responding to an interrupt over * normal method return. * * &lt;p&gt;A {@code Lock} implementation may be able to detect * erroneous use of the lock, such as an invocation that would * cause deadlock, and may throw an (unchecked) exception in such * circumstances. The circumstances and the exception type must * be documented by that {@code Lock} implementation. * * @throws InterruptedException if the current thread is * interrupted while acquiring the lock (and interruption * of lock acquisition is supported) */ void lockInterruptibly() throws InterruptedException; 4、tryLock 非阻塞函数，尝试获取锁，如果获取成功返回true，获取失败返回false。 /** * Acquires the lock only if it is free at the time of invocation. * * &lt;p&gt;Acquires the lock if it is available and returns immediately * with the value {@code true}. * If the lock is not available then this method will return * immediately with the value {@code false}. * * &lt;p&gt;A typical usage idiom for this method would be: * &lt;pre&gt; {@code * Lock lock = ...; * if (lock.tryLock()) { * try { * // manipulate protected state * } finally { * lock.unlock(); * } * } else { * // perform alternative actions * }}&lt;/pre&gt; * * This usage ensures that the lock is unlocked if it was acquired, and * doesn't try to unlock if the lock was not acquired. * * @return {@code true} if the lock was acquired and * {@code false} otherwise */ boolean tryLock(); 5、boolean tryLock(long time, TimeUnit unit) throws InterruptedException 在给定的时间内获取锁，如果没有获取成功则停止阻塞，并返回false。期间如果线程中断了，则会抛出中断异常。 /** * Acquires the lock if it is free within the given waiting time and the * current thread has not been {@linkplain Thread#interrupt interrupted}. * * &lt;p&gt;If the lock is available this method returns immediately * with the value {@code true}. * If the lock is not available then * the current thread becomes disabled for thread scheduling * purposes and lies dormant until one of three things happens: * &lt;ul&gt; * &lt;li&gt;The lock is acquired by the current thread; or * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} the * current thread, and interruption of lock acquisition is supported; or * &lt;li&gt;The specified waiting time elapses * &lt;/ul&gt; * * &lt;p&gt;If the lock is acquired then the value {@code true} is returned. * * &lt;p&gt;If the current thread: * &lt;ul&gt; * &lt;li&gt;has its interrupted status set on entry to this method; or * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while acquiring * the lock, and interruption of lock acquisition is supported, * &lt;/ul&gt; * then {@link InterruptedException} is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;If the specified waiting time elapses then the value {@code false} * is returned. * If the time is * less than or equal to zero, the method will not wait at all. * * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt; * * &lt;p&gt;The ability to interrupt a lock acquisition in some implementations * may not be possible, and if possible may * be an expensive operation. * The programmer should be aware that this may be the case. An * implementation should document when this is the case. * * &lt;p&gt;An implementation can favor responding to an interrupt over normal * method return, or reporting a timeout. * * &lt;p&gt;A {@code Lock} implementation may be able to detect * erroneous use of the lock, such as an invocation that would cause * deadlock, and may throw an (unchecked) exception in such circumstances. * The circumstances and the exception type must be documented by that * {@code Lock} implementation. * * @param time the maximum time to wait for the lock * @param unit the time unit of the {@code time} argument * @return {@code true} if the lock was acquired and {@code false} * if the waiting time elapsed before the lock was acquired * * @throws InterruptedException if the current thread is interrupted * while acquiring the lock (and interruption of lock * acquisition is supported) */ boolean tryLock(long time, TimeUnit unit) throws InterruptedException; 6、unlock：释放锁 /** * Releases the lock. * * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt; * * &lt;p&gt;A {@code Lock} implementation will usually impose * restrictions on which thread can release a lock (typically only the * holder of the lock can release it) and may throw * an (unchecked) exception if the restriction is violated. * Any restrictions and the exception * type must be documented by that {@code Lock} implementation. */ void unlock(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十一】AtomicReference]]></title>
    <url>%2F2019%2F03%2F04%2Fsource-code-java-31%2F</url>
    <content type="text"><![CDATA[说明：AtomicReferenc：泛型原子操作，提供了原子操作的设置值操作，并没有自增自减等具有数值特性的方法，相对来说较为简单。仅提供了原子操作的通用方法。针对AtomicInteger为何不继承AtomicReference，因为底层针对特定的类型具有更高的性能。 1、声明与定义 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField("value")); } catch (Exception ex) { throw new Error(ex); } } private volatile V value; 2、构造方法 /** * Creates a new AtomicReference with the given initial value. * * @param initialValue the initial value */ public AtomicReference(V initialValue) { value = initialValue; } /** * Creates a new AtomicReference with null initial value. */ public AtomicReference() { } 3、get/set /** * Gets the current value. * * @return the current value */ public final V get() { return value; } /** * Sets to the given value. * * @param newValue the new value */ public final void set(V newValue) { value = newValue; } 4、CAS操作 /** * Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * @param expect the expected value * @param update the new value * @return {@code true} if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(V expect, V update) { return unsafe.compareAndSwapObject(this, valueOffset, expect, update); } /** * Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to {@code compareAndSet}. * * @param expect the expected value * @param update the new value * @return {@code true} if successful */ public final boolean weakCompareAndSet(V expect, V update) { return unsafe.compareAndSwapObject(this, valueOffset, expect, update); } 5、getAndSet /** * Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value */ @SuppressWarnings("unchecked") public final V getAndSet(V newValue) { return (V)unsafe.getAndSetObject(this, valueOffset, newValue); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三十】AtomicIntegerArray与AtomicLongArray]]></title>
    <url>%2F2019%2F03%2F04%2Fsource-code-java-30%2F</url>
    <content type="text"><![CDATA[说明：AtomicIntegerArray与AtomicLongArray的实现逻辑一致，Integer的shift为2，Long的shift为8，然后操作时各自调用相应的Integer/Long的原子操作。 1、成员变量定义 array：实际保存的数据 base：int[]开辟地址空间的起始地址。这个有点不明白的是，base为什么每个都一样，那是怎么区分不同对象保存的位置。 shift：该类型的字节位移数。比如int四个字节，则shift为2，即1&lt;&lt;2，也就是每个int起始位置都是4的倍数，与int占四个字节吻合。 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final int base = unsafe.arrayBaseOffset(int[].class); private static final int shift; private final int[] array; 2、初始化 构造函数一开始便指定了此对象的大小。 并初始化了原子数组的每个位需要移位的数量 static { int scale = unsafe.arrayIndexScale(int[].class); if ((scale &amp; (scale - 1)) != 0) throw new Error("data type scale not a power of two"); shift = 31 - Integer.numberOfLeadingZeros(scale); } /** * Creates a new AtomicIntegerArray of the given length, with all * elements initially zero. * * @param length the length of the array */ public AtomicIntegerArray(int length) { array = new int[length]; } /** * Creates a new AtomicIntegerArray with the same length as, and * all elements copied from, the given array. * * @param array the array to copy elements from * @throws NullPointerException if array is null */ public AtomicIntegerArray(int[] array) { // Visibility guaranteed by final field guarantees this.array = array.clone(); } 3、long checkedByteOffset(int i)：计算下标的偏移字节量 private long checkedByteOffset(int i) { if (i &lt; 0 || i &gt;= array.length) throw new IndexOutOfBoundsException("index " + i); return byteOffset(i); } private static long byteOffset(int i) { return ((long) i &lt;&lt; shift) + base; } 4、虽然array定义时并没有使用volatile，但是取值设置值时使用了与volatile相关的方法getIntVolatile/putIntVolatile，保证了取值过程在多线程间的可见性。取值也是使用数组内存中的偏移字节。 /** * Gets the current value at position {@code i}. * * @param i the index * @return the current value */ public final int get(int i) { return getRaw(checkedByteOffset(i)); } private int getRaw(long offset) { return unsafe.getIntVolatile(array, offset); } /** * Sets the element at position {@code i} to the given value. * * @param i the index * @param newValue the new value */ public final void set(int i, int newValue) { unsafe.putIntVolatile(array, checkedByteOffset(i), newValue); } 5、其余值的设置与AtomicInteger类似，不一样的是多了一步计算元素主存中偏移量的操作。如果数组长度为1实际便退化成类似AtomicInteger的操作了。 /** * Atomically sets the element at position {@code i} to the given * value and returns the old value. * * @param i the index * @param newValue the new value * @return the previous value */ public final int getAndSet(int i, int newValue) { return unsafe.getAndSetInt(array, checkedByteOffset(i), newValue); } /** * Atomically sets the element at position {@code i} to the given * updated value if the current value {@code ==} the expected value. * * @param i the index * @param expect the expected value * @param update the new value * @return {@code true} if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(int i, int expect, int update) { return compareAndSetRaw(checkedByteOffset(i), expect, update); } private boolean compareAndSetRaw(long offset, int expect, int update) { return unsafe.compareAndSwapInt(array, offset, expect, update); } /** * Atomically sets the element at position {@code i} to the given * updated value if the current value {@code ==} the expected value. * * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to {@code compareAndSet}. * * @param i the index * @param expect the expected value * @param update the new value * @return {@code true} if successful */ public final boolean weakCompareAndSet(int i, int expect, int update) { return compareAndSet(i, expect, update); } /** * Atomically increments by one the element at index {@code i}. * * @param i the index * @return the previous value */ public final int getAndIncrement(int i) { return getAndAdd(i, 1); } /** * Atomically decrements by one the element at index {@code i}. * * @param i the index * @return the previous value */ public final int getAndDecrement(int i) { return getAndAdd(i, -1); } /** * Atomically adds the given value to the element at index {@code i}. * * @param i the index * @param delta the value to add * @return the previous value */ public final int getAndAdd(int i, int delta) { return unsafe.getAndAddInt(array, checkedByteOffset(i), delta); } /** * Atomically increments by one the element at index {@code i}. * * @param i the index * @return the updated value */ public final int incrementAndGet(int i) { return getAndAdd(i, 1) + 1; } /** * Atomically decrements by one the element at index {@code i}. * * @param i the index * @return the updated value */ public final int decrementAndGet(int i) { return getAndAdd(i, -1) - 1; } /** * Atomically adds the given value to the element at index {@code i}. * * @param i the index * @param delta the value to add * @return the updated value */ public final int addAndGet(int i, int delta) { return getAndAdd(i, delta) + delta; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十九】AtomicLong]]></title>
    <url>%2F2019%2F03%2F04%2Fsource-code-java-29%2F</url>
    <content type="text"><![CDATA[1、VM_SUPPORTS_LONG_CAS：虚拟机是否支持CAS操作 /** * Records whether the underlying JVM supports lockless * compareAndSwap for longs. While the Unsafe.compareAndSwapLong * method works in either case, some constructions should be * handled at Java level to avoid locking user-visible locks. */ static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); /** * Returns whether underlying JVM supports lockless CompareAndSet * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS. */ private static native boolean VMSupportsCS8(); 2、变量定义 valueOffset对应value在内存中的地址 volatile 修饰value使value在多线程下可见。 private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicLong.class.getDeclaredField("value")); } catch (Exception ex) { throw new Error(ex); } } private volatile long value; 3、boolean compareAndSet(long expect, long update)：设置前比较前值是否一致，一致则设置，不一致则设置失败。设置成功返回true，设置失败返回false /** * Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * * @param expect the expected value * @param update the new value * @return {@code true} if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(long expect, long update) { return unsafe.compareAndSwapLong(this, valueOffset, expect, update); } /** * Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to {@code compareAndSet}. * * @param expect the expected value * @param update the new value * @return {@code true} if successful */ public final boolean weakCompareAndSet(long expect, long update) { return unsafe.compareAndSwapLong(this, valueOffset, expect, update); } 4、long getAndSet(long newValue)：设置新值，并获取设置新值前的值。如果设置新值不成功，则会一直执行直到成功并返回 /** * Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value */ public final long getAndSet(long newValue) { return unsafe.getAndSetLong(this, valueOffset, newValue); } 5、一系列的自增自减操作方法，原子性与int类似，因为操作的原子性，在设置时可保证多线程的安全性。 /** * Atomically increments by one the current value. * * @return the previous value */ public final long getAndIncrement() { return unsafe.getAndAddLong(this, valueOffset, 1L); } /** * Atomically decrements by one the current value. * * @return the previous value */ public final long getAndDecrement() { return unsafe.getAndAddLong(this, valueOffset, -1L); } /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the previous value */ public final long getAndAdd(long delta) { return unsafe.getAndAddLong(this, valueOffset, delta); } /** * Atomically increments by one the current value. * * @return the updated value */ public final long incrementAndGet() { return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L; } /** * Atomically decrements by one the current value. * * @return the updated value */ public final long decrementAndGet() { return unsafe.getAndAddLong(this, valueOffset, -1L) - 1L; } /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */ public final long addAndGet(long delta) { return unsafe.getAndAddLong(this, valueOffset, delta) + delta; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十八】AtomicInteger]]></title>
    <url>%2F2019%2F03%2F03%2Fsource-code-java-28%2F</url>
    <content type="text"><![CDATA[1、定于与构造 // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; /** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */ public AtomicInteger(int initialValue) { value = initialValue; } /** * Creates a new AtomicInteger with initial value {@code 0}. */ public AtomicInteger() { } 2、常用的线程安全增减操作 getAndIncrement：获取当前值，并自增1 getAndDecrement：获取当前值，并自减1 int getAndAdd(int delta)：获取当前值，并加上delta的值 incrementAndGet：自增1，并返回自增后的值 decrementAndGet：自减1，并返回自减后的值 int addAndGet(int delta)：加上delta值，并返回加之后的值。 实际都是实现了原子操作： public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } 当原子操作失败时，继续获取当前值进行操作，直到操作成功，保证操作的安全性。 /** * Atomically increments by one the current value. * * @return the previous value */ public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } /** * Atomically decrements by one the current value. * * @return the previous value */ public final int getAndDecrement() { return unsafe.getAndAddInt(this, valueOffset, -1); } /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the previous value */ public final int getAndAdd(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta); } /** * Atomically increments by one the current value. * * @return the updated value */ public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1; } /** * Atomically decrements by one the current value. * * @return the updated value */ public final int decrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, -1) - 1; } /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */ public final int addAndGet(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta) + delta; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十七】AtomicBoolean]]></title>
    <url>%2F2019%2F03%2F03%2Fsource-code-java-27%2F</url>
    <content type="text"><![CDATA[1、定义 valueOffet保存了value变量的内存偏移量的值 value是AtomicBoolean保存的实际数据。1：true；0：false。因为int默认值为0，所以AtomicBoolean默认值为false value使用了关键字volatile，保证线程间的数据都是最新的。具体的作用可参考： https://mp.csdn.net/postedit/88094147 // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicBoolean.class.getDeclaredField("value")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; 2、构造 初始化value的值，无参构造默认为0 /** * Creates a new {@code AtomicBoolean} with the given initial value. * * @param initialValue the initial value */ public AtomicBoolean(boolean initialValue) { value = initialValue ? 1 : 0; } /** * Creates a new {@code AtomicBoolean} with initial value {@code false}. */ public AtomicBoolean() { } 3、get()：非0则为true。因为对象中各个方法的值都是1与0，所以与value == 1等价 /** * Returns the current value. * * @return the current value */ public final boolean get() { return value != 0; } 4、使用CAS：boolean compareAndSet(boolean expect, boolean update) 底层调用了本地方法：public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 与原值进行比较，如果相等则进行更新，如果不相等则取消更新。更新成功返回true，更新失败返回false。 weakCompareAndSet与compareAndSet目前是一样的实现，想了解其中的细节差异可自行了解。 /** * Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * * @param expect the expected value * @param update the new value * @return {@code true} if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(boolean expect, boolean update) { int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u); } /** * Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to {@code compareAndSet}. * * @param expect the expected value * @param update the new value * @return {@code true} if successful */ public boolean weakCompareAndSet(boolean expect, boolean update) { int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u); } 举例一：保证一个方法的逻辑只执行一次 AtomicBoolean test = new AtomicBoolean() public void onlyOnt() { if ( test.compareAndSet(false, true) ) { } } 举例二：保证一个方法的同一时间只能执行一次 AtomicBoolean test = new AtomicBoolean() public void onlyOnt() { if ( test.compareAndSet(false, true) ) { test.compareAndSet(true, false); 或者 test.set(true); } } 5、set /** * Unconditionally sets to the given value. * * @param newValue the new value */ public final void set(boolean newValue) { value = newValue ? 1 : 0; } 6、lazySet：并非对其它线程立即可见。 /** * Eventually sets to the given value. * * @param newValue the new value * @since 1.6 */ public final void lazySet(boolean newValue) { int v = newValue ? 1 : 0; unsafe.putOrderedInt(this, valueOffset, v); } 7、boolean getAndSet(boolean newValue) 原子操作写入新值，直至成功写入，并返回写入前的值。 /** * Atomically sets to the given value and returns the previous value. * * @param newValue the new value * @return the previous value */ public final boolean getAndSet(boolean newValue) { boolean prev; do { prev = get(); } while (!compareAndSet(prev, newValue)); return prev; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十六】TreeSet]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-26%2F</url>
    <content type="text"><![CDATA[1、与HashSet类似，也是对TreeMap的封装，底层依然使用TreeMap 2、数据存储于默认value值 /** * The backing map. */ private transient NavigableMap&lt;E,Object&gt; m; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); 3、构造函数初始化，默认使用TreeMap /** * Constructs a set backed by the specified navigable map. */ TreeSet(NavigableMap&lt;E,Object&gt; m) { this.m = m; } /** * Constructs a new, empty tree set, sorted according to the * natural ordering of its elements. All elements inserted into * the set must implement the {@link Comparable} interface. * Furthermore, all such elements must be &lt;i&gt;mutually * comparable&lt;/i&gt;: {@code e1.compareTo(e2)} must not throw a * {@code ClassCastException} for any elements {@code e1} and * {@code e2} in the set. If the user attempts to add an element * to the set that violates this constraint (for example, the user * attempts to add a string element to a set whose elements are * integers), the {@code add} call will throw a * {@code ClassCastException}. */ public TreeSet() { this(new TreeMap&lt;E,Object&gt;()); } /** * Constructs a new, empty tree set, sorted according to the specified * comparator. All elements inserted into the set must be &lt;i&gt;mutually * comparable&lt;/i&gt; by the specified comparator: {@code comparator.compare(e1, * e2)} must not throw a {@code ClassCastException} for any elements * {@code e1} and {@code e2} in the set. If the user attempts to add * an element to the set that violates this constraint, the * {@code add} call will throw a {@code ClassCastException}. * * @param comparator the comparator that will be used to order this set. * If {@code null}, the {@linkplain Comparable natural * ordering} of the elements will be used. */ public TreeSet(Comparator&lt;? super E&gt; comparator) { this(new TreeMap&lt;&gt;(comparator)); } /** * Constructs a new tree set containing the elements in the specified * collection, sorted according to the &lt;i&gt;natural ordering&lt;/i&gt; of its * elements. All elements inserted into the set must implement the * {@link Comparable} interface. Furthermore, all such elements must be * &lt;i&gt;mutually comparable&lt;/i&gt;: {@code e1.compareTo(e2)} must not throw a * {@code ClassCastException} for any elements {@code e1} and * {@code e2} in the set. * * @param c collection whose elements will comprise the new set * @throws ClassCastException if the elements in {@code c} are * not {@link Comparable}, or are not mutually comparable * @throws NullPointerException if the specified collection is null */ public TreeSet(Collection&lt;? extends E&gt; c) { this(); addAll(c); } /** * Constructs a new tree set containing the same elements and * using the same ordering as the specified sorted set. * * @param s sorted set whose elements will comprise the new set * @throws NullPointerException if the specified sorted set is null */ public TreeSet(SortedSet&lt;E&gt; s) { this(s.comparator()); addAll(s); } 4、add、remove 添加时设置默认value值：PRESENT remove删除后比较值：PRESENT /** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element {@code e} to this set if * the set contains no element {@code e2} such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns {@code false}. * * @param e element to be added to this set * @return {@code true} if this set did not already contain the specified * element * @throws ClassCastException if the specified object cannot be compared * with the elements currently in this set * @throws NullPointerException if the specified element is null * and this set uses natural ordering, or its comparator * does not permit null elements */ public boolean add(E e) { return m.put(e, PRESENT)==null; } /** * Removes the specified element from this set if it is present. * More formally, removes an element {@code e} such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns {@code true} if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return {@code true} if this set contained the specified element * @throws ClassCastException if the specified object cannot be compared * with the elements currently in this set * @throws NullPointerException if the specified element is null * and this set uses natural ordering, or its comparator * does not permit null elements */ public boolean remove(Object o) { return m.remove(o)==PRESENT; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十五】TreeMap]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-25%2F</url>
    <content type="text"><![CDATA[1、内部类Entry定义树键值对的结构 键值对的特征：key-value tree的特征：left-right-parent color：红黑树的设定 ​ private static final boolean RED = false; private static final boolean BLACK = true; /** * Node in the Tree. Doubles as a means to pass key-value pairs back to * user (see Map.Entry). */ static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; /** * Make a new cell with given key, value, and parent, and with * {@code null} child links, and BLACK color. */ Entry(K key, V value, Entry&lt;K,V&gt; parent) { this.key = key; this.value = value; this.parent = parent; } /** * Returns the key. * * @return the key */ public K getKey() { return key; } /** * Returns the value associated with the key. * * @return the value associated with the key */ public V getValue() { return value; } /** * Replaces the value currently associated with the key with the given * value. * * @return the value associated with the key before this method was * called */ public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); } public int hashCode() { int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; } public String toString() { return key + "=" + value; } } ​ 2、get(Object key) 进行比较判断，左边的值永远比右边的值大，根据此方式一次往下搜索。key值不能为空 public V get(Object key) { Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value); } final Entry&lt;K,V&gt; getEntry(Object key) { // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; } return null; } 3、put(K key, V value)：红黑树的添加元素 a、判断是不是首个节点 b、比较每个节点key的值，一直向下比较，直到节点空为止，或者key存在，直接设置值返回。 c、得到空节点之后，创建当前空节点。 d、因为保存了空节点的上个节点，所以得到了父节点，将新节点按比较的值挂到父节点的左值（新&lt;父）/右值（新&gt;=旧） e、插入节点后，重构红黑树。重构方式可参考红黑树的构造逻辑。 /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key}. * (A {@code null} return can also indicate that the map * previously associated {@code null} with {@code key}.) * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null * and this map uses natural ordering, or its comparator * does not permit null keys */ public V put(K key, V value) { Entry&lt;K,V&gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null; } 4、remove(Object key)：删除节点 a、如果存在左节点且存在右节点，则将当前节点降级，规则为左节点的最右边节点或者右节点的最左边节点。 successor：找到节点 p.key = s.key; p.value = s.value; 将找到的节点设置到当前节点，这样就可以删除找到的节点。找到的节点肯定最多只有一个左节点或者一个右节点。 b、如果左节点不为空，则将左节点替换到当前的节点。如果右节点不为空，则右节点替换到当前的节点。如果两个都为空，则判断父节点是否为空，为空则说明当前节点为根节点。如果左右节点都为空，则设置上级节点的子节点为空。把当前节点的父节点设置为空。 c、节点删除之后重新整理红黑树。 public V remove(Object key) { Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue; } /** * Delete node p, and then rebalance the tree. */ private void deleteEntry(Entry&lt;K,V&gt; p) { modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) { Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; } // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) { // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); } else if (p.parent == null) { // return if we are the only node. root = null; } else { // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) { if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; } } } /** * Returns the successor of the specified Entry, or null if no such. */ static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) { if (t == null) return null; else if (t.right != null) { Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; } else { Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) { ch = p; p = p.parent; } return p; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十四】LinkedHashSet]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-24%2F</url>
    <content type="text"><![CDATA[LinkedHashSet具体来说是构造重载了HashSet。使用HashSet在构造方法中添加dummy参数也能实现LinkedHashSet的功能。 使用上LinkedHashSet方便了HashSet的构造，并且使得语义更容易理解。 /** * Constructs a new, empty linked hash set with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity of the linked hash set * @param loadFactor the load factor of the linked hash set * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */ public LinkedHashSet(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor, true); } /** * Constructs a new, empty linked hash set with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity of the LinkedHashSet * @throws IllegalArgumentException if the initial capacity is less * than zero */ public LinkedHashSet(int initialCapacity) { super(initialCapacity, .75f, true); } /** * Constructs a new, empty linked hash set with the default initial * capacity (16) and load factor (0.75). */ public LinkedHashSet() { super(16, .75f, true); } /** * Constructs a new linked hash set with the same elements as the * specified collection. The linked hash set is created with an initial * capacity sufficient to hold the elements in the specified collection * and the default load factor (0.75). * * @param c the collection whose elements are to be placed into * this set * @throws NullPointerException if the specified collection is null */ public LinkedHashSet(Collection&lt;? extends E&gt; c) { super(Math.max(2*c.size(), 11), .75f, true); addAll(c); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十三】LinkedHashMap]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-23%2F</url>
    <content type="text"><![CDATA[public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 1、继承了HashMap，对HashMap的一个补充，LinkedHashMap添加了元素是有序的存储，具体的实现下面会详细介绍 2、内部类Entry继承了HashMap的Node，添加了前一个元素和后一个元素，为顺序打好基础。 /** * HashMap.Node subclass for normal LinkedHashMap entries. */ static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); } } 3、插入、删除 创建新节点就会在当前链表中在最后添加元素：linkNodeLast Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) { LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p; } 每次HashMap删除节点都会进行如下操作，LinkedMap同时删除相应的元素。 void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b; } 总结：LinkedHashMap实际是通过增加了entry的存储，并添加before与after节点实现HashMap的有序化。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十二】HashSet]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-22%2F</url>
    <content type="text"><![CDATA[1、成员变量map：底层使用HashMap进行数据保存 对于HashMap中的value统一使用空对象：PRESENT 。因此HashSet存储数据实际是一个HashMap，并且HashMap中的每个值都是：PRESENT private transient HashMap&lt;E,Object&gt; map; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); 2、构造函数：对map进行了初始化。 /** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() { map = new HashMap&lt;&gt;(); } /** * Constructs a new set containing the elements in the specified * collection. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor * (0.75) and an initial capacity sufficient to contain the elements in * the specified collection. * * @param c the collection whose elements are to be placed into this set * @throws NullPointerException if the specified collection is null */ public HashSet(Collection&lt;? extends E&gt; c) { map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); } /** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */ public HashSet(int initialCapacity, float loadFactor) { map = new HashMap&lt;&gt;(initialCapacity, loadFactor); } /** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and default load factor (0.75). * * @param initialCapacity the initial capacity of the hash table * @throws IllegalArgumentException if the initial capacity is less * than zero */ public HashSet(int initialCapacity) { map = new HashMap&lt;&gt;(initialCapacity); } /** * Constructs a new, empty linked hash set. (This package private * constructor is only used by LinkedHashSet.) The backing * HashMap instance is a LinkedHashMap with the specified initial * capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @param dummy ignored (distinguishes this * constructor from other int, float constructor.) * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */ HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); } 3、查/增/删/清：实际都是对map操作的封装，并无实际的操作。 /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this set * contains an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this set is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element */ public boolean contains(Object o) { return map.containsKey(o); } /** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) { return map.put(e, PRESENT)==null; } /** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns &lt;tt&gt;true&lt;/tt&gt; if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element */ public boolean remove(Object o) { return map.remove(o)==PRESENT; } /** * Removes all of the elements from this set. * The set will be empty after this call returns. */ public void clear() { map.clear(); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十一】Hashtable]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-21%2F</url>
    <content type="text"><![CDATA[1、内部类Entry，用于保存Hash的值。与HashMap中的Node定义实现相同 /** * Hashtable bucket collision list entry */ private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Entry&lt;K,V&gt; next; protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } @SuppressWarnings("unchecked") protected Object clone() { return new Entry&lt;&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); } // Map.Entry Ops public K getKey() { return key; } public V getValue() { return value; } public V setValue(V value) { if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; } public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); } public int hashCode() { return hash ^ Objects.hashCode(value); } public String toString() { return key.toString()+"="+value.toString(); } } 2、成员变量 table：实际存储数据 count：实际容量size threshold：扩容的阈值 loadFactor：加载因子 /** * The hash table data. */ private transient Entry&lt;?,?&gt;[] table; /** * The total number of entries in the hash table. */ private transient int count; /** * The table is rehashed when its size exceeds this threshold. (The * value of this field is (int)(capacity * loadFactor).) * * @serial */ private int threshold; /** * The load factor for the hashtable. * * @serial */ private float loadFactor; 3、与HashMap类似的实现这里就不赘述了，主要说明不同的实现。 4、get(Object key)：关于int index = (hash &amp; 0x7FFFFFFF) % tab.length;散列的计算，此处虽然取了余%，实际上与位与&amp;操作的结果是一致的，而HashMap中的&amp;操作更高效，因此感觉Hashtable并没有多少维护。 /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key.equals(k))}, * then this method returns {@code v}; otherwise it returns * {@code null}. (There can be at most one such mapping.) * * @param key the key whose associated value is to be returned * @return the value to which the specified key is mapped, or * {@code null} if this map contains no mapping for the key * @throws NullPointerException if the specified key is null * @see #put(Object, Object) */ @SuppressWarnings("unchecked") public synchronized V get(Object key) { Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return (V)e.value; } } return null; } 5、rehash与HashMap的resize类似，先计算分配空间，再对数据重新散列，因此同样比较消耗资源。 protected void rehash() { int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; // overflow-conscious code int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; } Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) { Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; } } } 6、put(K key, V value)：put方法相对简单，结构只有hash到具体位置，然后在具体位置中保存链表。 private void addEntry(int hash, K key, V value, int index) { modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry. @SuppressWarnings("unchecked") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; } /** * Maps the specified &lt;code&gt;key&lt;/code&gt; to the specified * &lt;code&gt;value&lt;/code&gt; in this hashtable. Neither the key nor the * value can be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt; * * The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method * with a key that is equal to the original key. * * @param key the hashtable key * @param value the value * @return the previous value of the specified key in this hashtable, * or &lt;code&gt;null&lt;/code&gt; if it did not have one * @exception NullPointerException if the key or value is * &lt;code&gt;null&lt;/code&gt; * @see Object#equals(Object) * @see #get(Object) */ public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings("unchecked") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } addEntry(hash, key, value, index); return null; } 7、remove(Object key)：散列到相应的桶，然后再对桶中链表进行操作。 /** * Removes the key (and its corresponding value) from this * hashtable. This method does nothing if the key is not in the hashtable. * * @param key the key that needs to be removed * @return the value to which the key had been mapped in this hashtable, * or &lt;code&gt;null&lt;/code&gt; if the key did not have a mapping * @throws NullPointerException if the key is &lt;code&gt;null&lt;/code&gt; */ public synchronized V remove(Object key) { Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings("unchecked") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index]; for(Entry&lt;K,V&gt; prev = null ; e != null ; prev = e, e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { modCount++; if (prev != null) { prev.next = e.next; } else { tab[index] = e.next; } count--; V oldValue = e.value; e.value = null; return oldValue; } } return null; } 总结：Hashtable的实现相对于HashMap来说简化了，没有了链表转树的操作。之所以被称作线程安全是因为每个方法前都加了关键字：synchronized document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二十】HashMap]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-20%2F</url>
    <content type="text"><![CDATA[说明：HashMap底层的时间存储依然是对象（节点）数组，实现涉及链表、红黑树等数据结构 1、常量定义 DEFAULT_INITIAL_CAPACITY：默认初始化容量，必须是2的倍数，因此使用位移操作，肯定是2的倍数。初始化值为16 MAXIMUM_CAPACITY：最大容量 2^30次方： DEFAULT_LOAD_FACTOR：默认加载因子，在判断是否扩容时，加载因子越小，可能扩容导致的空间浪费就越大。后续应用到的部分再详细讲解。是对于loadFactor成员变量的默认赋值 HashMap的table与tree转换的相关参数，tree采用的是红黑树： TREEIFY_THRESHOLD：表中桶的值个数大于此值时，进行树形化。 UNTREEIFY_THRESHOLD:表中桶的tree值个数大于此值时，还原为链表。 MIN_TREEIFY_CAPACITY：当整个表的值格式达到大于此值时，将整个表树形化。 /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; 2、内部类Node：存储数据Entry的实现 添加了hash、next值成员变量，高效查询值。 并对hashCode进行了重写。 /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + "=" + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } } 3、tableSizeFor：通过位移巧妙的返回大于参数值的最小2^n的值 /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 4、成员变量 table 底层保存的实际数据 entrySet 通过此键值对集合对此对象进行实际遍历操作 threshold 扩容的阈值 loadFactor 默认加载因子，与扩容相关，可影响到相关性能 /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node&lt;K,V&gt;[] table; /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * The number of key-value mappings contained in this map. */ transient int size; /** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). */ transient int modCount; /** * The next size value at which to resize (capacity * load factor). * * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; /** * The load factor for the hash table. * * @serial */ final float loadFactor; 5、三个构造函数，实际都是对扩容阈值、加载因子的配置 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 6、键值对参数的构造函数 预分配容量的一次性计算与分配，避免一次初始化多次分配的情况。分配完成后再插入相应的key-value /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } /** * Implements Map.putAll and Map constructor * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */ final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { if (table == null) { // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); } else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } =======以下是关键的具体实现============================= 7、get/put方法，HashMap中实际操作的核心算法。 get方法：对于获取hash值的第一个key的下标：(n - 1) &amp; hash；一开始我也很疑惑，因为n在扩容时(n=tab.length)会改变。 因此继续探究put放入值时的下标计算，涉及到两个位置： n = (tab = resize()).length; if (++size &gt; threshold) resize(); 而玄机就在resize方法中，resize方法不仅进行了扩容校验与扩容，并且在扩容后将原有的值按新的数组大小进行散列，因此resize方法比较消耗性能。其他在下面resize方法讲解时进行详细介绍， get涉及到了TreeNode（LinkedHashMap）的判断，这里因为值已经有了，因此逻辑处理比较简单，重要的在put方法中。 put方法： a、如果散列hash是第一个值则直接设置 b、如果第一个key一致，则将值直接设置第一个key的位置 c、如果当前第一个元素是TreeNode，则直接往后添加一个元素 d、遍历TreeNode到下一个值，如果当前桶的TreeNode大小大于TREEIFY_THRESHOLD - 1也就是达到8，则转化成红黑树treeifyBin，红黑树的实现后续再详细介绍。 /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}. (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 8、resize：容量大小重新配置，主要做了以下两步操作 a、大小重新分配，创建新的数组并指向新的数组 b、将旧数组中的值重新散列到新数组中，保证hash值的计算在容量大小重新分配后依然有效。 /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({"rawtypes","unchecked"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 9、remove(Object key)： a、与put、get一样，计算hash的index。 b、判断是不是TreeNode，如果是则按TreeNode进行删除值。 c、判断删除的是不是第一个值，如果是则将后续的值设置成当前第一个 d、是散列中后续的某个值，则将前一个值的next指向下一个值（当前值失去引用为删除） e、减少size /** * Removes the mapping for the specified key from this map if present. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } /** * Implements Map.remove and related methods * * @param hash hash for key * @param key the key * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */ final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } 10、clear：size=0，并清空值 /** * Removes all of the mappings from this map. * The map will be empty after this call returns. */ public void clear() { Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) { size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; } } 11、containsValue：判断是否含有某个值，直接遍历表格，并遍历每个hash值中存储的节点。 /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value */ public boolean containsValue(Object value) { Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) { for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; } } } return false; } 12、内部类创建了KeySet、Values、EntrySet。实际依然是通过内部类开放的接口对本HashMap的底层数据进行处理。 /** * Returns a {@link Set} view of the keys contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of * the iteration are undefined. The set supports element removal, * which removes the corresponding mapping from the map, via the * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; * operations. * * @return a set view of the keys contained in this map */ public Set&lt;K&gt; keySet() { Set&lt;K&gt; ks; return (ks = keySet) == null ? (keySet = new KeySet()) : ks; } final class KeySet extends AbstractSet&lt;K&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;K&gt; iterator() { return new KeyIterator(); } public final boolean contains(Object o) { return containsKey(o); } public final boolean remove(Object key) { return removeNode(hash(key), key, null, false, true) != null; } public final Spliterator&lt;K&gt; spliterator() { return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super K&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); } if (modCount != mc) throw new ConcurrentModificationException(); } } } /** * Returns a {@link Collection} view of the values contained in this map. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. If the map is * modified while an iteration over the collection is in progress * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), * the results of the iteration are undefined. The collection * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a view of the values contained in this map */ public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs; return (vs = values) == null ? (values = new Values()) : vs; } final class Values extends AbstractCollection&lt;V&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;V&gt; iterator() { return new ValueIterator(); } public final boolean contains(Object o) { return containsValue(o); } public final Spliterator&lt;V&gt; spliterator() { return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super V&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); } if (modCount != mc) throw new ConcurrentModificationException(); } } } /** * Returns a {@link Set} view of the mappings contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the * iterator) the results of the iteration are undefined. The set * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and * &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a set view of the mappings contained in this map */ public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; } final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(); } public final boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); } public final boolean remove(Object o) { if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; } return false; } public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() { return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) { Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) { int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) { for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); } if (modCount != mc) throw new ConcurrentModificationException(); } } } 13、TreeNode 内部类实现LinkedHashMap，方便对HashMap中实际的存储数据进行操作。 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十九】AbstractSet]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-19%2F</url>
    <content type="text"><![CDATA[1、AbstractSet比较简单，无序集合的抽象，继承了AbstractCollection 2、equals判断两个集合值是否全部包含，最后判断集合的大小，都一致说明两个集合内容一致。 public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Set)) return false; Collection&lt;?&gt; c = (Collection&lt;?&gt;) o; if (c.size() != size()) return false; try { return containsAll(c); } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } } 3、hashCode：集合所有的hashCode值相加，两个集合的hashCode值一致的情况就非常多了。 public int hashCode() { int h = 0; Iterator&lt;E&gt; i = iterator(); while (i.hasNext()) { E obj = i.next(); if (obj != null) h += obj.hashCode(); } return h; } 4、removeAll：遍历集合，存在一致的则一个一个删除。 public boolean removeAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); boolean modified = false; if (size() &gt; c.size()) { for (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); ) modified |= remove(i.next()); } else { for (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) { if (c.contains(i.next())) { i.remove(); modified = true; } } } return modified; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十八】AbstractMap]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-18%2F</url>
    <content type="text"><![CDATA[1、AbstractMap抽象类，实现Map接口，提供了下属Map实现的通用模板，给定了Map实现的框架。后续定义的Map可以很快实现。 2、AbstractMap的基础数据操作是基于entrySet的操作。因为实际的数据保存于Node&lt;K,V&gt;[] table;并实际通过entrySet封装的对象进行实际的数据管理。 但是也没有具体实现，需要根据实现类来继承。 public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet(); 3、size：entrySet的大小 isEmpty:entrySet的大小是否为0 /** * {@inheritDoc} * * @implSpec * This implementation returns &lt;tt&gt;entrySet().size()&lt;/tt&gt;. */ public int size() { return entrySet().size(); } /** * {@inheritDoc} * * @implSpec * This implementation returns &lt;tt&gt;size() == 0&lt;/tt&gt;. */ public boolean isEmpty() { return size() == 0; } 4、containsValue：遍历entrySet，判断其中的value值是否存在 containsKey：遍历entrySet，判断其中的key值是否存在 /** * {@inheritDoc} * * @implSpec * This implementation iterates over &lt;tt&gt;entrySet()&lt;/tt&gt; searching * for an entry with the specified value. If such an entry is found, * &lt;tt&gt;true&lt;/tt&gt; is returned. If the iteration terminates without * finding such an entry, &lt;tt&gt;false&lt;/tt&gt; is returned. Note that this * implementation requires linear time in the size of the map. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public boolean containsValue(Object value) { Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (value==null) { while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); if (e.getValue()==null) return true; } } else { while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); if (value.equals(e.getValue())) return true; } } return false; } /** * {@inheritDoc} * * @implSpec * This implementation iterates over &lt;tt&gt;entrySet()&lt;/tt&gt; searching * for an entry with the specified key. If such an entry is found, * &lt;tt&gt;true&lt;/tt&gt; is returned. If the iteration terminates without * finding such an entry, &lt;tt&gt;false&lt;/tt&gt; is returned. Note that this * implementation requires linear time in the size of the map; many * implementations will override this method. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public boolean containsKey(Object key) { Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (key==null) { while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) return true; } } else { while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) return true; } } return false; } 5、get(Object key)：获取某个键的值，一样需要遍历entrySet /** * {@inheritDoc} * * @implSpec * This implementation iterates over &lt;tt&gt;entrySet()&lt;/tt&gt; searching * for an entry with the specified key. If such an entry is found, * the entry's value is returned. If the iteration terminates without * finding such an entry, &lt;tt&gt;null&lt;/tt&gt; is returned. Note that this * implementation requires linear time in the size of the map; many * implementations will override this method. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public V get(Object key) { Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (key==null) { while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) return e.getValue(); } } else { while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) return e.getValue(); } } return null; } 6、put(K key, V value)：抽象类不提供具体的实现，但是子类如果为不可变key-value键值对，则无需对此方法进行重载，方便map的继承。 /** * {@inheritDoc} * * @implSpec * This implementation always throws an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;. * * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public V put(K key, V value) { throw new UnsupportedOperationException(); } 7、remove(Object key) ：遍历直到查到对应的key-value，然后删除，并返回此key对应的value public V remove(Object key) { Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); Entry&lt;K,V&gt; correctEntry = null; if (key==null) { while (correctEntry==null &amp;&amp; i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) correctEntry = e; } } else { while (correctEntry==null &amp;&amp; i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) correctEntry = e; } } V oldValue = null; if (correctEntry !=null) { oldValue = correctEntry.getValue(); i.remove(); } return oldValue; } 8、putAll(Map&lt;? extends K, ? extends V&gt; m)：遍历key-value，并一个一个设置值进去。 /** * {@inheritDoc} * * @implSpec * This implementation iterates over the specified map's * &lt;tt&gt;entrySet()&lt;/tt&gt; collection, and calls this map's &lt;tt&gt;put&lt;/tt&gt; * operation once for each entry returned by the iteration. * * &lt;p&gt;Note that this implementation throws an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if this map does not support * the &lt;tt&gt;put&lt;/tt&gt; operation and the specified map is nonempty. * * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public void putAll(Map&lt;? extends K, ? extends V&gt; m) { for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); } 9、clear：相应的实现会在具体的子类中体现，实际也是操作table节点数组 /** * {@inheritDoc} * * @implSpec * This implementation calls &lt;tt&gt;entrySet().clear()&lt;/tt&gt;. * * &lt;p&gt;Note that this implementation throws an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the &lt;tt&gt;entrySet&lt;/tt&gt; * does not support the &lt;tt&gt;clear&lt;/tt&gt; operation. * * @throws UnsupportedOperationException {@inheritDoc} */ public void clear() { entrySet().clear(); } 10、定义成员变量：keySet/values，避免每次获取key/values集合时重复创建对象。已经创建了则无需继续创建。 /** * Each of these fields are initialized to contain an instance of the * appropriate view the first time this view is requested. The views are * stateless, so there's no reason to create more than one of each. */ transient volatile Set&lt;K&gt; keySet; transient volatile Collection&lt;V&gt; values; 11、提供keySet()/values()实现，不同的子类有不同的重载，此处提供实现的一个模板。 当keySet/values未初始化时，新创建一个集合，实际包了一层壳，实际调用的方法还是本AbstractMap。 在此有个疑问，在构造函数中为何不直接队keySet/values进行初始化，这样使用keySet()/values()时就无需进行判断了。 /** * {@inheritDoc} * * @implSpec * This implementation returns a set that subclasses {@link AbstractSet}. * The subclass's iterator method returns a "wrapper object" over this * map's &lt;tt&gt;entrySet()&lt;/tt&gt; iterator. The &lt;tt&gt;size&lt;/tt&gt; method * delegates to this map's &lt;tt&gt;size&lt;/tt&gt; method and the * &lt;tt&gt;contains&lt;/tt&gt; method delegates to this map's * &lt;tt&gt;containsKey&lt;/tt&gt; method. * * &lt;p&gt;The set is created the first time this method is called, * and returned in response to all subsequent calls. No synchronization * is performed, so there is a slight chance that multiple calls to this * method will not all return the same set. */ public Set&lt;K&gt; keySet() { if (keySet == null) { keySet = new AbstractSet&lt;K&gt;() { public Iterator&lt;K&gt; iterator() { return new Iterator&lt;K&gt;() { private Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); public boolean hasNext() { return i.hasNext(); } public K next() { return i.next().getKey(); } public void remove() { i.remove(); } }; } public int size() { return AbstractMap.this.size(); } public boolean isEmpty() { return AbstractMap.this.isEmpty(); } public void clear() { AbstractMap.this.clear(); } public boolean contains(Object k) { return AbstractMap.this.containsKey(k); } }; } return keySet; } /** * {@inheritDoc} * * @implSpec * This implementation returns a collection that subclasses {@link * AbstractCollection}. The subclass's iterator method returns a * "wrapper object" over this map's &lt;tt&gt;entrySet()&lt;/tt&gt; iterator. * The &lt;tt&gt;size&lt;/tt&gt; method delegates to this map's &lt;tt&gt;size&lt;/tt&gt; * method and the &lt;tt&gt;contains&lt;/tt&gt; method delegates to this map's * &lt;tt&gt;containsValue&lt;/tt&gt; method. * * &lt;p&gt;The collection is created the first time this method is called, and * returned in response to all subsequent calls. No synchronization is * performed, so there is a slight chance that multiple calls to this * method will not all return the same collection. */ public Collection&lt;V&gt; values() { if (values == null) { values = new AbstractCollection&lt;V&gt;() { public Iterator&lt;V&gt; iterator() { return new Iterator&lt;V&gt;() { private Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); public boolean hasNext() { return i.hasNext(); } public V next() { return i.next().getValue(); } public void remove() { i.remove(); } }; } public int size() { return AbstractMap.this.size(); } public boolean isEmpty() { return AbstractMap.this.isEmpty(); } public void clear() { AbstractMap.this.clear(); } public boolean contains(Object v) { return AbstractMap.this.containsValue(v); } }; } return values; } 12、equals：遍历保证每个key-value都一致。 public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; if (m.size() != size()) return false; try { Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } 13、hashCode：遍历直接加上所有Entry的hashCode /** * Returns the hash code value for this map. The hash code of a map is * defined to be the sum of the hash codes of each entry in the map's * &lt;tt&gt;entrySet()&lt;/tt&gt; view. This ensures that &lt;tt&gt;m1.equals(m2)&lt;/tt&gt; * implies that &lt;tt&gt;m1.hashCode()==m2.hashCode()&lt;/tt&gt; for any two maps * &lt;tt&gt;m1&lt;/tt&gt; and &lt;tt&gt;m2&lt;/tt&gt;, as required by the general contract of * {@link Object#hashCode}. * * @implSpec * This implementation iterates over &lt;tt&gt;entrySet()&lt;/tt&gt;, calling * {@link Map.Entry#hashCode hashCode()} on each element (entry) in the * set, and adding up the results. * * @return the hash code value for this map * @see Map.Entry#hashCode() * @see Object#equals(Object) * @see Set#equals(Object) */ public int hashCode() { int h = 0; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) h += i.next().hashCode(); return h; } 14、SimpleEntry与SimpleImmutableEntry SimpleEntry主要提供了key/value的get/set方法，并添加了Entry的构造函数 SimpleImmutableEntry基本与SimpleEntry一致，但是未实现set方法，不能对此key-value进行修改。为不可修改的entry。 AbstractMap提供这两个类对Entry的实现，基本满足了常用子类可能需要的实现，子类在无特殊情况下无需实现Map的接口，达到封装的目的。 /** * An Entry maintaining a key and a value. The value may be * changed using the &lt;tt&gt;setValue&lt;/tt&gt; method. This class * facilitates the process of building custom map * implementations. For example, it may be convenient to return * arrays of &lt;tt&gt;SimpleEntry&lt;/tt&gt; instances in method * &lt;tt&gt;Map.entrySet().toArray&lt;/tt&gt;. * * @since 1.6 */ public static class SimpleEntry&lt;K,V&gt; implements Entry&lt;K,V&gt;, java.io.Serializable { private static final long serialVersionUID = -8499721149061103585L; private final K key; private V value; /** * Creates an entry representing a mapping from the specified * key to the specified value. * * @param key the key represented by this entry * @param value the value represented by this entry */ public SimpleEntry(K key, V value) { this.key = key; this.value = value; } /** * Creates an entry representing the same mapping as the * specified entry. * * @param entry the entry to copy */ public SimpleEntry(Entry&lt;? extends K, ? extends V&gt; entry) { this.key = entry.getKey(); this.value = entry.getValue(); } /** * Returns the key corresponding to this entry. * * @return the key corresponding to this entry */ public K getKey() { return key; } /** * Returns the value corresponding to this entry. * * @return the value corresponding to this entry */ public V getValue() { return value; } /** * Replaces the value corresponding to this entry with the specified * value. * * @param value new value to be stored in this entry * @return the old value corresponding to the entry */ public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } /** * Compares the specified object with this entry for equality. * Returns {@code true} if the given object is also a map entry and * the two entries represent the same mapping. More formally, two * entries {@code e1} and {@code e2} represent the same mapping * if&lt;pre&gt; * (e1.getKey()==null ? * e2.getKey()==null : * e1.getKey().equals(e2.getKey())) * &amp;amp;&amp;amp; * (e1.getValue()==null ? * e2.getValue()==null : * e1.getValue().equals(e2.getValue()))&lt;/pre&gt; * This ensures that the {@code equals} method works properly across * different implementations of the {@code Map.Entry} interface. * * @param o object to be compared for equality with this map entry * @return {@code true} if the specified object is equal to this map * entry * @see #hashCode */ public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue()); } /** * Returns the hash code value for this map entry. The hash code * of a map entry {@code e} is defined to be: &lt;pre&gt; * (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ * (e.getValue()==null ? 0 : e.getValue().hashCode())&lt;/pre&gt; * This ensures that {@code e1.equals(e2)} implies that * {@code e1.hashCode()==e2.hashCode()} for any two Entries * {@code e1} and {@code e2}, as required by the general * contract of {@link Object#hashCode}. * * @return the hash code value for this map entry * @see #equals */ public int hashCode() { return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } /** * Returns a String representation of this map entry. This * implementation returns the string representation of this * entry's key followed by the equals character ("&lt;tt&gt;=&lt;/tt&gt;") * followed by the string representation of this entry's value. * * @return a String representation of this map entry */ public String toString() { return key + "=" + value; } } /** * An Entry maintaining an immutable key and value. This class * does not support method &lt;tt&gt;setValue&lt;/tt&gt;. This class may be * convenient in methods that return thread-safe snapshots of * key-value mappings. * * @since 1.6 */ public static class SimpleImmutableEntry&lt;K,V&gt; implements Entry&lt;K,V&gt;, java.io.Serializable { private static final long serialVersionUID = 7138329143949025153L; private final K key; private final V value; /** * Creates an entry representing a mapping from the specified * key to the specified value. * * @param key the key represented by this entry * @param value the value represented by this entry */ public SimpleImmutableEntry(K key, V value) { this.key = key; this.value = value; } /** * Creates an entry representing the same mapping as the * specified entry. * * @param entry the entry to copy */ public SimpleImmutableEntry(Entry&lt;? extends K, ? extends V&gt; entry) { this.key = entry.getKey(); this.value = entry.getValue(); } /** * Returns the key corresponding to this entry. * * @return the key corresponding to this entry */ public K getKey() { return key; } /** * Returns the value corresponding to this entry. * * @return the value corresponding to this entry */ public V getValue() { return value; } /** * Replaces the value corresponding to this entry with the specified * value (optional operation). This implementation simply throws * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;, as this class implements * an &lt;i&gt;immutable&lt;/i&gt; map entry. * * @param value new value to be stored in this entry * @return (Does not return) * @throws UnsupportedOperationException always */ public V setValue(V value) { throw new UnsupportedOperationException(); } /** * Compares the specified object with this entry for equality. * Returns {@code true} if the given object is also a map entry and * the two entries represent the same mapping. More formally, two * entries {@code e1} and {@code e2} represent the same mapping * if&lt;pre&gt; * (e1.getKey()==null ? * e2.getKey()==null : * e1.getKey().equals(e2.getKey())) * &amp;amp;&amp;amp; * (e1.getValue()==null ? * e2.getValue()==null : * e1.getValue().equals(e2.getValue()))&lt;/pre&gt; * This ensures that the {@code equals} method works properly across * different implementations of the {@code Map.Entry} interface. * * @param o object to be compared for equality with this map entry * @return {@code true} if the specified object is equal to this map * entry * @see #hashCode */ public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue()); } /** * Returns the hash code value for this map entry. The hash code * of a map entry {@code e} is defined to be: &lt;pre&gt; * (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ * (e.getValue()==null ? 0 : e.getValue().hashCode())&lt;/pre&gt; * This ensures that {@code e1.equals(e2)} implies that * {@code e1.hashCode()==e2.hashCode()} for any two Entries * {@code e1} and {@code e2}, as required by the general * contract of {@link Object#hashCode}. * * @return the hash code value for this map entry * @see #equals */ public int hashCode() { return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } /** * Returns a String representation of this map entry. This * implementation returns the string representation of this * entry's key followed by the equals character ("&lt;tt&gt;=&lt;/tt&gt;") * followed by the string representation of this entry's value. * * @return a String representation of this map entry */ public String toString() { return key + "=" + value; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十七】Map接口]]></title>
    <url>%2F2019%2F03%2F02%2Fsource-code-java-17%2F</url>
    <content type="text"><![CDATA[1、map接口定义了键值对操作的基本常用方法。 2、size：key-value的数量 /** * Returns the number of key-value mappings in this map. If the * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;. * * @return the number of key-value mappings in this map */ int size(); 3、isEmpty：key是否为空 /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings. * * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings */ boolean isEmpty(); 3、containsKey：是否包含某个key containsValue：是否包含某个Value /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key. More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if * this map contains a mapping for a key &lt;tt&gt;k&lt;/tt&gt; such that * &lt;tt&gt;(key==null ? k==null : key.equals(k))&lt;/tt&gt;. (There can be * at most one such mapping.) * * @param key key whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key * @throws ClassCastException if the key is of an inappropriate type for * this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key is null and this map * does not permit null keys * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) */ boolean containsKey(Object key); /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if * this map contains at least one mapping to a value &lt;tt&gt;v&lt;/tt&gt; such that * &lt;tt&gt;(value==null ? v==null : value.equals(v))&lt;/tt&gt;. This operation * will probably require time linear in the map size for most * implementations of the &lt;tt&gt;Map&lt;/tt&gt; interface. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value * @throws ClassCastException if the value is of an inappropriate type for * this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified value is null and this * map does not permit null values * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) */ boolean containsValue(Object value); 4、get：获取值 put：设置值 remove：删除key putAll：添加某个键值对的所有值 clear：清空键值对的所有值 /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}. (There can be at most one such mapping.) * * &lt;p&gt;If this map permits null values, then a return value of * {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; indicate that the map * contains no mapping for the key; it's also possible that the map * explicitly maps the key to {@code null}. The {@link #containsKey * containsKey} operation may be used to distinguish these two cases. * * @param key the key whose associated value is to be returned * @return the value to which the specified key is mapped, or * {@code null} if this map contains no mapping for the key * @throws ClassCastException if the key is of an inappropriate type for * this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key is null and this map * does not permit null keys * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) */ V get(Object key); // Modification Operations /** * Associates the specified value with the specified key in this map * (optional operation). If the map previously contained a mapping for * the key, the old value is replaced by the specified value. (A map * &lt;tt&gt;m&lt;/tt&gt; is said to contain a mapping for a key &lt;tt&gt;k&lt;/tt&gt; if and only * if {@link #containsKey(Object) m.containsKey(k)} would return * &lt;tt&gt;true&lt;/tt&gt;.) * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;, * if the implementation supports &lt;tt&gt;null&lt;/tt&gt; values.) * @throws UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the class of the specified key or value * prevents it from being stored in this map * @throws NullPointerException if the specified key or value is null * and this map does not permit null keys or values * @throws IllegalArgumentException if some property of the specified key * or value prevents it from being stored in this map */ V put(K key, V value); /** * Removes the mapping for a key from this map if it is present * (optional operation). More formally, if this map contains a mapping * from key &lt;tt&gt;k&lt;/tt&gt; to value &lt;tt&gt;v&lt;/tt&gt; such that * &lt;code&gt;(key==null ? k==null : key.equals(k))&lt;/code&gt;, that mapping * is removed. (The map can contain at most one such mapping.) * * &lt;p&gt;Returns the value to which this map previously associated the key, * or &lt;tt&gt;null&lt;/tt&gt; if the map contained no mapping for the key. * * &lt;p&gt;If this map permits null values, then a return value of * &lt;tt&gt;null&lt;/tt&gt; does not &lt;i&gt;necessarily&lt;/i&gt; indicate that the map * contained no mapping for the key; it's also possible that the map * explicitly mapped the key to &lt;tt&gt;null&lt;/tt&gt;. * * &lt;p&gt;The map will not contain a mapping for the specified key once the * call returns. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * @throws UnsupportedOperationException if the &lt;tt&gt;remove&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the key is of an inappropriate type for * this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key is null and this * map does not permit null keys * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) */ V remove(Object key); // Bulk Operations /** * Copies all of the mappings from the specified map to this map * (optional operation). The effect of this call is equivalent to that * of calling {@link #put(Object,Object) put(k, v)} on this map once * for each mapping from key &lt;tt&gt;k&lt;/tt&gt; to value &lt;tt&gt;v&lt;/tt&gt; in the * specified map. The behavior of this operation is undefined if the * specified map is modified while the operation is in progress. * * @param m mappings to be stored in this map * @throws UnsupportedOperationException if the &lt;tt&gt;putAll&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the class of a key or value in the * specified map prevents it from being stored in this map * @throws NullPointerException if the specified map is null, or if * this map does not permit null keys or values, and the * specified map contains null keys or values * @throws IllegalArgumentException if some property of a key or value in * the specified map prevents it from being stored in this map */ void putAll(Map&lt;? extends K, ? extends V&gt; m); /** * Removes all of the mappings from this map (optional operation). * The map will be empty after this call returns. * * @throws UnsupportedOperationException if the &lt;tt&gt;clear&lt;/tt&gt; operation * is not supported by this map */ void clear(); 5、查看方法： keySet：获取所有的键集合 values：获取键值对中所有的值集合 /** * Returns a {@link Set} view of the keys contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of * the iteration are undefined. The set supports element removal, * which removes the corresponding mapping from the map, via the * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; * operations. * * @return a set view of the keys contained in this map */ Set&lt;K&gt; keySet(); /** * Returns a {@link Collection} view of the values contained in this map. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. If the map is * modified while an iteration over the collection is in progress * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), * the results of the iteration are undefined. The collection * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a collection view of the values contained in this map */ Collection&lt;V&gt; values(); 6、entrySet：获取键值对的集合。map的实际值是保存在Map.Entry中 /** * Returns a {@link Set} view of the mappings contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the * iterator) the results of the iteration are undefined. The set * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and * &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a set view of the mappings contained in this map */ Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); 7、Entry：定义了key，value的get/set方法，用于保存map的键值对信息。 /** * A map entry (key-value pair). The &lt;tt&gt;Map.entrySet&lt;/tt&gt; method returns * a collection-view of the map, whose elements are of this class. The * &lt;i&gt;only&lt;/i&gt; way to obtain a reference to a map entry is from the * iterator of this collection-view. These &lt;tt&gt;Map.Entry&lt;/tt&gt; objects are * valid &lt;i&gt;only&lt;/i&gt; for the duration of the iteration; more formally, * the behavior of a map entry is undefined if the backing map has been * modified after the entry was returned by the iterator, except through * the &lt;tt&gt;setValue&lt;/tt&gt; operation on the map entry. * * @see Map#entrySet() * @since 1.2 */ interface Entry&lt;K,V&gt; { /** * Returns the key corresponding to this entry. * * @return the key corresponding to this entry * @throws IllegalStateException implementations may, but are not * required to, throw this exception if the entry has been * removed from the backing map. */ K getKey(); /** * Returns the value corresponding to this entry. If the mapping * has been removed from the backing map (by the iterator's * &lt;tt&gt;remove&lt;/tt&gt; operation), the results of this call are undefined. * * @return the value corresponding to this entry * @throws IllegalStateException implementations may, but are not * required to, throw this exception if the entry has been * removed from the backing map. */ V getValue(); /** * Replaces the value corresponding to this entry with the specified * value (optional operation). (Writes through to the map.) The * behavior of this call is undefined if the mapping has already been * removed from the map (by the iterator's &lt;tt&gt;remove&lt;/tt&gt; operation). * * @param value new value to be stored in this entry * @return old value corresponding to the entry * @throws UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation * is not supported by the backing map * @throws ClassCastException if the class of the specified value * prevents it from being stored in the backing map * @throws NullPointerException if the backing map does not permit * null values, and the specified value is null * @throws IllegalArgumentException if some property of this value * prevents it from being stored in the backing map * @throws IllegalStateException implementations may, but are not * required to, throw this exception if the entry has been * removed from the backing map. */ V setValue(V value); /** * Compares the specified object with this entry for equality. * Returns &lt;tt&gt;true&lt;/tt&gt; if the given object is also a map entry and * the two entries represent the same mapping. More formally, two * entries &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; represent the same mapping * if&lt;pre&gt; * (e1.getKey()==null ? * e2.getKey()==null : e1.getKey().equals(e2.getKey())) &amp;amp;&amp;amp; * (e1.getValue()==null ? * e2.getValue()==null : e1.getValue().equals(e2.getValue())) * &lt;/pre&gt; * This ensures that the &lt;tt&gt;equals&lt;/tt&gt; method works properly across * different implementations of the &lt;tt&gt;Map.Entry&lt;/tt&gt; interface. * * @param o object to be compared for equality with this map entry * @return &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this map * entry */ boolean equals(Object o); /** * Returns the hash code value for this map entry. The hash code * of a map entry &lt;tt&gt;e&lt;/tt&gt; is defined to be: &lt;pre&gt; * (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ * (e.getValue()==null ? 0 : e.getValue().hashCode()) * &lt;/pre&gt; * This ensures that &lt;tt&gt;e1.equals(e2)&lt;/tt&gt; implies that * &lt;tt&gt;e1.hashCode()==e2.hashCode()&lt;/tt&gt; for any two Entries * &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt;, as required by the general * contract of &lt;tt&gt;Object.hashCode&lt;/tt&gt;. * * @return the hash code value for this map entry * @see Object#hashCode() * @see Object#equals(Object) * @see #equals(Object) */ int hashCode(); /** * Returns a comparator that compares {@link Map.Entry} in natural order on key. * * &lt;p&gt;The returned comparator is serializable and throws {@link * NullPointerException} when comparing an entry with a null key. * * @param &lt;K&gt; the {@link Comparable} type of then map keys * @param &lt;V&gt; the type of the map values * @return a comparator that compares {@link Map.Entry} in natural order on key. * @see Comparable * @since 1.8 */ public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() { return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey()); } /** * Returns a comparator that compares {@link Map.Entry} in natural order on value. * * &lt;p&gt;The returned comparator is serializable and throws {@link * NullPointerException} when comparing an entry with null values. * * @param &lt;K&gt; the type of the map keys * @param &lt;V&gt; the {@link Comparable} type of the map values * @return a comparator that compares {@link Map.Entry} in natural order on value. * @see Comparable * @since 1.8 */ public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() { return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue()); } /** * Returns a comparator that compares {@link Map.Entry} by key using the given * {@link Comparator}. * * &lt;p&gt;The returned comparator is serializable if the specified comparator * is also serializable. * * @param &lt;K&gt; the type of the map keys * @param &lt;V&gt; the type of the map values * @param cmp the key {@link Comparator} * @return a comparator that compares {@link Map.Entry} by the key. * @since 1.8 */ public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) { Objects.requireNonNull(cmp); return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey()); } /** * Returns a comparator that compares {@link Map.Entry} by value using the given * {@link Comparator}. * * &lt;p&gt;The returned comparator is serializable if the specified comparator * is also serializable. * * @param &lt;K&gt; the type of the map keys * @param &lt;V&gt; the type of the map values * @param cmp the value {@link Comparator} * @return a comparator that compares {@link Map.Entry} by the value. * @since 1.8 */ public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) { Objects.requireNonNull(cmp); return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue()); } } 7、getOrDefault：底层提供了值为空时，获取默认值的方法 default V getOrDefault(Object key, V defaultValue) { V v; return (((v = get(key)) != null) || containsKey(key)) ? v : defaultValue; } 8、putIfAbsent：如果原有值不存在，则将新值设置进去 /** * If the specified key is not already associated with a value (or is mapped * to {@code null}) associates it with the given value and returns * {@code null}, else returns the current value. * * @implSpec * The default implementation is equivalent to, for this {@code * map}: * * &lt;pre&gt; {@code * V v = map.get(key); * if (v == null) * v = map.put(key, value); * * return v; * }&lt;/pre&gt; * * &lt;p&gt;The default implementation makes no guarantees about synchronization * or atomicity properties of this method. Any implementation providing * atomicity guarantees must override this method and document its * concurrency properties. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with the specified key, or * {@code null} if there was no mapping for the key. * (A {@code null} return can also indicate that the map * previously associated {@code null} with the key, * if the implementation supports null values.) * @throws UnsupportedOperationException if the {@code put} operation * is not supported by this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws ClassCastException if the key or value is of an inappropriate * type for this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key or value is null, * and this map does not permit null keys or values * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws IllegalArgumentException if some property of the specified key * or value prevents it from being stored in this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @since 1.8 */ default V putIfAbsent(K key, V value) { V v = get(key); if (v == null) { v = put(key, value); } return v; } 9、remove(Object key, Object value)：key-value同时相等时进行删除。如果key不存在，则不操作，并返回false。 只有实际删除了，才返回true /** * Removes the entry for the specified key only if it is currently * mapped to the specified value. * * @implSpec * The default implementation is equivalent to, for this {@code map}: * * &lt;pre&gt; {@code * if (map.containsKey(key) &amp;&amp; Objects.equals(map.get(key), value)) { * map.remove(key); * return true; * } else * return false; * }&lt;/pre&gt; * * &lt;p&gt;The default implementation makes no guarantees about synchronization * or atomicity properties of this method. Any implementation providing * atomicity guarantees must override this method and document its * concurrency properties. * * @param key key with which the specified value is associated * @param value value expected to be associated with the specified key * @return {@code true} if the value was removed * @throws UnsupportedOperationException if the {@code remove} operation * is not supported by this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws ClassCastException if the key or value is of an inappropriate * type for this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key or value is null, * and this map does not permit null keys or values * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @since 1.8 */ default boolean remove(Object key, Object value) { Object curValue = get(key); if (!Objects.equals(curValue, value) || (curValue == null &amp;&amp; !containsKey(key))) { return false; } remove(key); return true; } 10、replace(K key, V oldValue, V newValue)：校验key-oldValue匹配后，且key存在之后；才设置新的newValue /** * Replaces the entry for the specified key only if currently * mapped to the specified value. * * @implSpec * The default implementation is equivalent to, for this {@code map}: * * &lt;pre&gt; {@code * if (map.containsKey(key) &amp;&amp; Objects.equals(map.get(key), value)) { * map.put(key, newValue); * return true; * } else * return false; * }&lt;/pre&gt; * * The default implementation does not throw NullPointerException * for maps that do not support null values if oldValue is null unless * newValue is also null. * * &lt;p&gt;The default implementation makes no guarantees about synchronization * or atomicity properties of this method. Any implementation providing * atomicity guarantees must override this method and document its * concurrency properties. * * @param key key with which the specified value is associated * @param oldValue value expected to be associated with the specified key * @param newValue value to be associated with the specified key * @return {@code true} if the value was replaced * @throws UnsupportedOperationException if the {@code put} operation * is not supported by this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws ClassCastException if the class of a specified key or value * prevents it from being stored in this map * @throws NullPointerException if a specified key or newValue is null, * and this map does not permit null keys or values * @throws NullPointerException if oldValue is null and this map does not * permit null values * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws IllegalArgumentException if some property of a specified key * or value prevents it from being stored in this map * @since 1.8 */ default boolean replace(K key, V oldValue, V newValue) { Object curValue = get(key); if (!Objects.equals(curValue, oldValue) || (curValue == null &amp;&amp; !containsKey(key))) { return false; } put(key, newValue); return true; } 11、replace(K key, V value)：值存在或者键存在，则替换新的value /** * Replaces the entry for the specified key only if it is * currently mapped to some value. * * @implSpec * The default implementation is equivalent to, for this {@code map}: * * &lt;pre&gt; {@code * if (map.containsKey(key)) { * return map.put(key, value); * } else * return null; * }&lt;/pre&gt; * * &lt;p&gt;The default implementation makes no guarantees about synchronization * or atomicity properties of this method. Any implementation providing * atomicity guarantees must override this method and document its * concurrency properties. * * @param key key with which the specified value is associated * @param value value to be associated with the specified key * @return the previous value associated with the specified key, or * {@code null} if there was no mapping for the key. * (A {@code null} return can also indicate that the map * previously associated {@code null} with the key, * if the implementation supports null values.) * @throws UnsupportedOperationException if the {@code put} operation * is not supported by this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws ClassCastException if the class of the specified key or value * prevents it from being stored in this map * (&lt;a href="{@docRoot}/java/util/Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key or value is null, * and this map does not permit null keys or values * @throws IllegalArgumentException if some property of the specified key * or value prevents it from being stored in this map * @since 1.8 */ default V replace(K key, V value) { V curValue; if (((curValue = get(key)) != null) || containsKey(key)) { curValue = put(key, value); } return curValue; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十六】LinkedList]]></title>
    <url>%2F2019%2F03%2F01%2Fsource-code-java-16%2F</url>
    <content type="text"><![CDATA[1、Node节点定义 当前元素，前一个元素，后应该元素。 private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } 2、链表参数的定义 size表明集合长度。 first用来标明集合开始的元素，last表明集合结束的元素。 transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; 3、构造函数 无参则默认为空 集合参数实际实现为addAll，一个一个添加。 /** * Constructs an empty list. */ public LinkedList() { } /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c); } 4、内部有用的实际几个实现 linkFirst：添加节点到第一个节点之前（自己成为第一个节点），如果第一个节点不存在，则本身是第一个节点，也是最后一个节点。 linkLast：添加节点到最后一个节点之前（自己成为最后一个节点），如果最后一个节点不存在，则也表明链表为空，当前节点也就是最后一个节点。 linkBefore：在元素前添加一个元素 unlinkFirst：删除第一个元素 unlinkLast：删除最后一个元素 unlink：删除某个元素 /** * Links e as first element. */ private void linkFirst(E e) { final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; } /** * Links e as last element. */ void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } /** * Inserts element e before non-null Node succ. */ void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } /** * Unlinks non-null first node f. */ private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; } /** * Unlinks non-null last node l. */ private E unlinkLast(Node&lt;E&gt; l) { // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; } /** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } 6、addAll 打开指定位置的节点，并创建集合的节点串联起来，最后在接到开口的结尾处。 /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element * from the specified collection * @param c collection containing elements to be added to this list * @return {@code true} if this list changed as a result of the call * @throws IndexOutOfBoundsException {@inheritDoc} * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) { checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) { succ = null; pred = last; } else { succ = node(index); pred = succ.prev; } for (Object o : a) { @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; } if (succ == null) { last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true; } 7、默认对第一个元素的操作 peek获取第一个元素的值 element：获取第一个元素 poll：推出（删除）第一个元素，并返回。 remove：删除第一个元素 /** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list, or {@code null} if this list is empty * @since 1.5 */ public E peek() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; } /** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */ public E element() { return getFirst(); } /** * Retrieves and removes the head (first element) of this list. * * @return the head of this list, or {@code null} if this list is empty * @since 1.5 */ public E poll() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); } /** * Retrieves and removes the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */ public E remove() { return removeFirst(); } 8、后进先出：类似堆栈，后续会解析堆栈 /** * Pushes an element onto the stack represented by this list. In other * words, inserts the element at the front of this list. * * &lt;p&gt;This method is equivalent to {@link #addFirst}. * * @param e the element to push * @since 1.6 */ public void push(E e) { addFirst(e); } /** * Pops an element from the stack represented by this list. In other * words, removes and returns the first element of this list. * * &lt;p&gt;This method is equivalent to {@link #removeFirst()}. * * @return the element at the front of this list (which is the top * of the stack represented by this list) * @throws NoSuchElementException if this list is empty * @since 1.6 */ public E pop() { return removeFirst(); } 9、toArray 需要遍历一遍进行赋值 public &lt;T&gt; T[] toArray(T[] a) { if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); int i = 0; Object[] result = a; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; if (a.length &gt; size) a[size] = null; return a; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十五】ArrayList]]></title>
    <url>%2F2019%2F03%2F01%2Fsource-code-java-15%2F</url>
    <content type="text"><![CDATA[1、DEFAULT_CAPACITY ：默认初始容量 当首次扩容时，默认扩容是此常量：10 /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 2、EMPTY_ELEMENTDATA 与DEFAULTCAPACITY_EMPTY_ELEMENTDATA 两个都是初始化空数组。EMPTY_ELEMENTDATA 初始化的是构造函数参数为0的时候的值， DEFAULTCAPACITY_EMPTY_ELEMENTDATA是初始化无参构造函数的值。在首次添加记录时，如果是无参构造函数初始化的DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则初始分配空间大小为DEFAULT_CAPACITY 。EMPTY_ELEMENTDATA 则与普通添加元素时扩展的空间一致。 /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 3、elementData与size elementData用于保存集合的值，size为集合实际的长度。因为elementData的长度并不是实际的size大小。 /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; 4、无参与带initialCapacity初始容量的构造函数 /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); } } /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 5、集合参数的构造函数 当集合为空时，实际退化为initialCapacity=0时的构造函数 /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 6、容量裁剪。容量与集合实际大小一致，释放空间。 /** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */ public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } 7、容量扩展方法 ensureCapacity：判断当前是否为空构造函数创建的集合，如果是则最低扩展长度为10。否则按传入容量参数为准，传入容量大于最低扩展时才进行扩展，否则无需扩展。ArrayList中此方法并没有进行使用。 ensureCapacityInternal：如果是无参构造函数创建的集合，则取默认扩展容量与当前要扩展容量中的最大值，然后判断是否需要扩展容量。 ensureExplicitCapacity：判断当前的容量是否足够，不够则再进行容量扩展判断。 MAX_ARRAY_SIZE：最大数组长度 grow：实际的空间扩展方法。每次增加旧空间的一半，判断是否满足新申请的空间，不满足则以新申请的为准。如果大于最大的数组长度，则返回整形最大值（最大数组长度+8），然后扩展空间。 扩展空间大于实际所需空间能避免频繁申请空间对系统的资源消耗。 /** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) { int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) { ensureExplicitCapacity(minCapacity); } } private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); } /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 8、contains与indexOf contains实际是indexOf() != -1的实现 /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */ public boolean contains(Object o) { return indexOf(o) &gt;= 0; } /** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1; } 9、add 申请空间再赋值 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 某个位置插入值，先校验位置是否合法，再申请空间，然后调用系统底层的高效方法进行数组拷贝。最后在指定位置插入值，并且数组长度+1。 /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 10、remove 指定位置之后的所有值向前拷贝一位，最后的值置空，并且数组长度-1。 /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 11、remove Object 先查找位置，然后快速删除（参考快速删除说明） /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } 12、fastRemove：内部快速删除，无需进行校验与数据保存与返回。 /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 13、clear 元素全部清空后长度设置为0 /** * Removes all of the elements from this list. The list will * be empty after this call returns. */ public void clear() { modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; } 14、addAll 扩展集合的长度，然后调用底层的数组复制。最后判断如果集合为空则返回false。有个疑问是为什么不先进行数组长度判断，再进行之后的操作，网上也大致没有相关资料。 /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } 15、batchRemove：批量删除 遍历：要删除的集合中包含的元素就往前移一位，最后将多余的数组置空并设置size。 private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try { for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; } finally { // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) { System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; } if (w != size) { // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; } } return modified; } 16、未重载equals与hashCode，使用了父类AbstractList中的equals与hashCode的实现。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十四】AbstractList]]></title>
    <url>%2F2019%2F03%2F01%2Fsource-code-java-14%2F</url>
    <content type="text"><![CDATA[1、indexOf /** * {@inheritDoc} * * &lt;p&gt;This implementation first gets a list iterator (with * {@code listIterator()}). Then, it iterates over the list until the * specified element is found or the end of the list is reached. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public int indexOf(Object o) { ListIterator&lt;E&gt; it = listIterator(); if (o==null) { while (it.hasNext()) if (it.next()==null) return it.previousIndex(); } else { while (it.hasNext()) if (o.equals(it.next())) return it.previousIndex(); } return -1; } 解析：迭代器返回的是：previousIndex 前元素下标，咋一看有点难以理解。可以查看迭代器的具体实现。 /** * {@inheritDoc} * * &lt;p&gt;This implementation returns {@code listIterator(0)}. * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() { return listIterator(0); } /** * {@inheritDoc} * * &lt;p&gt;This implementation returns a straightforward implementation of the * {@code ListIterator} interface that extends the implementation of the * {@code Iterator} interface returned by the {@code iterator()} method. * The {@code ListIterator} implementation relies on the backing list's * {@code get(int)}, {@code set(int, E)}, {@code add(int, E)} * and {@code remove(int)} methods. * * &lt;p&gt;Note that the list iterator returned by this implementation will * throw an {@link UnsupportedOperationException} in response to its * {@code remove}, {@code set} and {@code add} methods unless the * list's {@code remove(int)}, {@code set(int, E)}, and * {@code add(int, E)} methods are overridden. * * &lt;p&gt;This implementation can be made to throw runtime exceptions in the * face of concurrent modification, as described in the specification for * the (protected) {@link #modCount} field. * * @throws IndexOutOfBoundsException {@inheritDoc} */ public ListIterator&lt;E&gt; listIterator(final int index) { rangeCheckForAdd(index); return new ListItr(index); } 默认获取的迭代器游标cursor从0开始，以为cursor=0的元素就是第一个元素。实际0指向的是第一个元素的前一个元素，也就是第一个元素的cursor是1。因此可以得出index = cursor - 1。previousIndex = cursor - 1得到当前元素的下标index也就不难理解了。 private class Itr implements Iterator&lt;E&gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } private class ListItr extends Itr implements ListIterator&lt;E&gt; { ListItr(int index) { cursor = index; } public boolean hasPrevious() { return cursor != 0; } public E previous() { checkForComodification(); try { int i = cursor - 1; E previous = get(i); lastRet = cursor = i; return previous; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public int nextIndex() { return cursor; } public int previousIndex() { return cursor-1; } public void set(E e) { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.set(lastRet, e); expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } public void add(E e) { checkForComodification(); try { int i = cursor; AbstractList.this.add(i, e); lastRet = -1; cursor = i + 1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } } 2、lastIndexOf 其中nextIndex与previousIndex同理。nextIndex返回当前元素的下标 /** * {@inheritDoc} * * &lt;p&gt;This implementation first gets a list iterator that points to the end * of the list (with {@code listIterator(size())}). Then, it iterates * backwards over the list until the specified element is found, or the * beginning of the list is reached. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public int lastIndexOf(Object o) { ListIterator&lt;E&gt; it = listIterator(size()); if (o==null) { while (it.hasPrevious()) if (it.previous()==null) return it.nextIndex(); } else { while (it.hasPrevious()) if (o.equals(it.previous())) return it.nextIndex(); } return -1; } 3、ListItr 中lastRet的作用 add或者remove后不能继续remove元素。remove后当前元素不存在了，自然不能继续remove当前元素；add之后游标指向了下一个元素，cursor + 1，需要next之后继续添加。 测试如下： List&lt;Long&gt; list = new ArrayList&lt;Long&gt;(); list.add(1L); list.add(2L); list.add(3L); list.add(4L); list.add(5L); ListIterator&lt;Long&gt; iterator = list.listIterator(); iterator.next(); iterator.next(); iterator.next(); iterator.add(11L); iterator.remove(); 测试结果： Exception in thread “main” java.lang.IllegalStateException at java.util.ArrayList$Itr.remove(ArrayList.java:864) at com.rich.file.Test.main(Test.java:36) 正确做法： List&lt;Long&gt; list = new ArrayList&lt;Long&gt;(); list.add(1L); list.add(2L); list.add(3L); list.add(4L); list.add(5L); ListIterator&lt;Long&gt; iterator = list.listIterator(); iterator.next(); iterator.next(); iterator.next(); iterator.add(11L); iterator.next(); iterator.remove(); 4、equals 元素依次比较是否相等，并且顺序要一致。 /** * Compares the specified object with this list for equality. Returns * {@code true} if and only if the specified object is also a list, both * lists have the same size, and all corresponding pairs of elements in * the two lists are &lt;i&gt;equal&lt;/i&gt;. (Two elements {@code e1} and * {@code e2} are &lt;i&gt;equal&lt;/i&gt; if {@code (e1==null ? e2==null : * e1.equals(e2))}.) In other words, two lists are defined to be * equal if they contain the same elements in the same order.&lt;p&gt; * * This implementation first checks if the specified object is this * list. If so, it returns {@code true}; if not, it checks if the * specified object is a list. If not, it returns {@code false}; if so, * it iterates over both lists, comparing corresponding pairs of elements. * If any comparison returns {@code false}, this method returns * {@code false}. If either iterator runs out of elements before the * other it returns {@code false} (as the lists are of unequal length); * otherwise it returns {@code true} when the iterations complete. * * @param o the object to be compared for equality with this list * @return {@code true} if the specified object is equal to this list */ public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof List)) return false; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); if (!(o1==null ? o2==null : o1.equals(o2))) return false; } return !(e1.hasNext() || e2.hasNext()); } 这里比较疑惑为啥没有先进行size判断，在进行比较。可能部分的实现计算size复杂度会达到O(n)吧。因此有需要的实现可继续重写，如下： public boolean equals(Object o) { if ((o instanceof List) &amp;&amp; ((List) o).size() == size()) { return true; } return super.equals(o); } 5、hashCode：对每个值的hashCode进行计算。 /** * Returns the hash code value for this list. * * &lt;p&gt;This implementation uses exactly the code that is used to define the * list hash function in the documentation for the {@link List#hashCode} * method. * * @return the hash code value for this list */ public int hashCode() { int hashCode = 1; for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode; } 6、subList：获取子数列 public List&lt;E&gt; subList(int fromIndex, int toIndex) { return new SubList&lt;&gt;(this, fromIndex, toIndex); } 7、内部类SubList、RandomAccessSubList RandomAccessSubList比SubList添加了实现RandomAccess。是否随机访问集合。部分实现是可以极大提高访问效率。 class SubList&lt;E&gt; extends AbstractList&lt;E&gt; { private final AbstractList&lt;E&gt; l; private final int offset; private int size; SubList(AbstractList&lt;E&gt; list, int fromIndex, int toIndex) { if (fromIndex &lt; 0) throw new IndexOutOfBoundsException("fromIndex = " + fromIndex); if (toIndex &gt; list.size()) throw new IndexOutOfBoundsException("toIndex = " + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException("fromIndex(" + fromIndex + ") &gt; toIndex(" + toIndex + ")"); l = list; offset = fromIndex; size = toIndex - fromIndex; this.modCount = l.modCount; } public E set(int index, E element) { rangeCheck(index); checkForComodification(); return l.set(index+offset, element); } public E get(int index) { rangeCheck(index); checkForComodification(); return l.get(index+offset); } public int size() { checkForComodification(); return size; } public void add(int index, E element) { rangeCheckForAdd(index); checkForComodification(); l.add(index+offset, element); this.modCount = l.modCount; size++; } public E remove(int index) { rangeCheck(index); checkForComodification(); E result = l.remove(index+offset); this.modCount = l.modCount; size--; return result; } protected void removeRange(int fromIndex, int toIndex) { checkForComodification(); l.removeRange(fromIndex+offset, toIndex+offset); this.modCount = l.modCount; size -= (toIndex-fromIndex); } public boolean addAll(Collection&lt;? extends E&gt; c) { return addAll(size, c); } public boolean addAll(int index, Collection&lt;? extends E&gt; c) { rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); l.addAll(offset+index, c); this.modCount = l.modCount; size += cSize; return true; } public Iterator&lt;E&gt; iterator() { return listIterator(); } public ListIterator&lt;E&gt; listIterator(final int index) { checkForComodification(); rangeCheckForAdd(index); return new ListIterator&lt;E&gt;() { private final ListIterator&lt;E&gt; i = l.listIterator(index+offset); public boolean hasNext() { return nextIndex() &lt; size; } public E next() { if (hasNext()) return i.next(); else throw new NoSuchElementException(); } public boolean hasPrevious() { return previousIndex() &gt;= 0; } public E previous() { if (hasPrevious()) return i.previous(); else throw new NoSuchElementException(); } public int nextIndex() { return i.nextIndex() - offset; } public int previousIndex() { return i.previousIndex() - offset; } public void remove() { i.remove(); SubList.this.modCount = l.modCount; size--; } public void set(E e) { i.set(e); } public void add(E e) { i.add(e); SubList.this.modCount = l.modCount; size++; } }; } public List&lt;E&gt; subList(int fromIndex, int toIndex) { return new SubList&lt;&gt;(this, fromIndex, toIndex); } private void rangeCheck(int index) { if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private void rangeCheckForAdd(int index) { if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private String outOfBoundsMsg(int index) { return "Index: "+index+", Size: "+size; } private void checkForComodification() { if (this.modCount != l.modCount) throw new ConcurrentModificationException(); } } class RandomAccessSubList&lt;E&gt; extends SubList&lt;E&gt; implements RandomAccess { RandomAccessSubList(AbstractList&lt;E&gt; list, int fromIndex, int toIndex) { super(list, fromIndex, toIndex); } public List&lt;E&gt; subList(int fromIndex, int toIndex) { return new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十三】AbstractCollection]]></title>
    <url>%2F2019%2F03%2F01%2Fsource-code-java-13%2F</url>
    <content type="text"><![CDATA[1、抽象函数定义，子类继承 /** * Returns an iterator over the elements contained in this collection. * * @return an iterator over the elements contained in this collection */ public abstract Iterator&lt;E&gt; iterator(); public abstract int size(); 2、空集合定义，判断size是否为0 /** * {@inheritDoc} * * &lt;p&gt;This implementation returns &lt;tt&gt;size() == 0&lt;/tt&gt;. */ public boolean isEmpty() { return size() == 0; } 3、是否包含某个变量，迭代器判断是否相等，如果变量为null，则判断集合中是否存在null值 /** * {@inheritDoc} * * &lt;p&gt;This implementation iterates over the elements in the collection, * checking each element in turn for equality with the specified element. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public boolean contains(Object o) { Iterator&lt;E&gt; it = iterator(); if (o==null) { while (it.hasNext()) if (it.next()==null) return true; } else { while (it.hasNext()) if (o.equals(it.next())) return true; } return false; } 4、toArray，转为数组。通过迭代器的方式，如果期间集合的值添加了，也会返回添加后的值。如果减少了，则返回减少后的值。 /** * {@inheritDoc} * * &lt;p&gt;This implementation returns an array containing all the elements * returned by this collection's iterator, in the same order, stored in * consecutive elements of the array, starting with index {@code 0}. * The length of the returned array is equal to the number of elements * returned by the iterator, even if the size of this collection changes * during iteration, as might happen if the collection permits * concurrent modification during iteration. The {@code size} method is * called only as an optimization hint; the correct result is returned * even if the iterator returns a different number of elements. * * &lt;p&gt;This method is equivalent to: * * &lt;pre&gt; {@code * List&lt;E&gt; list = new ArrayList&lt;E&gt;(size()); * for (E e : this) * list.add(e); * return list.toArray(); * }&lt;/pre&gt; */ public Object[] toArray() { // Estimate size of array; be prepared to see more or fewer elements Object[] r = new Object[size()]; Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) { if (! it.hasNext()) // fewer elements than expected return Arrays.copyOf(r, i); r[i] = it.next(); } return it.hasNext() ? finishToArray(r, it) : r; } 5、带数组参数的toArray。需要注意的是会改变传入数组的值，新数组也不是原有集合的长度，而是与传入数组的长度相关，当传入数组的长度小于等于集合的长度时，以集合长度为准，否则以数组长度为准。返回数组中，如果输出超出集合部分的第一个值为null，其后值不变。具体看测试结果。 /** * {@inheritDoc} * * &lt;p&gt;This implementation returns an array containing all the elements * returned by this collection's iterator in the same order, stored in * consecutive elements of the array, starting with index {@code 0}. * If the number of elements returned by the iterator is too large to * fit into the specified array, then the elements are returned in a * newly allocated array with length equal to the number of elements * returned by the iterator, even if the size of this collection * changes during iteration, as might happen if the collection permits * concurrent modification during iteration. The {@code size} method is * called only as an optimization hint; the correct result is returned * even if the iterator returns a different number of elements. * * &lt;p&gt;This method is equivalent to: * * &lt;pre&gt; {@code * List&lt;E&gt; list = new ArrayList&lt;E&gt;(size()); * for (E e : this) * list.add(e); * return list.toArray(a); * }&lt;/pre&gt; * * @throws ArrayStoreException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) { // Estimate size of array; be prepared to see more or fewer elements int size = size(); T[] r = a.length &gt;= size ? a : (T[])java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), size); Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) { if (! it.hasNext()) { // fewer elements than expected if (a == r) { r[i] = null; // null-terminate } else if (a.length &lt; i) { return Arrays.copyOf(r, i); } else { System.arraycopy(r, 0, a, 0, i); if (a.length &gt; i) { a[i] = null; } } return a; } r[i] = (T)it.next(); } // more elements than expected return it.hasNext() ? finishToArray(r, it) : r; } 测试代码： public static void main(String[] args) { List&lt;Long&gt; list = new ArrayList&lt;Long&gt;(); list.add(1L); list.add(2L); list.add(3L); Long[] array = new Long[] {4L, 5L, 6L, 7L, 8L}; Long[] newArray = list.toArray(array); for (int i = 0; i &lt; array.length; i++) { System.out.print(array[i] + " "); } System.out.println(); for (int i = 0; i &lt; newArray.length; i++) { System.out.print(newArray[i] + " "); } } 测试结果： 1 2 3 null 8 1 2 3 null 8 6、集合的最大长度：2的31次方 - 8 /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 7、将迭代器的值设置到数组中并返回 /** * Reallocates the array being used within toArray when the iterator * returned more elements than expected, and finishes filling it from * the iterator. * * @param r the array, replete with previously stored elements * @param it the in-progress iterator over this collection * @return array containing the elements in the given array, plus any * further elements returned by the iterator, trimmed to size */ @SuppressWarnings("unchecked") private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) { int i = r.length; while (it.hasNext()) { int cap = r.length; if (i == cap) { int newCap = cap + (cap &gt;&gt; 1) + 1; // overflow-conscious code if (newCap - MAX_ARRAY_SIZE &gt; 0) newCap = hugeCapacity(cap + 1); r = Arrays.copyOf(r, newCap); } r[i++] = (T)it.next(); } // trim if overallocated return (i == r.length) ? r : Arrays.copyOf(r, i); } 8、最大容量：hugeCapacity private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError ("Required array size too large"); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 9、remove：删除集合中第一个出现的值，删除成功返回true。不存在则返回false /** * {@inheritDoc} * * &lt;p&gt;This implementation iterates over the collection looking for the * specified element. If it finds the element, it removes the element * from the collection using the iterator's remove method. * * &lt;p&gt;Note that this implementation throws an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the iterator returned by this * collection's iterator method does not implement the &lt;tt&gt;remove&lt;/tt&gt; * method and this collection contains the specified object. * * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public boolean remove(Object o) { Iterator&lt;E&gt; it = iterator(); if (o==null) { while (it.hasNext()) { if (it.next()==null) { it.remove(); return true; } } } else { while (it.hasNext()) { if (o.equals(it.next())) { it.remove(); return true; } } } return false; } 10、containsAll：判断每个值是否都存在 /** * {@inheritDoc} * * &lt;p&gt;This implementation iterates over the specified collection, * checking each element returned by the iterator in turn to see * if it's contained in this collection. If all elements are so * contained &lt;tt&gt;true&lt;/tt&gt; is returned, otherwise &lt;tt&gt;false&lt;/tt&gt;. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @see #contains(Object) */ public boolean containsAll(Collection&lt;?&gt; c) { for (Object e : c) if (!contains(e)) return false; return true; } 11、addAll:添加集合全部的值，添加成功返回true /** * {@inheritDoc} * * &lt;p&gt;This implementation iterates over the specified collection, and adds * each object returned by the iterator to this collection, in turn. * * &lt;p&gt;Note that this implementation will throw an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; unless &lt;tt&gt;add&lt;/tt&gt; is * overridden (assuming the specified collection is non-empty). * * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} * @throws IllegalStateException {@inheritDoc} * * @see #add(Object) */ public boolean addAll(Collection&lt;? extends E&gt; c) { boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; } 12、差集：removeAll：删除集合全部的值，存在删除一个则返回true /** * {@inheritDoc} * * &lt;p&gt;This implementation iterates over this collection, checking each * element returned by the iterator in turn to see if it's contained * in the specified collection. If it's so contained, it's removed from * this collection with the iterator's &lt;tt&gt;remove&lt;/tt&gt; method. * * &lt;p&gt;Note that this implementation will throw an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the iterator returned by the * &lt;tt&gt;iterator&lt;/tt&gt; method does not implement the &lt;tt&gt;remove&lt;/tt&gt; method * and this collection contains one or more elements in common with the * specified collection. * * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * * @see #remove(Object) * @see #contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator&lt;?&gt; it = iterator(); while (it.hasNext()) { if (c.contains(it.next())) { it.remove(); modified = true; } } return modified; } 13、交集：集合中存在的不删 /** * {@inheritDoc} * * &lt;p&gt;This implementation iterates over this collection, checking each * element returned by the iterator in turn to see if it's contained * in the specified collection. If it's not so contained, it's removed * from this collection with the iterator's &lt;tt&gt;remove&lt;/tt&gt; method. * * &lt;p&gt;Note that this implementation will throw an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the iterator returned by the * &lt;tt&gt;iterator&lt;/tt&gt; method does not implement the &lt;tt&gt;remove&lt;/tt&gt; method * and this collection contains one or more elements not present in the * specified collection. * * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * * @see #remove(Object) * @see #contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); boolean modified = false; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) { if (!c.contains(it.next())) { it.remove(); modified = true; } } return modified; } 14、clear：一个一个删除 /** * {@inheritDoc} * * &lt;p&gt;This implementation iterates over this collection, removing each * element using the &lt;tt&gt;Iterator.remove&lt;/tt&gt; operation. Most * implementations will probably choose to override this method for * efficiency. * * &lt;p&gt;Note that this implementation will throw an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the iterator returned by this * collection's &lt;tt&gt;iterator&lt;/tt&gt; method does not implement the * &lt;tt&gt;remove&lt;/tt&gt; method and this collection is non-empty. * * @throws UnsupportedOperationException {@inheritDoc} */ public void clear() { Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) { it.next(); it.remove(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十二】Void]]></title>
    <url>%2F2019%2F03%2F01%2Fsource-code-java-12%2F</url>
    <content type="text"><![CDATA[1、源码查看 /** * The {@code Void} class is an uninstantiable placeholder class to hold a * reference to the {@code Class} object representing the Java keyword * void. * * @author unascribed * @since JDK1.1 */ public final class Void { /** * The {@code Class} object representing the pseudo-type corresponding to * the keyword {@code void}. */ @SuppressWarnings("unchecked") public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass("void"); /* * The Void class cannot be instantiated. */ private Void() {} } 2、Void与void Void是void的封装类 3、Void作用 在方法返回值反射时可以使用Void.TYPE来判断类型。也可以使用void.class来判断。 4、总结 实际作用并不大，从声明来看，有用部分也只声明了TYPE。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十一】Thread]]></title>
    <url>%2F2019%2F02%2F28%2Fsource-code-java-11%2F</url>
    <content type="text"><![CDATA[1、实现接口Runnable 不仅是Thread，实现Runnable的类也可直接通过线程池启动，或者通过Thread的start方法启动 public class Thread implements Runnable { } 2、注册线程 /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */ private static native void registerNatives(); static { registerNatives(); } 3、参数 /* 线程名称，在创建对象时指定。 */ private volatile char name[]; /* 线程优先级，越大越优先，越先被执行。最大10，最小1，默认是5 */ private int priority; /* 未发现其作用 */ private Thread threadQ; /* 未发现其作用 */ private long eetop; /* Whether or not to single_step this thread. */ private boolean single_step; /* Whether or not the thread is a daemon thread. */ /* 守护线程，如果存在非后台线程，则会一直存在，直到非后台线程终止后停止。需要在thread启动前指定setDaemon，启动后无效。 */ private boolean daemon = false; /* JVM state */ private boolean stillborn = false; /* What will be run. */ /* 目标启动线程，在创建时以构造参数的方式传入。 */ private Runnable target; /* The group of this thread */ /* 本线程的线程组，启动时将本线程添加到线程组中。如果创建线程时未指定线程组，则默认返回安全的线程组。 */ private ThreadGroup group; /* 安全访问策略：AccessControlContext。在创建时需要应用到，native获取方法与本地化虚拟机交互。 */ /* The inherited AccessControlContext of this thread */ private AccessControlContext inheritedAccessControlContext; /* For autonumbering anonymous threads. */ private static int threadInitNumber; /* 每创建一次，线程的初始化值就+1 */ private static synchronized int nextThreadNum() { return threadInitNumber++; } /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ /* 初始化时创建 */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; /* * The requested stack size for this thread, or 0 if the creator did * not specify a stack size. It is up to the VM to do whatever it * likes with this number; some VMs will ignore it. */ /* 堆栈值，依赖于虚拟机，部分虚拟机直接忽略此参数 */ private long stackSize; /* * Thread ID */ private long tid; /* For generating thread ID */ /* 用户生成线程序号 */ private static long threadSeqNumber; /* Java thread status for tools, * initialized to indicate thread 'not yet started' */ private volatile int threadStatus = 0; private static synchronized long nextThreadID() { return ++threadSeqNumber; } 4、线程优先级常量：最大10，最小1，默认是5 /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; 5、本地创建当前线程 /** * Returns a reference to the currently executing thread object. * * @return the currently executing thread. */ public static native Thread currentThread(); 6、sleep 本地休眠毫秒：sleep(long millis) 休眠纳秒：sleep(long millis, int nanos).实际是休眠大于500纳秒秒时，或者是毫秒为0，纳秒不为0时，自动给休眠的毫秒加1。 /** * Causes the currently executing thread to sleep (temporarily cease * execution) for the specified number of milliseconds, subject to * the precision and accuracy of system timers and schedulers. The thread * does not lose ownership of any monitors. * * @param millis * the length of time to sleep in milliseconds * * @throws IllegalArgumentException * if the value of {@code millis} is negative * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public static native void sleep(long millis) throws InterruptedException; /** * Causes the currently executing thread to sleep (temporarily cease * execution) for the specified number of milliseconds plus the specified * number of nanoseconds, subject to the precision and accuracy of system * timers and schedulers. The thread does not lose ownership of any * monitors. * * @param millis * the length of time to sleep in milliseconds * * @param nanos * {@code 0-999999} additional nanoseconds to sleep * * @throws IllegalArgumentException * if the value of {@code millis} is negative, or the value of * {@code nanos} is not in the range {@code 0-999999} * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public static void sleep(long millis, int nanos) throws InterruptedException { if (millis &lt; 0) { throw new IllegalArgumentException("timeout value is negative"); } if (nanos &lt; 0 || nanos &gt; 999999) { throw new IllegalArgumentException( "nanosecond timeout value out of range"); } if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) { millis++; } sleep(millis); } 7、init：初始化线程 先指定线程名 从本地获取线程为父线程（本地创建后才有此线程的创建，父子概念成立） 线程组的初始化，，不存在则从安全组获取，或者从本地获取，然后校验是否有安全组的访问权限。 线程安全访问策略如果存在，则校验是否有线程实现的权限 设置是否守护线程与线程优先级 初始化访问策略 目标线程值初始化 设置当前线程的ID private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) { if (name == null) { throw new NullPointerException("name cannot be null"); } this.name = name.toCharArray(); Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } 8、构造函数 默认对线程名的指定，都实现如上的init方法 /** * Allocates a new {@code Thread} object. This constructor has the same * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread} * {@code (null, null, gname)}, where {@code gname} is a newly generated * name. Automatically generated names are of the form * {@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer. */ public Thread() { init(null, null, "Thread-" + nextThreadNum(), 0); } /** * Allocates a new {@code Thread} object. This constructor has the same * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread} * {@code (null, target, gname)}, where {@code gname} is a newly generated * name. Automatically generated names are of the form * {@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer. * * @param target * the object whose {@code run} method is invoked when this thread * is started. If {@code null}, this classes {@code run} method does * nothing. */ public Thread(Runnable target) { init(null, target, "Thread-" + nextThreadNum(), 0); } /** * Creates a new Thread that inherits the given AccessControlContext. * This is not a public constructor. */ Thread(Runnable target, AccessControlContext acc) { init(null, target, "Thread-" + nextThreadNum(), 0, acc); } /** * Allocates a new {@code Thread} object. This constructor has the same * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread} * {@code (group, target, gname)} ,where {@code gname} is a newly generated * name. Automatically generated names are of the form * {@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer. * * @param group * the thread group. If {@code null} and there is a security * manager, the group is determined by {@linkplain * SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}. * If there is not a security manager or {@code * SecurityManager.getThreadGroup()} returns {@code null}, the group * is set to the current thread's thread group. * * @param target * the object whose {@code run} method is invoked when this thread * is started. If {@code null}, this thread's run method is invoked. * * @throws SecurityException * if the current thread cannot create a thread in the specified * thread group */ public Thread(ThreadGroup group, Runnable target) { init(group, target, "Thread-" + nextThreadNum(), 0); } /** * Allocates a new {@code Thread} object. This constructor has the same * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread} * {@code (null, null, name)}. * * @param name * the name of the new thread */ public Thread(String name) { init(null, null, name, 0); } /** * Allocates a new {@code Thread} object. This constructor has the same * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread} * {@code (group, null, name)}. * * @param group * the thread group. If {@code null} and there is a security * manager, the group is determined by {@linkplain * SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}. * If there is not a security manager or {@code * SecurityManager.getThreadGroup()} returns {@code null}, the group * is set to the current thread's thread group. * * @param name * the name of the new thread * * @throws SecurityException * if the current thread cannot create a thread in the specified * thread group */ public Thread(ThreadGroup group, String name) { init(group, null, name, 0); } /** * Allocates a new {@code Thread} object. This constructor has the same * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread} * {@code (null, target, name)}. * * @param target * the object whose {@code run} method is invoked when this thread * is started. If {@code null}, this thread's run method is invoked. * * @param name * the name of the new thread */ public Thread(Runnable target, String name) { init(null, target, name, 0); } /** * Allocates a new {@code Thread} object so that it has {@code target} * as its run object, has the specified {@code name} as its name, * and belongs to the thread group referred to by {@code group}. * * &lt;p&gt;If there is a security manager, its * {@link SecurityManager#checkAccess(ThreadGroup) checkAccess} * method is invoked with the ThreadGroup as its argument. * * &lt;p&gt;In addition, its {@code checkPermission} method is invoked with * the {@code RuntimePermission("enableContextClassLoaderOverride")} * permission when invoked directly or indirectly by the constructor * of a subclass which overrides the {@code getContextClassLoader} * or {@code setContextClassLoader} methods. * * &lt;p&gt;The priority of the newly created thread is set equal to the * priority of the thread creating it, that is, the currently running * thread. The method {@linkplain #setPriority setPriority} may be * used to change the priority to a new value. * * &lt;p&gt;The newly created thread is initially marked as being a daemon * thread if and only if the thread creating it is currently marked * as a daemon thread. The method {@linkplain #setDaemon setDaemon} * may be used to change whether or not a thread is a daemon. * * @param group * the thread group. If {@code null} and there is a security * manager, the group is determined by {@linkplain * SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}. * If there is not a security manager or {@code * SecurityManager.getThreadGroup()} returns {@code null}, the group * is set to the current thread's thread group. * * @param target * the object whose {@code run} method is invoked when this thread * is started. If {@code null}, this thread's run method is invoked. * * @param name * the name of the new thread * * @throws SecurityException * if the current thread cannot create a thread in the specified * thread group or cannot override the context class loader methods. */ public Thread(ThreadGroup group, Runnable target, String name) { init(group, target, name, 0); } /** * Allocates a new {@code Thread} object so that it has {@code target} * as its run object, has the specified {@code name} as its name, * and belongs to the thread group referred to by {@code group}, and has * the specified &lt;i&gt;stack size&lt;/i&gt;. * * &lt;p&gt;This constructor is identical to {@link * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact * that it allows the thread stack size to be specified. The stack size * is the approximate number of bytes of address space that the virtual * machine is to allocate for this thread's stack. &lt;b&gt;The effect of the * {@code stackSize} parameter, if any, is highly platform dependent.&lt;/b&gt; * * &lt;p&gt;On some platforms, specifying a higher value for the * {@code stackSize} parameter may allow a thread to achieve greater * recursion depth before throwing a {@link StackOverflowError}. * Similarly, specifying a lower value may allow a greater number of * threads to exist concurrently without throwing an {@link * OutOfMemoryError} (or other internal error). The details of * the relationship between the value of the &lt;tt&gt;stackSize&lt;/tt&gt; parameter * and the maximum recursion depth and concurrency level are * platform-dependent. &lt;b&gt;On some platforms, the value of the * {@code stackSize} parameter may have no effect whatsoever.&lt;/b&gt; * * &lt;p&gt;The virtual machine is free to treat the {@code stackSize} * parameter as a suggestion. If the specified value is unreasonably low * for the platform, the virtual machine may instead use some * platform-specific minimum value; if the specified value is unreasonably * high, the virtual machine may instead use some platform-specific * maximum. Likewise, the virtual machine is free to round the specified * value up or down as it sees fit (or to ignore it completely). * * &lt;p&gt;Specifying a value of zero for the {@code stackSize} parameter will * cause this constructor to behave exactly like the * {@code Thread(ThreadGroup, Runnable, String)} constructor. * * &lt;p&gt;&lt;i&gt;Due to the platform-dependent nature of the behavior of this * constructor, extreme care should be exercised in its use. * The thread stack size necessary to perform a given computation will * likely vary from one JRE implementation to another. In light of this * variation, careful tuning of the stack size parameter may be required, * and the tuning may need to be repeated for each JRE implementation on * which an application is to run.&lt;/i&gt; * * &lt;p&gt;Implementation note: Java platform implementers are encouraged to * document their implementation's behavior with respect to the * {@code stackSize} parameter. * * * @param group * the thread group. If {@code null} and there is a security * manager, the group is determined by {@linkplain * SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}. * If there is not a security manager or {@code * SecurityManager.getThreadGroup()} returns {@code null}, the group * is set to the current thread's thread group. * * @param target * the object whose {@code run} method is invoked when this thread * is started. If {@code null}, this thread's run method is invoked. * * @param name * the name of the new thread * * @param stackSize * the desired stack size for the new thread, or zero to indicate * that this parameter is to be ignored. * * @throws SecurityException * if the current thread cannot create a thread in the specified * thread group * * @since 1.4 */ public Thread(ThreadGroup group, Runnable target, String name, long stackSize) { init(group, target, name, stackSize); } 9、start线程启动 添加当前线程到线程组中 设置本地线程为启动，启动成功则设置成功状态 启动失败则线程组中移除该线程 /** * Causes this thread to begin execution; the Java Virtual Machine * calls the &lt;code&gt;run&lt;/code&gt; method of this thread. * &lt;p&gt; * The result is that two threads are running concurrently: the * current thread (which returns from the call to the * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its * &lt;code&gt;run&lt;/code&gt; method). * &lt;p&gt; * It is never legal to start a thread more than once. * In particular, a thread may not be restarted once it has completed * execution. * * @exception IllegalThreadStateException if the thread was already * started. * @see #run() * @see #stop() */ public synchronized void start() { /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); void threadStartFailed(Thread t) { synchronized(this) { remove(t); nUnstartedThreads++; } } 10、run 调用run方法执行运行接口的run实现 /** * If this thread was constructed using a separate * &lt;code&gt;Runnable&lt;/code&gt; run object, then that * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called; * otherwise, this method does nothing and returns. * &lt;p&gt; * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method. * * @see #start() * @see #stop() * @see #Thread(ThreadGroup, Runnable, String) */ @Override public void run() { if (target != null) { target.run(); } } 11、exit退出 线程组移除该线程，并唤起全部线程 其余的值置空，等待回收 /** * This method is called by the system to give a Thread * a chance to clean up before it actually exits. */ private void exit() { if (group != null) { group.threadTerminated(this); group = null; } /* Aggressively null out all reference fields: see bug 4006245 */ target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; } 12、stop 线程强制退出，将废弃 /** * Forces the thread to stop executing. * &lt;p&gt; * If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt; * method is called with &lt;code&gt;this&lt;/code&gt; * as its argument. This may result in a * &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread). * &lt;p&gt; * If this thread is different from the current thread (that is, the current * thread is trying to stop a thread other than itself), the * security manager's &lt;code&gt;checkPermission&lt;/code&gt; method (with a * &lt;code&gt;RuntimePermission("stopThread")&lt;/code&gt; argument) is called in * addition. * Again, this may result in throwing a * &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread). * &lt;p&gt; * The thread represented by this thread is forced to stop whatever * it is doing abnormally and to throw a newly created * &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception. * &lt;p&gt; * It is permitted to stop a thread that has not yet been started. * If the thread is eventually started, it immediately terminates. * &lt;p&gt; * An application should not normally try to catch * &lt;code&gt;ThreadDeath&lt;/code&gt; unless it must do some extraordinary * cleanup operation (note that the throwing of * &lt;code&gt;ThreadDeath&lt;/code&gt; causes &lt;code&gt;finally&lt;/code&gt; clauses of * &lt;code&gt;try&lt;/code&gt; statements to be executed before the thread * officially dies). If a &lt;code&gt;catch&lt;/code&gt; clause catches a * &lt;code&gt;ThreadDeath&lt;/code&gt; object, it is important to rethrow the * object so that the thread actually dies. * &lt;p&gt; * The top-level error handler that reacts to otherwise uncaught * exceptions does not print out a message or otherwise notify the * application if the uncaught exception is an instance of * &lt;code&gt;ThreadDeath&lt;/code&gt;. * * @exception SecurityException if the current thread cannot * modify this thread. * @see #interrupt() * @see #checkAccess() * @see #run() * @see #start() * @see ThreadDeath * @see ThreadGroup#uncaughtException(Thread,Throwable) * @see SecurityManager#checkAccess(Thread) * @see SecurityManager#checkPermission * @deprecated This method is inherently unsafe. Stopping a thread with * Thread.stop causes it to unlock all of the monitors that it * has locked (as a natural consequence of the unchecked * &lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up the stack). If * any of the objects previously protected by these monitors were in * an inconsistent state, the damaged objects become visible to * other threads, potentially resulting in arbitrary behavior. Many * uses of &lt;code&gt;stop&lt;/code&gt; should be replaced by code that simply * modifies some variable to indicate that the target thread should * stop running. The target thread should check this variable * regularly, and return from its run method in an orderly fashion * if the variable indicates that it is to stop running. If the * target thread waits for long periods (on a condition variable, * for example), the &lt;code&gt;interrupt&lt;/code&gt; method should be used to * interrupt the wait. * For more information, see * &lt;a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html"&gt;Why * are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;. */ @Deprecated public final void stop() { SecurityManager security = System.getSecurityManager(); if (security != null) { checkAccess(); if (this != Thread.currentThread()) { security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION); } } // A zero status value corresponds to "NEW", it can't change to // not-NEW because we hold the lock. if (threadStatus != 0) { resume(); // Wake up thread if it was suspended; no-op otherwise } // The VM can handle all thread states stop0(new ThreadDeath()); } 13、interrupt 中断线程，并不一定立刻中断，只是设置线程的状态为中断 /** * Interrupts this thread. * * &lt;p&gt; Unless the current thread is interrupting itself, which is * always permitted, the {@link #checkAccess() checkAccess} method * of this thread is invoked, which may cause a {@link * SecurityException} to be thrown. * * &lt;p&gt; If this thread is blocked in an invocation of the {@link * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link * Object#wait(long, int) wait(long, int)} methods of the {@link Object} * class, or of the {@link #join()}, {@link #join(long)}, {@link * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)}, * methods of this class, then its interrupt status will be cleared and it * will receive an {@link InterruptedException}. * * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link * java.nio.channels.InterruptibleChannel InterruptibleChannel} * then the channel will be closed, the thread's interrupt * status will be set, and the thread will receive a {@link * java.nio.channels.ClosedByInterruptException}. * * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector} * then the thread's interrupt status will be set and it will return * immediately from the selection operation, possibly with a non-zero * value, just as if the selector's {@link * java.nio.channels.Selector#wakeup wakeup} method were invoked. * * &lt;p&gt; If none of the previous conditions hold then this thread's interrupt * status will be set. &lt;/p&gt; * * &lt;p&gt; Interrupting a thread that is not alive need not have any effect. * * @throws SecurityException * if the current thread cannot modify this thread * * @revised 6.0 * @spec JSR-51 */ public void interrupt() { if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) { Interruptible b = blocker; if (b != null) { interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; } } interrupt0(); } /** * Tests whether the current thread has been interrupted. The * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see #isInterrupted() * @revised 6.0 */ public static boolean interrupted() { return currentThread().isInterrupted(true); } 14、setPriority 设置线程优先级，在线程启动前设置有效。 /** * Changes the priority of this thread. * &lt;p&gt; * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called * with no arguments. This may result in throwing a * &lt;code&gt;SecurityException&lt;/code&gt;. * &lt;p&gt; * Otherwise, the priority of this thread is set to the smaller of * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted * priority of the thread's thread group. * * @param newPriority priority to set this thread to * @exception IllegalArgumentException If the priority is not in the * range &lt;code&gt;MIN_PRIORITY&lt;/code&gt; to * &lt;code&gt;MAX_PRIORITY&lt;/code&gt;. * @exception SecurityException if the current thread cannot modify * this thread. * @see #getPriority * @see #checkAccess() * @see #getThreadGroup() * @see #MAX_PRIORITY * @see #MIN_PRIORITY * @see ThreadGroup#getMaxPriority() */ public final void setPriority(int newPriority) { ThreadGroup g; checkAccess(); if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) { throw new IllegalArgumentException(); } if((g = getThreadGroup()) != null) { if (newPriority &gt; g.getMaxPriority()) { newPriority = g.getMaxPriority(); } setPriority0(priority = newPriority); } } 15、join(long millis) 参数millis为等待的毫秒时间，如果为0时表示等待此线程执行后执行以下线程。不为0时则等待此毫秒值后继续向下执行。 /** * Waits at most {@code millis} milliseconds for this thread to * die. A timeout of {@code 0} means to wait forever. * * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls * conditioned on {@code this.isAlive}. As a thread terminates the * {@code this.notifyAll} method is invoked. It is recommended that * applications not use {@code wait}, {@code notify}, or * {@code notifyAll} on {@code Thread} instances. * * @param millis * the time to wait in milliseconds * * @throws IllegalArgumentException * if the value of {@code millis} is negative * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException("timeout value is negative"); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } } 16、join(long millis, int nanos) 等待执行纳秒，与sleep中的纳秒逻辑一致 /** * Waits at most {@code millis} milliseconds plus * {@code nanos} nanoseconds for this thread to die. * * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls * conditioned on {@code this.isAlive}. As a thread terminates the * {@code this.notifyAll} method is invoked. It is recommended that * applications not use {@code wait}, {@code notify}, or * {@code notifyAll} on {@code Thread} instances. * * @param millis * the time to wait in milliseconds * * @param nanos * {@code 0-999999} additional nanoseconds to wait * * @throws IllegalArgumentException * if the value of {@code millis} is negative, or the value * of {@code nanos} is not in the range {@code 0-999999} * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public final synchronized void join(long millis, int nanos) throws InterruptedException { if (millis &lt; 0) { throw new IllegalArgumentException("timeout value is negative"); } if (nanos &lt; 0 || nanos &gt; 999999) { throw new IllegalArgumentException( "nanosecond timeout value out of range"); } if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) { millis++; } join(millis); } 17、join() 默认为等待此线程执行完成 /** * Waits for this thread to die. * * &lt;p&gt; An invocation of this method behaves in exactly the same * way as the invocation * * &lt;blockquote&gt; * {@linkplain #join(long) join}{@code (0)} * &lt;/blockquote&gt; * * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public final void join() throws InterruptedException { join(0); } 18、线程状态 /** * A thread state. A thread can be in one of the following states: * &lt;ul&gt; * &lt;li&gt;{@link #NEW}&lt;br&gt; * A thread that has not yet started is in this state. * &lt;/li&gt; * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt; * A thread executing in the Java virtual machine is in this state. * &lt;/li&gt; * &lt;li&gt;{@link #BLOCKED}&lt;br&gt; * A thread that is blocked waiting for a monitor lock * is in this state. * &lt;/li&gt; * &lt;li&gt;{@link #WAITING}&lt;br&gt; * A thread that is waiting indefinitely for another thread to * perform a particular action is in this state. * &lt;/li&gt; * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt; * A thread that is waiting for another thread to perform an action * for up to a specified waiting time is in this state. * &lt;/li&gt; * &lt;li&gt;{@link #TERMINATED}&lt;br&gt; * A thread that has exited is in this state. * &lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt; * A thread can be in only one state at a given point in time. * These states are virtual machine states which do not reflect * any operating system thread states. * * @since 1.5 * @see #getState */ public enum State { /** * Thread state for a thread which has not yet started. */ /*创建*/ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ /*可运行*/ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ /*阻塞*/ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt; * &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt; * &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ /*等待*/ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt; * &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt; * &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt; * &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt; * &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt; * &lt;/ul&gt; */ /* 已制定等待时间的等待状态 */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ /*已终止的状态*/ TERMINATED; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【十】Short]]></title>
    <url>%2F2019%2F02%2F28%2Fsource-code-java-10%2F</url>
    <content type="text"><![CDATA[1、最大值与最小值 /** * A constant holding the minimum value a {@code short} can * have, -2&lt;sup&gt;15&lt;/sup&gt;. */ public static final short MIN_VALUE = -32768; /** * A constant holding the maximum value a {@code short} can * have, 2&lt;sup&gt;15&lt;/sup&gt;-1. */ public static final short MAX_VALUE = 32767; 2、ShortCache 定义缓存-128~127 private static class ShortCache { private ShortCache(){} static final Short cache[] = new Short[-(-128) + 127 + 1]; static { for(int i = 0; i &lt; cache.length; i++) cache[i] = new Short((short)(i - 128)); } } 3、hashCode与equals 返回相应的short值 /** * Returns a hash code for a {@code short} value; compatible with * {@code Short.hashCode()}. * * @param value the value to hash * @return a hash code value for a {@code short} value. * @since 1.8 */ public static int hashCode(short value) { return (int)value; } /** * Compares this object to the specified object. The result is * {@code true} if and only if the argument is not * {@code null} and is a {@code Short} object that * contains the same {@code short} value as this object. * * @param obj the object to compare with * @return {@code true} if the objects are the same; * {@code false} otherwise. */ public boolean equals(Object obj) { if (obj instanceof Short) { return value == ((Short)obj).shortValue(); } return false; } 4、其余与Integer功能类似 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【九】Long]]></title>
    <url>%2F2019%2F02%2F27%2Fsource-code-java-9%2F</url>
    <content type="text"><![CDATA[1、最大值最小值 /** * A constant holding the minimum value a {@code long} can * have, -2&lt;sup&gt;63&lt;/sup&gt;. */ @Native public static final long MIN_VALUE = 0x8000000000000000L; /** * A constant holding the maximum value a {@code long} can * have, 2&lt;sup&gt;63&lt;/sup&gt;-1. */ @Native public static final long MAX_VALUE = 0x7fffffffffffffffL; 2、stringSize：乘法判断位数，Long比Integer大很多，定义数组比较长 static int stringSize(long x) { long p = 10; for (int i=1; i&lt;19; i++) { if (x &lt; p) return i; p = 10*p; } return 19; } 3、LongCache -128~127的缓存。 private static class LongCache { private LongCache(){} static final Long cache[] = new Long[-(-128) + 127 + 1]; static { for(int i = 0; i &lt; cache.length; i++) cache[i] = new Long(i - 128); } } /** * Returns a {@code Long} instance representing the specified * {@code long} value. * If a new {@code Long} instance is not required, this method * should generally be used in preference to the constructor * {@link #Long(long)}, as this method is likely to yield * significantly better space and time performance by caching * frequently requested values. * * Note that unlike the {@linkplain Integer#valueOf(int) * corresponding method} in the {@code Integer} class, this method * is &lt;em&gt;not&lt;/em&gt; required to cache values within a particular * range. * * @param l a long value. * @return a {@code Long} instance representing {@code l}. * @since 1.5 */ public static Long valueOf(long l) { final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache return LongCache.cache[(int)l + offset]; } return new Long(l); } 4、hashCode 返回前32位与后32位的异或值 @Override public int hashCode() { return Long.hashCode(value); } /** * Returns a hash code for a {@code long} value; compatible with * {@code Long.hashCode()}. * * @param value the value to hash * @return a hash code value for a {@code long} value. * @since 1.8 */ public static int hashCode(long value) { return (int)(value ^ (value &gt;&gt;&gt; 32)); } 5、equals 值的比较 public boolean equals(Object obj) { if (obj instanceof Long) { return value == ((Long)obj).longValue(); } return false; } 6、其余功能与Integer类似 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【八】Integer]]></title>
    <url>%2F2019%2F02%2F27%2Fsource-code-java-8%2F</url>
    <content type="text"><![CDATA[1、最大值最小值 /** * A constant holding the minimum value an {@code int} can * have, -2&lt;sup&gt;31&lt;/sup&gt;. */ @Native public static final int MIN_VALUE = 0x80000000; /** * A constant holding the maximum value an {@code int} can * have, 2&lt;sup&gt;31&lt;/sup&gt;-1. */ @Native public static final int MAX_VALUE = 0x7fffffff; 2、进制字符：最大为10+26=36进制 /** * All possible chars for representing a number as a String */ final static char[] digits = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' }; 3、进制转化字符串 进制最小2进制，最大36进制 10进制直接返回字符串，进制转化时取绝对值，再进行转化，最后添加符号 public static String toString(int i, int radix) { if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX) radix = 10; /* Use the faster version */ if (radix == 10) { return toString(i); } char buf[] = new char[33]; boolean negative = (i &lt; 0); int charPos = 32; if (!negative) { i = -i; } while (i &lt;= -radix) { buf[charPos--] = digits[-(i % radix)]; i = i / radix; } buf[charPos] = digits[-i]; if (negative) { buf[--charPos] = '-'; } return new String(buf, charPos, (33 - charPos)); } 4、16进制、8进制、2进制转化 都是转化成无符号的进制数。先计算出位数，创建对应的字符数组，位运算计算出每一位的值，并获取值对应的字符，任何创建字符串返回。 /** * Returns a string representation of the integer argument as an * unsigned integer in base&amp;nbsp;16. * * &lt;p&gt;The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; * if the argument is negative; otherwise, it is equal to the * argument. This value is converted to a string of ASCII digits * in hexadecimal (base&amp;nbsp;16) with no extra leading * {@code 0}s. * * &lt;p&gt;The value of the argument can be recovered from the returned * string {@code s} by calling {@link * Integer#parseUnsignedInt(String, int) * Integer.parseUnsignedInt(s, 16)}. * * &lt;p&gt;If the unsigned magnitude is zero, it is represented by a * single zero character {@code '0'} ({@code '\u005Cu0030'}); * otherwise, the first character of the representation of the * unsigned magnitude will not be the zero character. The * following characters are used as hexadecimal digits: * * &lt;blockquote&gt; * {@code 0123456789abcdef} * &lt;/blockquote&gt; * * These are the characters {@code '\u005Cu0030'} through * {@code '\u005Cu0039'} and {@code '\u005Cu0061'} through * {@code '\u005Cu0066'}. If uppercase letters are * desired, the {@link java.lang.String#toUpperCase()} method may * be called on the result: * * &lt;blockquote&gt; * {@code Integer.toHexString(n).toUpperCase()} * &lt;/blockquote&gt; * * @param i an integer to be converted to a string. * @return the string representation of the unsigned integer value * represented by the argument in hexadecimal (base&amp;nbsp;16). * @see #parseUnsignedInt(String, int) * @see #toUnsignedString(int, int) * @since JDK1.0.2 */ public static String toHexString(int i) { return toUnsignedString0(i, 4); } /** * Returns a string representation of the integer argument as an * unsigned integer in base&amp;nbsp;8. * * &lt;p&gt;The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; * if the argument is negative; otherwise, it is equal to the * argument. This value is converted to a string of ASCII digits * in octal (base&amp;nbsp;8) with no extra leading {@code 0}s. * * &lt;p&gt;The value of the argument can be recovered from the returned * string {@code s} by calling {@link * Integer#parseUnsignedInt(String, int) * Integer.parseUnsignedInt(s, 8)}. * * &lt;p&gt;If the unsigned magnitude is zero, it is represented by a * single zero character {@code '0'} ({@code '\u005Cu0030'}); * otherwise, the first character of the representation of the * unsigned magnitude will not be the zero character. The * following characters are used as octal digits: * * &lt;blockquote&gt; * {@code 01234567} * &lt;/blockquote&gt; * * These are the characters {@code '\u005Cu0030'} through * {@code '\u005Cu0037'}. * * @param i an integer to be converted to a string. * @return the string representation of the unsigned integer value * represented by the argument in octal (base&amp;nbsp;8). * @see #parseUnsignedInt(String, int) * @see #toUnsignedString(int, int) * @since JDK1.0.2 */ public static String toOctalString(int i) { return toUnsignedString0(i, 3); } /** * Returns a string representation of the integer argument as an * unsigned integer in base&amp;nbsp;2. * * &lt;p&gt;The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; * if the argument is negative; otherwise it is equal to the * argument. This value is converted to a string of ASCII digits * in binary (base&amp;nbsp;2) with no extra leading {@code 0}s. * * &lt;p&gt;The value of the argument can be recovered from the returned * string {@code s} by calling {@link * Integer#parseUnsignedInt(String, int) * Integer.parseUnsignedInt(s, 2)}. * * &lt;p&gt;If the unsigned magnitude is zero, it is represented by a * single zero character {@code '0'} ({@code '\u005Cu0030'}); * otherwise, the first character of the representation of the * unsigned magnitude will not be the zero character. The * characters {@code '0'} ({@code '\u005Cu0030'}) and {@code * '1'} ({@code '\u005Cu0031'}) are used as binary digits. * * @param i an integer to be converted to a string. * @return the string representation of the unsigned integer value * represented by the argument in binary (base&amp;nbsp;2). * @see #parseUnsignedInt(String, int) * @see #toUnsignedString(int, int) * @since JDK1.0.2 */ public static String toBinaryString(int i) { return toUnsignedString0(i, 1); } /** * Convert the integer to an unsigned number. */ private static String toUnsignedString0(int val, int shift) { // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : "Illegal shift value"; int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val); int chars = Math.max(((mag + (shift - 1)) / shift), 1); char[] buf = new char[chars]; formatUnsignedInt(val, shift, buf, 0, chars); // Use special constructor which takes over "buf". return new String(buf, true); } /** * Format a long (treated as unsigned) into a character buffer. * @param val the unsigned int to format * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary) * @param buf the character buffer to write to * @param offset the offset in the destination buffer to start at * @param len the number of characters to write * @return the lowest character location used */ static int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len) { int charPos = len; int radix = 1 &lt;&lt; shift; int mask = radix - 1; do { buf[offset + --charPos] = Integer.digits[val &amp; mask]; val &gt;&gt;&gt;= shift; } while (val != 0 &amp;&amp; charPos &gt; 0); return charPos; } 5、巧妙的个位数与十位数常量，对应的数字下标肯定可以返回对应的十位和个位上的值 final static char [] DigitTens = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '3', '3', '3', '3', '3', '3', '3', '3', '3', '3', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '5', '5', '5', '5', '5', '5', '5', '5', '5', '5', '6', '6', '6', '6', '6', '6', '6', '6', '6', '6', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '8', '8', '8', '8', '8', '8', '8', '8', '8', '8', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', } ; final static char [] DigitOnes = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', } ; 6、getChars，将int值转化为字符数组 可参考：https://www.jianshu.com/p/44a14079f161 /** * Places characters representing the integer i into the * character array buf. The characters are placed into * the buffer backwards starting with the least significant * digit at the specified index (exclusive), and working * backwards from there. * * Will fail if i == Integer.MIN_VALUE */ static void getChars(int i, int index, char[] buf) { int q, r; int charPos = index; char sign = 0; if (i &lt; 0) { sign = '-'; i = -i; } // Generate two digits per iteration while (i &gt;= 65536) { q = i / 100; // really: r = i - (q * 100); r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)); i = q; buf [--charPos] = DigitOnes[r]; buf [--charPos] = DigitTens[r]; } // Fall thru to fast mode for smaller numbers // assert(i &lt;= 65536, i); for (;;) { q = (i * 52429) &gt;&gt;&gt; (16+3); r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1)); // r = i-(q*10) ... buf [--charPos] = digits [r]; i = q; if (i == 0) break; } if (sign != 0) { buf [--charPos] = sign; } } 7、stringSize:int有几位 巧妙的使用数组比较来获取位数，而不是除法来 final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE }; // Requires positive x static int stringSize(int x) { for (int i=0; ; i++) if (x &lt;= sizeTable[i]) return i+1; } 8、parseInt 字符串按进制来转化成int。最大2进制，最小36进行，有符号整形。 public static int parseInt(String s, int radix) throws NumberFormatException { /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) { throw new NumberFormatException("null"); } if (radix &lt; Character.MIN_RADIX) { throw new NumberFormatException("radix " + radix + " less than Character.MIN_RADIX"); } if (radix &gt; Character.MAX_RADIX) { throw new NumberFormatException("radix " + radix + " greater than Character.MAX_RADIX"); } int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len &gt; 0) { char firstChar = s.charAt(0); if (firstChar &lt; '0') { // Possible leading "+" or "-" if (firstChar == '-') { negative = true; limit = Integer.MIN_VALUE; } else if (firstChar != '+') throw NumberFormatException.forInputString(s); if (len == 1) // Cannot have lone "+" or "-" throw NumberFormatException.forInputString(s); i++; } multmin = limit / radix; while (i &lt; len) { // Accumulating negatively avoids surprises near MAX_VALUE digit = Character.digit(s.charAt(i++),radix); if (digit &lt; 0) { throw NumberFormatException.forInputString(s); } if (result &lt; multmin) { throw NumberFormatException.forInputString(s); } result *= radix; if (result &lt; limit + digit) { throw NumberFormatException.forInputString(s); } result -= digit; } } else { throw NumberFormatException.forInputString(s); } return negative ? result : -result; } 9、parseInt 默认十进制 public static int parseInt(String s) throws NumberFormatException { return parseInt(s,10); } 10、parseUnsignedInt：无符号字符串进制解析 public static int parseUnsignedInt(String s, int radix) throws NumberFormatException { if (s == null) { throw new NumberFormatException("null"); } int len = s.length(); if (len &gt; 0) { char firstChar = s.charAt(0); if (firstChar == '-') { throw new NumberFormatException(String.format("Illegal leading minus sign " + "on unsigned string %s.", s)); } else { if (len &lt;= 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits (radix == 10 &amp;&amp; len &lt;= 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits return parseInt(s, radix); } else { long ell = Long.parseLong(s, radix); if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) { return (int) ell; } else { throw new NumberFormatException(String.format("String value %s exceeds " + "range of unsigned int.", s)); } } } } else { throw NumberFormatException.forInputString(s); } } 11、IntegerCache 整形缓存，默认创建-128~127的Integer对象 private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 12、valueOf 在-128~127之间无需new对象，之间从缓存获取 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 13、hashCode与equals hashCode返回整形；equals比较int大小 @Override public int hashCode() { return Integer.hashCode(value); } /** * Returns a hash code for a {@code int} value; compatible with * {@code Integer.hashCode()}. * * @param value the value to hash * @since 1.8 * * @return a hash code value for a {@code int} value. */ public static int hashCode(int value) { return value; } /** * Compares this object to the specified object. The result is * {@code true} if and only if the argument is not * {@code null} and is an {@code Integer} object that * contains the same {@code int} value as this object. * * @param obj the object to compare with. * @return {@code true} if the objects are the same; * {@code false} otherwise. */ public boolean equals(Object obj) { if (obj instanceof Integer) { return value == ((Integer)obj).intValue(); } return false; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【七】Float]]></title>
    <url>%2F2019%2F02%2F27%2Fsource-code-java-7%2F</url>
    <content type="text"><![CDATA[1、常量定义：SIZE=32；BYTES=4 /** * A constant holding the positive infinity of type * {@code float}. It is equal to the value returned by * {@code Float.intBitsToFloat(0x7f800000)}. */ public static final float POSITIVE_INFINITY = 1.0f / 0.0f; /** * A constant holding the negative infinity of type * {@code float}. It is equal to the value returned by * {@code Float.intBitsToFloat(0xff800000)}. */ public static final float NEGATIVE_INFINITY = -1.0f / 0.0f; /** * A constant holding a Not-a-Number (NaN) value of type * {@code float}. It is equivalent to the value returned by * {@code Float.intBitsToFloat(0x7fc00000)}. */ public static final float NaN = 0.0f / 0.0f; /** * A constant holding the largest positive finite value of type * {@code float}, (2-2&lt;sup&gt;-23&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;127&lt;/sup&gt;. * It is equal to the hexadecimal floating-point literal * {@code 0x1.fffffeP+127f} and also equal to * {@code Float.intBitsToFloat(0x7f7fffff)}. */ public static final float MAX_VALUE = 0x1.fffffeP+127f; // 3.4028235e+38f /** * A constant holding the smallest positive normal value of type * {@code float}, 2&lt;sup&gt;-126&lt;/sup&gt;. It is equal to the * hexadecimal floating-point literal {@code 0x1.0p-126f} and also * equal to {@code Float.intBitsToFloat(0x00800000)}. * * @since 1.6 */ public static final float MIN_NORMAL = 0x1.0p-126f; // 1.17549435E-38f /** * A constant holding the smallest positive nonzero value of type * {@code float}, 2&lt;sup&gt;-149&lt;/sup&gt;. It is equal to the * hexadecimal floating-point literal {@code 0x0.000002P-126f} * and also equal to {@code Float.intBitsToFloat(0x1)}. */ public static final float MIN_VALUE = 0x0.000002P-126f; // 1.4e-45f /** * Maximum exponent a finite {@code float} variable may have. It * is equal to the value returned by {@code * Math.getExponent(Float.MAX_VALUE)}. * * @since 1.6 */ public static final int MAX_EXPONENT = 127; /** * Minimum exponent a normalized {@code float} variable may have. * It is equal to the value returned by {@code * Math.getExponent(Float.MIN_NORMAL)}. * * @since 1.6 */ public static final int MIN_EXPONENT = -126; /** * The number of bits used to represent a {@code float} value. * * @since 1.5 */ public static final int SIZE = 32; /** * The number of bytes used to represent a {@code float} value. * * @since 1.8 */ public static final int BYTES = SIZE / Byte.SIZE; 2、hashCode与equals hashCode直接返回float的位信息，equls根据位信息进行比较。与Double的区别是Double64位使用long型，float是32位使用int型 public static int hashCode(float value) { return floatToIntBits(value); } /** * Compares this object against the specified object. The result * is {@code true} if and only if the argument is not * {@code null} and is a {@code Float} object that * represents a {@code float} with the same value as the * {@code float} represented by this object. For this * purpose, two {@code float} values are considered to be the * same if and only if the method {@link #floatToIntBits(float)} * returns the identical {@code int} value when applied to * each. * * &lt;p&gt;Note that in most cases, for two instances of class * {@code Float}, {@code f1} and {@code f2}, the value * of {@code f1.equals(f2)} is {@code true} if and only if * * &lt;blockquote&gt;&lt;pre&gt; * f1.floatValue() == f2.floatValue() * &lt;/pre&gt;&lt;/blockquote&gt; * * &lt;p&gt;also has the value {@code true}. However, there are two exceptions: * &lt;ul&gt; * &lt;li&gt;If {@code f1} and {@code f2} both represent * {@code Float.NaN}, then the {@code equals} method returns * {@code true}, even though {@code Float.NaN==Float.NaN} * has the value {@code false}. * &lt;li&gt;If {@code f1} represents {@code +0.0f} while * {@code f2} represents {@code -0.0f}, or vice * versa, the {@code equal} test has the value * {@code false}, even though {@code 0.0f==-0.0f} * has the value {@code true}. * &lt;/ul&gt; * * This definition allows hash tables to operate properly. * * @param obj the object to be compared * @return {@code true} if the objects are the same; * {@code false} otherwise. * @see java.lang.Float#floatToIntBits(float) */ public boolean equals(Object obj) { return (obj instanceof Float) &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value)); } /** * Returns a representation of the specified floating-point value * according to the IEEE 754 floating-point "single format" bit * layout. * * &lt;p&gt;Bit 31 (the bit that is selected by the mask * {@code 0x80000000}) represents the sign of the floating-point * number. * Bits 30-23 (the bits that are selected by the mask * {@code 0x7f800000}) represent the exponent. * Bits 22-0 (the bits that are selected by the mask * {@code 0x007fffff}) represent the significand (sometimes called * the mantissa) of the floating-point number. * * &lt;p&gt;If the argument is positive infinity, the result is * {@code 0x7f800000}. * * &lt;p&gt;If the argument is negative infinity, the result is * {@code 0xff800000}. * * &lt;p&gt;If the argument is NaN, the result is {@code 0x7fc00000}. * * &lt;p&gt;In all cases, the result is an integer that, when given to the * {@link #intBitsToFloat(int)} method, will produce a floating-point * value the same as the argument to {@code floatToIntBits} * (except all NaN values are collapsed to a single * "canonical" NaN value). * * @param value a floating-point number. * @return the bits that represent the floating-point number. */ public static int floatToIntBits(float value) { int result = floatToRawIntBits(value); // Check for NaN based on values of bit fields, maximum // exponent and nonzero significand. if ( ((result &amp; FloatConsts.EXP_BIT_MASK) == FloatConsts.EXP_BIT_MASK) &amp;&amp; (result &amp; FloatConsts.SIGNIF_BIT_MASK) != 0) result = 0x7fc00000; return result; } 3、最大值 a与b都为0.0时，a为-0则返回b public static float max(float a, float b) { if (a != a) return a; // a is NaN if ((a == 0.0f) &amp;&amp; (b == 0.0f) &amp;&amp; (Float.floatToRawIntBits(a) == negativeZeroFloatBits)) { // Raw conversion ok since NaN can't map to -0.0. return b; } return (a &gt;= b) ? a : b; } 4、最小值 a与b都为0.0时，b为-0则返回b public static float min(float a, float b) { if (a != a) return a; // a is NaN if ((a == 0.0f) &amp;&amp; (b == 0.0f) &amp;&amp; (Float.floatToRawIntBits(b) == negativeZeroFloatBits)) { // Raw conversion ok since NaN can't map to -0.0. return b; } return (a &lt;= b) ? a : b; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【六】Double]]></title>
    <url>%2F2019%2F02%2F27%2Fsource-code-java-6%2F</url>
    <content type="text"><![CDATA[1、最大值 a与b都为0.0时，a为-0则返回b public static double max(double a, double b) { if (a != a) return a; // a is NaN if ((a == 0.0d) &amp;&amp; (b == 0.0d) &amp;&amp; (Double.doubleToRawLongBits(a) == negativeZeroDoubleBits)) { // Raw conversion ok since NaN can't map to -0.0. return b; } return (a &gt;= b) ? a : b; } 2、最小值 a与b都为0.0时，b为-0则返回b public static double min(double a, double b) { if (a != a) return a; // a is NaN if ((a == 0.0d) &amp;&amp; (b == 0.0d) &amp;&amp; (Double.doubleToRawLongBits(b) == negativeZeroDoubleBits)) { // Raw conversion ok since NaN can't map to -0.0. return b; } return (a &lt;= b) ? a : b; } 3、equals 比较长整位。长整位判断是否为NaN，是则返回NaN对应long型位 public boolean equals(Object obj) { return (obj instanceof Double) &amp;&amp; (doubleToLongBits(((Double)obj).value) == doubleToLongBits(value)); } /** * Returns a representation of the specified floating-point value * according to the IEEE 754 floating-point "double * format" bit layout. * * &lt;p&gt;Bit 63 (the bit that is selected by the mask * {@code 0x8000000000000000L}) represents the sign of the * floating-point number. Bits * 62-52 (the bits that are selected by the mask * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0 * (the bits that are selected by the mask * {@code 0x000fffffffffffffL}) represent the significand * (sometimes called the mantissa) of the floating-point number. * * &lt;p&gt;If the argument is positive infinity, the result is * {@code 0x7ff0000000000000L}. * * &lt;p&gt;If the argument is negative infinity, the result is * {@code 0xfff0000000000000L}. * * &lt;p&gt;If the argument is NaN, the result is * {@code 0x7ff8000000000000L}. * * &lt;p&gt;In all cases, the result is a {@code long} integer that, when * given to the {@link #longBitsToDouble(long)} method, will produce a * floating-point value the same as the argument to * {@code doubleToLongBits} (except all NaN values are * collapsed to a single "canonical" NaN value). * * @param value a {@code double} precision floating-point number. * @return the bits that represent the floating-point number. */ public static long doubleToLongBits(double value) { long result = doubleToRawLongBits(value); // Check for NaN based on values of bit fields, maximum // exponent and nonzero significand. if ( ((result &amp; DoubleConsts.EXP_BIT_MASK) == DoubleConsts.EXP_BIT_MASK) &amp;&amp; (result &amp; DoubleConsts.SIGNIF_BIT_MASK) != 0L) result = 0x7ff8000000000000L; return result; } 4、hashCode 依旧返回长整位的计算，右移32位返回整形 @Override public int hashCode() { return Double.hashCode(value); } /** * Returns a hash code for a {@code double} value; compatible with * {@code Double.hashCode()}. * * @param value the value to hash * @return a hash code value for a {@code double} value. * @since 1.8 */ public static int hashCode(double value) { long bits = doubleToLongBits(value); return (int)(bits ^ (bits &gt;&gt;&gt; 32)); } 5、常量 SIZE=64，双精度浮点型的，BYTES八个字节 /** * A constant holding the positive infinity of type * {@code double}. It is equal to the value returned by * {@code Double.longBitsToDouble(0x7ff0000000000000L)}. */ public static final double POSITIVE_INFINITY = 1.0 / 0.0; /** * A constant holding the negative infinity of type * {@code double}. It is equal to the value returned by * {@code Double.longBitsToDouble(0xfff0000000000000L)}. */ public static final double NEGATIVE_INFINITY = -1.0 / 0.0; /** * A constant holding a Not-a-Number (NaN) value of type * {@code double}. It is equivalent to the value returned by * {@code Double.longBitsToDouble(0x7ff8000000000000L)}. */ public static final double NaN = 0.0d / 0.0; /** * A constant holding the largest positive finite value of type * {@code double}, * (2-2&lt;sup&gt;-52&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;1023&lt;/sup&gt;. It is equal to * the hexadecimal floating-point literal * {@code 0x1.fffffffffffffP+1023} and also equal to * {@code Double.longBitsToDouble(0x7fefffffffffffffL)}. */ public static final double MAX_VALUE = 0x1.fffffffffffffP+1023; // 1.7976931348623157e+308 /** * A constant holding the smallest positive normal value of type * {@code double}, 2&lt;sup&gt;-1022&lt;/sup&gt;. It is equal to the * hexadecimal floating-point literal {@code 0x1.0p-1022} and also * equal to {@code Double.longBitsToDouble(0x0010000000000000L)}. * * @since 1.6 */ public static final double MIN_NORMAL = 0x1.0p-1022; // 2.2250738585072014E-308 /** * A constant holding the smallest positive nonzero value of type * {@code double}, 2&lt;sup&gt;-1074&lt;/sup&gt;. It is equal to the * hexadecimal floating-point literal * {@code 0x0.0000000000001P-1022} and also equal to * {@code Double.longBitsToDouble(0x1L)}. */ public static final double MIN_VALUE = 0x0.0000000000001P-1022; // 4.9e-324 /** * Maximum exponent a finite {@code double} variable may have. * It is equal to the value returned by * {@code Math.getExponent(Double.MAX_VALUE)}. * * @since 1.6 */ public static final int MAX_EXPONENT = 1023; /** * Minimum exponent a normalized {@code double} variable may * have. It is equal to the value returned by * {@code Math.getExponent(Double.MIN_NORMAL)}. * * @since 1.6 */ public static final int MIN_EXPONENT = -1022; /** * The number of bits used to represent a {@code double} value. * * @since 1.5 */ public static final int SIZE = 64; /** * The number of bytes used to represent a {@code double} value. * * @since 1.8 */ public static final int BYTES = SIZE / Byte.SIZE; 6、可参考Double表示：https://blog.csdn.net/yangfangjit/article/details/72890779 Double的表示范围为n*2^m位 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【五】Byte]]></title>
    <url>%2F2019%2F02%2F27%2Fsource-code-java-5%2F</url>
    <content type="text"><![CDATA[1、定义常量，byte取值范围-128~127，位数为8位 /** * A constant holding the minimum value a {@code byte} can * have, -2&lt;sup&gt;7&lt;/sup&gt;. */ public static final byte MIN_VALUE = -128; /** * A constant holding the maximum value a {@code byte} can * have, 2&lt;sup&gt;7&lt;/sup&gt;-1. */ public static final byte MAX_VALUE = 127; /** * The number of bits used to represent a {@code byte} value in two's * complement binary form. * * @since 1.5 */ public static final int SIZE = 8; 2、toString 返回十进制数值 public String toString() { return Integer.toString((int)value); } 3、hashCode byte的int值 @Override public int hashCode() { return Byte.hashCode(value); } public static int hashCode(byte value) { return (int)value; } 4、valueOf byte只有256个值，初始化对象后放入缓存中，直接读取。 private static class ByteCache { private ByteCache(){} static final Byte cache[] = new Byte[-(-128) + 127 + 1]; static { for(int i = 0; i &lt; cache.length; i++) cache[i] = new Byte((byte)(i - 128)); } } public static Byte valueOf(byte b) { final int offset = 128; return ByteCache.cache[(int)b + offset]; } 5、parseByte 解析字符串时，以Integer进行解析成byte，超过byte取值范围则抛出异常 public static byte parseByte(String s, int radix) throws NumberFormatException { int i = Integer.parseInt(s, radix); if (i &lt; MIN_VALUE || i &gt; MAX_VALUE) throw new NumberFormatException( "Value out of range. Value:\"" + s + "\" Radix:" + radix); return (byte)i; } public static byte parseByte(String s) throws NumberFormatException { return parseByte(s, 10); } 6、字符串构造函数 以字符串十进制进行解析 public Byte(String s) throws NumberFormatException { this.value = parseByte(s, 10); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【四】Boolean]]></title>
    <url>%2F2019%2F02%2F27%2Fsource-code-java-4%2F</url>
    <content type="text"><![CDATA[1、已定义常量 public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); 2、字符串解析Boolean 判断是否为true字符串，不区分大小写 public static boolean parseBoolean(String s) { return ((s != null) &amp;&amp; s.equalsIgnoreCase("true")); } 4、toString 返回true或false字符串 public String toString() { return value ? "true" : "false"; } 5、hashCode true为1231，false为1237 至于为什么是1231和1237，可参考：https://blog.csdn.net/qq_21251983/article/details/52164403 @Override public int hashCode() { return Boolean.hashCode(value); } public static int hashCode(boolean value) { return value ? 1231 : 1237; } 6、equals 比较boolean是否一致 public boolean equals(Object obj) { if (obj instanceof Boolean) { return value == ((Boolean)obj).booleanValue(); } return false; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【三】StringBuffer与StringBuilder]]></title>
    <url>%2F2019%2F02%2F27%2Fsource-code-java-3%2F</url>
    <content type="text"><![CDATA[1、AbstractStringBuilder 下的append方法 public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; } 2、StringBuffer实现 public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } 3、StringBuilder实现 public StringBuilder append(String str) { super.append(str); return this; } 4、如上，类似的StringBuffer的相关操作方法都加了synchronized 修饰，是线程安全的 StringBuilder未加修饰，非线程安全。 5、append方法根据getChars直接复制字符到当前对象之后，未产生新的对象，避免了不断创建字符串对象。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【二】String类]]></title>
    <url>%2F2019%2F02%2F27%2Fsource-code-java-2%2F</url>
    <content type="text"><![CDATA[1、存储，char字符数组 private final char value[]; 2、初始化与复制 可见创建string是传递对象的引用，char[]拷贝数组的值 public String(String original) { this.value = original.value; this.hash = original.hash; } public String(char value[]) { this.value = Arrays.copyOf(value, value.length); } public String(char value[], int offset, int count) { if (offset &lt; 0) { throw new StringIndexOutOfBoundsException(offset); } if (count &lt; 0) { throw new StringIndexOutOfBoundsException(count); } // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) { throw new StringIndexOutOfBoundsException(offset + count); } this.value = Arrays.copyOfRange(value, offset, offset+count); } 3、字符串复制 复制当前字符串的子串到目标字符串 public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) { if (srcBegin &lt; 0) { throw new StringIndexOutOfBoundsException(srcBegin); } if (srcEnd &gt; value.length) { throw new StringIndexOutOfBoundsException(srcEnd); } if (srcBegin &gt; srcEnd) { throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); } System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); } 4、equals、contentEquals 先比较长度，再逐一比较字符串中的char是否一致，不一致则直接返回false public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } public boolean contentEquals(CharSequence cs) { // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) { if (cs instanceof StringBuffer) { synchronized(cs) { return nonSyncContentEquals((AbstractStringBuilder)cs); } } else { return nonSyncContentEquals((AbstractStringBuilder)cs); } } // Argument is a String if (cs instanceof String) { return equals(cs); } // Argument is a generic CharSequence char v1[] = value; int n = v1.length; if (n != cs.length()) { return false; } for (int i = 0; i &lt; n; i++) { if (v1[i] != cs.charAt(i)) { return false; } } return true; } 5、hashCode 字符串不一致的hashCode可能一致 public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } hashCode一致的情况 char[] chars1 = new char[] {0x01, 0x01}; char[] chars2 = new char[] {0x20}; String str1 = new String(chars1); String str2 = new String(chars2); System.out.println(str1.hashCode()); System.out.println(str2.hashCode()); System.out.println(str1.hashCode() == str2.hashCode()); 6、jdk8引入的字符串合并方法 public static String join(CharSequence delimiter, CharSequence... elements) { Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) { joiner.add(cs); } return joiner.toString(); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十九】安装confluence]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-19%2F</url>
    <content type="text"><![CDATA[#confluence+jira配置 #参考：https://blog.csdn.net/u012312884/article/details/76796719 #https://blog.csdn.net/hzx1464138068/article/details/79390606 --postgresql 用户数据库创建 CREATE USER user_confluence WITH PASSWORD 'user_confluence'; CREATE DATABASE db_confluence OWNER user_confluence; GRANT ALL PRIVILEGES ON DATABASE db_confluence to user_confluence; --安装 cd /home/soft/ tar xzvf atlassian-confluence-6.9.1.tar.gz mv atlassian-confluence-6.9.1 /home/app/ --用户创建 useradd confluence passwd confluence user password confluence confluence --目录创建于授权 chown -R confluence.confluence /home/app/atlassian-confluence-6.9.1 chmod -R 700 /home/app/atlassian-confluence-6.9.1 mkdir /home/data/confluence-home chown -R confluence.confluence /home/data/confluence-home chmod -R 700 /home/data/confluence-home --修改配置 cd /home/app/atlassian-confluence-6.9.1/ vi confluence/WEB-INF/classes/confluence-init.properties confluence.home=/home/data/confluence-home document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十八】安装golang]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-18%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software tar xzvf go1.10.1.linux-amd64.tar.gz echo "export GO_HOME=/home/software/go" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$GO_HOME/bin" &gt;&gt; /etc/profile echo "export GOPATH=$GO_HOME" &gt;&gt; /etc/profile source /etc/profile #测试 go version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十七】安装gitlab]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-17%2F</url>
    <content type="text"><![CDATA[#参考：https://www.gitlab.com.cn/installation/#centos-7 #安装 sudo yum install -y curl policycoreutils-python openssh-server sudo systemctl enable sshd sudo systemctl start sshd sudo firewall-cmd --permanent --add-service=http sudo systemctl reload firewalld sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash #下载地址：https://mirrors.tuna.tsinghua.edu.cn/gitlab-ee/yum/el7/ EXTERNAL_URL="http://192.168.233.20:10060" rpm -ivh gitlab-ee-10.6.3-ee.0.el7.x86_64.rpm firewall-cmd --permanent --zone=public --add-port=10060/tcp firewall-cmd --reload #访问 http://192.168.233.20:10060 root 111111 #说明 第一次使用root登录，会提示重置密码 #安装目录 /opt/gitlab #配置参考 https://docs.gitlab.com/omnibus/README.html#installation-and-configuration-using-omnibus-package document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十六】安装禅道Zentao]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-16%2F</url>
    <content type="text"><![CDATA[cd /opt tar xzvf ZenTaoPMS.biz1.1.3.zbox_64.tar.gz cd zbox ./zbox start #修改访问端口 /opt/zbox/zbox stop /opt/zbox/zbox -ap 28080 -mp 3307 /opt/zbox/zbox start #开启防火墙 firewall-cmd --permanent --zone=public --add-port=28080/tcp firewall-cmd --reload #访问 http://192.168.233.20:28080 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十五】安装接口管理-阿里RAP2]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-15%2F</url>
    <content type="text"><![CDATA[#安装rap2-delos git clone https://github.com/thx/rap2-delos.git CREATE DATABASE IF NOT EXISTS RAP2_DELOS_APP DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 配置文件 目录：rap2-delos/src/config 文件：config.dev.ts;其中dev，表示开发环境，其他同理 修改：config.dev.ts文件中db对象中username，password参数与本地或者开发环境的数据库信息匹配 npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm install npm run build npm run create-db npm run check #开发模式-启动开发模式的服务器 监视并在发生代码变更时自动重启 npm run dev #生产模式-启动生产模式服务器 npm start #开启防火墙 firewall-cmd --permanent --zone=public --add-port=20081/tcp firewall-cmd --reload #安装前端：rap2-dolores git clone https://github.com/thx/rap2-dolores.git 配置文件 目录：rap2-dolores/src/config 文件：config.dev.ts;其中dev，表示开发环境，其他同理 修改：config.dev.ts文件，serve地址是服务端rap2-delos部署成功后的地址，默认：'http://localhost:8080' 修改成指定ip: serve: 'http://192.168.233.20:20081', 安装项目依赖包 项目根目录下执行 cnpm install 安装启动插件 npm install -g serve 编译启动项目 开发模式-自动监视改变后重新编译 npm run dev 备注：测试用例 npm run test 生产模式-编译React生产包 npm run build 用serve命令或nginx服务器路由到编译产出的build文件夹作为静态服务器即可 serve -s ./build -p 20082 看到浏览器中出现登录页面，表示部署成功 #开启防火墙 firewall-cmd --permanent --zone=public --add-port=20082/tcp firewall-cmd --reload #访问 http://192.168.233.20:20082/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十四】安装mysql-5.7.13]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-14%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software tar xzvf mysql-boost-5.7.13.tar.gz mkdir -p /usr/local/mysql/data cd mysql-5.7.13 cmake \ -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \ -DMYSQL_UNIX_ADDR=/usr/local/mysql/mysql.sock \ -DDEFAULT_CHARSET=utf8 \ -DDEFAULT_COLLATION=utf8_general_ci \ -DWITH_MYISAM_STORAGE_ENGINE=1 \ -DWITH_INNOBASE_STORAGE_ENGINE=1 \ -DWITH_ARCHIVE_STORAGE_ENGINE=1 \ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ -DWITH_MEMORY_STORAGE_ENGINE=1 \ -DWITH_READLINE=1 \ -DENABLED_LOCAL_INFILE=1 \ -DMYSQL_DATADIR=/usr/local/mysql/data \ -DMYSQL_USER=mysql \ -DMYSQL_TCP_PORT=3306 \ -DENABLE_DOWNLOADS=1 \ -DDOWNLOAD_BOOST=1 \ -DWITH_BOOST=/home/software/mysql-5.7.13/boost/ -DWITH_EMBEDDED_SERVER=OFF make make install #安装killall yum install psmisc groupadd mysql useradd -g mysql mysql chmod +w /usr/local/mysql chown -R mysql:mysql /usr/local/mysql chmod -R 777 /usr/local/mysql cp support-files/my-default.cnf /usr/local/mysql/my.cnf mkdir -p /usr/local/mysql/log #[mysqld] echo "basedir = /usr/local/mysql" &gt;&gt; /usr/local/mysql/my.cnf echo "datadir=/usr/local/mysql/data" &gt;&gt; /usr/local/mysql/my.cnf echo "socket=/usr/local/mysql/mysql.sock" &gt;&gt; /usr/local/mysql/my.cnf echo "port = 3306" &gt;&gt; /usr/local/mysql/my.cnf #user=mysql echo "symbolic-links=0" &gt;&gt; /usr/local/mysql/my.cnf #echo "skip-grant-tables=1" &gt;&gt; /usr/local/mysql/my.cnf echo "[mysqld_safe]" &gt;&gt; /usr/local/mysql/my.cnf echo "log-error=/usr/local/mysql/log/mysqld.log" &gt;&gt; /usr/local/mysql/my.cnf echo "pid-file=/usr/local/mysql/mysqld.pid" &gt;&gt; /usr/local/mysql/my.cnf sed -i 's/^sql_mode=.*$/sql_mode=NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION/g' /usr/local/mysql/my.cnf echo "export MYSQL_PATH=/usr/local/mysql" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$MYSQL_PATH/bin" &gt;&gt; /etc/profile source /etc/profile cd /usr/local/mysql bin/mysql_install_db --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql bin/mysqld_safe --defaults-file=/usr/local/mysql/my.cnf --user=mysql --skip-grant-tables &amp; mysql -uroot -p -e " use mysql; update user set authentication_string=PASSWORD('111111') where user='root'; flush privileges; quit" killall mysqld_safe killall mysqld sleep 5 bin/mysqld_safe --defaults-file=/usr/local/mysql/my.cnf &amp; cd /home/software/mysql-5.7.13/ cp support-files/mysql.server /etc/init.d/mysql chmod +x /etc/init.d/mysql killall mysqld_safe killall mysqld sleep 5 service mysql restart #把mysql注册为开机启动的服务 chkconfig --add mysql #开启防火墙 firewall-cmd --permanent --zone=public --add-port=3306/tcp firewall-cmd --reload #初始化密码，设置权限 alter user 'root'@'localhost' identified by '111111'; GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.233.1' IDENTIFIED BY '111111'; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十三】安装sonarqube-7.0]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-13%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software unzip sonarqube-7.0.zip cd sonarqube-7.0 vi conf/sonar.properties sonar.web.port=19000 firewall-cmd --permanent --zone=public --add-port=19000/tcp firewall-cmd --reload vi bin/linux-x86-64/sonar.sh RUN_AS_USER=sonar su sonar bin/linux-x86-64/sonar.sh start #数据库配置 CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci; CREATE USER 'sonar' IDENTIFIED BY 'sonar'; GRANT ALL ON sonar.* TO 'sonar'@'%' IDENTIFIED BY 'sonar'; GRANT ALL ON sonar.* TO 'sonar'@'localhost' IDENTIFIED BY 'sonar'; FLUSH PRIVILEGES; #配置文件修改 sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance sonar.jdbc.username=sonar sonar.jdbc.password=sonar #访问 http://192.168.233.20:19000/ admin admin document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十二】安装gitblit]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-12%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software tar xzvf gitblit-1.8.0.tar.gz cd gitblit-1.8.0 #配置修改 vi data/defaults.properties server.httpPort = 10080 server.httpBindInterface = 192.168.233.20 web.otherUrls = http://192.168.233.20:10080/r/{0} firewall-cmd --permanent --zone=public --add-port=10080/tcp #测试 ./gitblit.sh #访问 http://192.168.233.20:10080 admin admin document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十一】安装nexus]]></title>
    <url>%2F2019%2F02%2F26%2Fcentos7-soft-install-11%2F</url>
    <content type="text"><![CDATA[#安装 firewall-cmd --permanent --zone=public --add-port=18081/tcp firewall-cmd --reload cd /home/software tar xzvf nexus-3.9.0-01-unix.tar.gz cd nexus-3.9.0-01 vi etc/nexus-default.properties application-port=18081 #测试 bin/nexus start #访问 http://192.168.15.16:18081/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【十】安装maven]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-10%2F</url>
    <content type="text"><![CDATA[#安装 wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.5.3/binaries/apache-maven-3.5.3-bin.tar.gz tar xzvf apache-maven-3.5.3-bin.tar.gz echo "export MVN_HOME=/home/software/apache-maven-3.5.3" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$MVN_HOME/bin" &gt;&gt; /etc/profile source /etc/profile document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【九】安装postgresql]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-9%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software tar xzvf postgresql-9.6.8.tar.gz cd postgresql-9.6.8 ./configure --prefix=/usr/local/postgresql --without-readline make &amp;&amp; make install cd contrib make &amp;&amp; make install echo "export PATH=\$PATH:/usr/local/postgresql/bin" &gt;&gt; /etc/profile source /etc/profile #添加用户 groupadd postgres useradd -g postgres postgres mkdir -p /home/postgresql/data mkdir -p /home/postgresql/logfile chown postgres:postgres /home/postgresql/data chown postgres:postgres /home/postgresql/ chmod -R 775 /usr/local/postgresql/ chmod -R 775 /home/postgresql/ #添加环境变量 echo "export POSTGRESQL_HOME=/usr/local/postgresql" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$POSTGRESQL_HOME/bin" &gt;&gt; /etc/profile source /etc/profile cp /home/software/postgresql-9.6.8/contrib/start-scripts/linux /etc/init.d/postgresql chmod u+x /etc/rc.d/init.d/postgresql #vi /etc/rc.d/init.d/postgresql sed -i 's/^prefix=.*$/prefix=\/usr\/local\/postgresql/g' /etc/rc.d/init.d/postgresql sed -i 's/^PGDATA=.*$/PGDATA="\/home\/postgresql\/data"/g' /etc/rc.d/init.d/postgresql #初始化数据库 su postgres cd /home/postgresql/data initdb -D /home/postgresql/data #创建用户 su root service postgresql start #设置密码 psql -U postgres alter user postgres with password 'postgres'; su postgres psql CREATE USER db_post WITH PASSWORD 'db_post'; CREATE DATABASE db_postOWNER db_post; GRANT ALL PRIVILEGES ON DATABASE db_post to db_post; #修改权限文件 cd /home/postgresql/data vi postgresql.conf listen_addresses = '*' vi pg_hba.conf host all all 192.168.0.1/16 md5 #安装postgresql插件，监控sql执行时间 vi postgresql.conf #------------------------------------------------------------------------------ # PG_STAT_STATEMENTS OPTIONS #------------------------------------------------------------------------------ shared_preload_libraries = 'pg_stat_statements' pg_stat_statements.max = 1000 pg_stat_statements.track = all #开放端口 firewall-cmd --permanent --zone=public --add-port=5432/tcp firewall-cmd --reload #安装插件 CREATE EXTENSION pg_stat_statements; SELECT query, calls, total_time, (total_time/calls) as average ,rows, 100.0 * shared_blks_hit /nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent FROM pg_stat_statements ORDER BY average DESC LIMIT 10; #重置统计信息 select pg_stat_statements_reset(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【八】安装nginx]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-8%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software tar xzvf openssl-1.0.2h.tar.gz cd openssl-1.0.2h ./config make &amp;&amp; make install cd /home/software tar xzvf pcre-8.39.tar.gz cd pcre-8.39 ./configure make &amp;&amp; make install cd /home/software tar xzvf zlib-1.2.8.tar.gz cd zlib-1.2.8 ./configure make &amp;&amp; make install cd /home/software tar xzvf nginx-1.13.11.tar.gz cd nginx-1.13.11 ./configure --prefix=/usr/local/nginx --with-http_auth_request_module --with-http_ssl_module --with-pcre=/home/software/pcre-8.39 --with-openssl=/home/software/openssl-1.0.2h --with-zlib=/home/software/zlib-1.2.8 make make install cp /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf_bak #开放端口 firewall-cmd --permanent --zone=public --add-port=80/tcp #测试 /usr/local/nginx/sbin/nginx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【七】安装fastdfs]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-7%2F</url>
    <content type="text"><![CDATA[mkdir -p /home/fdfs/data git clone https://github.com/happyfish100/libfastcommon.git cd libfastcommon/ ./make.sh ./make.sh install rm -f /usr/local/lib/libfastcommon.so rm -f /usr/lib/libfastcommon.so rm -f /usr/local/lib/libfdfsclient.so rm -f /usr/lib/libfdfsclient.so ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so git clone https://github.com/happyfish100/fastdfs.git cd fastdfs/ make make install 配置文件修改 cd /etc/fdfs/ cp tracker.conf.sample tracker.conf cp storage.conf.sample storage.conf cp client.conf.sample client.conf #修改ip local_ip=`/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d "addr:"` echo $local_ip #sed -i 's/^base_path=\/home\/yuqing\/fastdfs/base_path=\/home\/fdfs\/data/g' /etc/fdfs/tracker.conf sed -i 's/^base_path=.*$/base_path=\/home\/fdfs\/data/g' /etc/fdfs/tracker.conf sed -i 's/^bind_addr=.*$/bind_addr='"$local_ip"'/g' /etc/fdfs/tracker.conf sed -i 's/^base_path=.*$/base_path=\/home\/fdfs\/data/g' /etc/fdfs/storage.conf sed -i 's/^bind_addr=.*$/bind_addr='"$local_ip"'/g' /etc/fdfs/storage.conf sed -i 's/^store_path0=.*$/store_path0=\/home\/fdfs\/data/g' /etc/fdfs/storage.conf sed -i 's/^tracker_server=.*$/tracker_server='"$local_ip:22122"'/g' /etc/fdfs/storage.conf sed -i 's/^base_path=.*$/base_path=\/home\/fdfs\/data/g' /etc/fdfs/client.conf sed -i 's/^tracker_server=.*$/tracker_server='"$local_ip:22122"'/g' /etc/fdfs/client.conf #启动 fdfs_trackerd /etc/fdfs/tracker.conf fdfs_storaged /etc/fdfs/storage.conf document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【六】安装git]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-6%2F</url>
    <content type="text"><![CDATA[#安装准备，git-2.17.0 #删除原装git yum remove git #安装gcc yum install gcc #安装g++ yum install gcc-c++ #安装编译所需的包 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev yum install gcc perl-ExtUtils-MakeMaker #开始安装 cd /home/software wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.17.0.tar.gz tar xzvf git-2.17.0.tar.gz cd git-2.17.0 ./configure --prefix=/usr/local/git-2.17.0 make make install echo "export GIT_HOME=/usr/local/git-2.17.0" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$GIT_HOME/bin" &gt;&gt; /etc/profile source /etc/profile document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【五】安装ftp]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-5%2F</url>
    <content type="text"><![CDATA[#安装 yum install ftp vsftpd #设置开机启动 systemctl enable vsftpd.service #启动 systemctl start vsftpd.service #停止 systemctl stop vsftpd.service #查看状态 systemctl status vsftpd.service 权限配置 sed -i 's/^#chroot_list_enable=YES$/chroot_list_enable=YES/g' /etc/vsftpd/vsftpd.conf sed -i 's/^#chroot_list_file=\/etc\/vsftpd.chroot_list$/chroot_list_file=\/etc\/vsftpd\/chroot_list/g' /etc/vsftpd/vsftpd.conf sed -i 's/^anonymous_enable=YES$/anonymous_enable=NO/g' /etc/vsftpd/vsftpd.conf echo "pasv_min_port=61001" &gt;&gt; /etc/vsftpd/vsftpd.conf echo "pasv_max_port=62000" &gt;&gt; /etc/vsftpd/vsftpd.conf mkdir -p /home/ftp useradd -d /home/ftp/ftpuser -g ftp -s /sbin/nologin ftpuser passwd ftpuser setsebool -P ftpd_disable_trans 1 setsebool -P ftp_home_dir 1 firewall 防火墙配置 firewall-cmd --zone=public --add-service=ftp --permanent firewall-cmd --zone=public --add-port=21/tcp --permanent firewall-cmd --zone=public --add-port=61001-62000/tcp --permanent document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【四】安装redis]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-4%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software tar xzf redis-4.0.9.tar.gz cd redis-4.0.9 make MALLOC=libc echo "export REDIS_HOME=/home/software/redis-4.0.9" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$REDIS_HOME/src" &gt;&gt; /etc/profile source /etc/profile #测试 redis-server redis.conf document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【三】安装nodejs]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-3%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software xz -d node-v8.11.1-linux-x64.tar.xz tar xvf node-v8.11.1-linux-x64.tar echo "export NODE_HOME=/home/software/node-v8.11.1-linux-x64" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$NODE_HOME/bin" &gt;&gt; /etc/profile source /etc/profile #测试 node -v npm -v document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【二】安装JDK]]></title>
    <url>%2F2019%2F02%2F25%2Fcentos7-soft-install-2%2F</url>
    <content type="text"><![CDATA[#安装 cd /home/software/software/ tar xzvf jdk-8u162-linux-x64.tar.gz echo "export JAVA_HOME=/home/software/software/jdk1.8.0_162" &gt;&gt; /etc/profile echo "export PATH=\$PATH:\$JAVA_HOME/bin" &gt;&gt; /etc/profile source /etc/profile #测试 java -version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件安装系列【一】安装vpn]]></title>
    <url>%2F2018%2F05%2F19%2Fcentos7-soft-install-1%2F</url>
    <content type="text"><![CDATA[安装环境：腾讯云、Centos7、Hongkong Server 一、服务端安装步骤： 1、安装ppp , pptpd 和 iptables。 yum install update yum -y install ppp pptpd yum install iptables2、配置pptpd.conf 去掉以下两项前面的";" vi /etc/pptpd.conf localip 119... #注意修改成腾讯云外网ip remoteip 192.168.0.234-238,192.168.0.2453、配置options.pptpd中的dns vi /etc/ppp/options.pptpd 默认dns： ms-dns 8.8.8.8 ms-dns 8.8.4.4 其他的dns： ms-dns 208.67.222.222 ms-dns 208.67.220.220 4、配置连接VPN客户端要用到的帐号密码 vi /etc/ppp/chap-secrets client server secret IP addresses 用户名 pptpd 密码 * 5、配置sysctl.conf 将以下内容加入配置文件 vi /etc/sysctl.conf vm.swappiness = 0 net.ipv4.neigh.default.gc_stale_time=120 net.ipv4.conf.all.rp_filter=0 net.ipv4.conf.default.rp_filter=0 net.ipv4.conf.default.arp_announce = 2 net.ipv4.conf.all.arp_announce=2 net.ipv4.tcp_max_tw_buckets = 5000 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 1024 net.ipv4.tcp_synack_retries = 2 net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1 net.ipv4.conf.lo.arp_announce=2 net.ipv4.ip_forward = 16、配置iptables文件 腾讯云默认添加转发网卡为内网网卡eth0 vi /etc/sysconfig/iptables # Generated by iptables-save v1.4.21 on Sat May 19 10:44:10 2018 *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [26:3094] -A INPUT -p gre -j ACCEPT -A INPUT -p tcp -m tcp --dport 47 -j ACCEPT -A INPUT -p tcp -m tcp --dport 1723 -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -m state --state ESTABLISHED -j ACCEPT -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT COMMIT # Completed on Sat May 19 10:44:10 2018 # Generated by iptables-save v1.4.21 on Sat May 19 10:44:10 2018 *nat :PREROUTING ACCEPT [8:660] :INPUT ACCEPT [8:660] :OUTPUT ACCEPT [18:1443] :POSTROUTING ACCEPT [18:1443] #-A POSTROUTING -s 192.168.0.0/24 -o Virtio -j MASQUERADE -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE COMMIT # Completed on Sat May 19 10:44:10 20187、内外网不能同时访问问题 在以下文件加入如下内容vi /etc/ppp/ip-up /sbin/ifconfig $1 mtu 15008、重启服务 systemctl restart iptables systemctl restart pptpd二、客户端windows10连接 操作步骤：开始–》设置–》VPN 如下图： 具体的配置如下： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Centos7软件安装系列</category>
      </categories>
      <tags>
        <tag>Centos7软件安装系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码看JAVA【一】ArrayList与LinkedList在插入删除查询的区别]]></title>
    <url>%2F2018%2F05%2F07%2Fsource-code-java-1%2F</url>
    <content type="text"><![CDATA[1、插入 1.1、ArrayList实现 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; }1.2、LinkedList实现 /** * Links e as last element. */ void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } /** * Inserts element e before non-null Node succ. */ void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); }1.3、对比 ArrayList插入时，先将插入下标之后的所有元素往后复制一遍（下标+1）；然后再将元素设置到指定下标。 LinkedList插入时，先根据值创建节点元素；然后修改插入位置前后节点的索引。 总结：ArrayList在插入时比LinkedList多进行了元素的复制，会消耗一定的时间，在插入元素时比LinkedList性能要低。 2、删除 2.1、ArrayList实现 /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; }2.2、LinkedList实现 /** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } /** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; }2.3、对比 ArrayList删除时，先将插入下标之后的所有元素往前复制一遍（下标-1）；然后将元素置空，并减少List长度。 LinkedList删除时，将删除节点的前节点指针指向后节点，然后将元素置空，并减少List长度。 总结：ArrayList在删除时比LinkedList多进行了元素的复制，会消耗一定的时间，在删除元素时比LinkedList性能要低。 3、查询 3.1、ArrayList实现 E elementData(**int **index) { **return **(E) **elementData**[index]; }3.2、LinkedList实现 _/** __ * Returns the (non-null) Node at the specified element index. __ */ _Node&lt;E&gt; node(**int **index) { _// assert isElementIndex(index); __ __ _**if **(index &lt; (**size **&gt;&gt; 1)) { Node&lt;E&gt; x = **first**; **for **(**int **i = 0; i &lt; index; i++) x = x.**next**; **return **x; } **else **{ Node&lt;E&gt; x = **last**; **for **(**int **i = **size **- 1; i &gt; index; i--) x = x.**prev**; **return **x; } }2.3、对比 ArrayList查询定位时，直接根据数组索引获取元素。 LinkedList查询定位时，需要遍历到指定的位置获取元素。 总结：ArrayList在查询时比LinkedList少了元素遍历，比LinkedList性能要高。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>源码看JAVA</category>
      </categories>
      <tags>
        <tag>源码看JAVA</tag>
      </tags>
  </entry>
</search>
